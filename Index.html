<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dashboard</title>
<style>
  :root{
    --green1:#12b886;
    --green2:#0ca678;
    --tab-h:56px;
    --anim:0.75s;
  }

  /* Loading bar */
  #loadingBarWrap{position:fixed;top:0;left:0;right:0;height:4px;z-index:9999;overflow:hidden;pointer-events:none}
  #loadingBar{position:absolute;top:0;left:-40%;height:100%;width:40%;
    background:linear-gradient(90deg,#9ff6d0,#26b893,#9ff6d0);animation:none}
  @keyframes indeterminate{0%{left:-40%;width:40%}50%{left:20%;width:60%}100%{left:100%;width:40%}}

 /* === DASHBOARD SHEET (Notes-style) ======================================== */
:root{
  --dash-handle-h: 88px;
  /* Full screen height using dynamic viewport units */
  --dash-open-h: 100dvh;
}


/* Dark backdrop for Dashboard */
#dashOverlay{
  position: fixed; inset: 0;
  background: rgba(0,0,0,.35);
  display: none;
  z-index: 10040; /* just below notes (10050) so Notes can still sit above if both open */
}

#dashSheet{
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 10055;   /* above #dashOverlay */
  /* Keep rounded top corners visible when minimized */
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  box-shadow: 0 -8px 24px rgba(0,0,0,.25);
  background: #fff;

  /* Fill the entire screen height */
  height: var(--dash-open-h);
  max-height: var(--dash-open-h);
  width: 100%;

  display: flex;
  flex-direction: column;

  /* Closed state sits with only the handle visible; open = slide to full height */
  transform: translateY(calc(100% - var(--dash-handle-h)));
  transition: transform .25s ease;
  will-change: transform;
  contain: layout paint;
}


/* Green handle / tap target */
#dashHandle{
  height: var(--dash-handle-h);
  background: linear-gradient(135deg, var(--green1), var(--green2));
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  display: flex; align-items: center; justify-content: center;
  color: #fff;
  font-weight: 800; letter-spacing: .3px;
  cursor: pointer; user-select: none;
  position: relative; z-index: 1;
}

/* Scrollable body area */
#dashBody{
  flex: 1 1 auto;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 12px 14px 16px;
  min-height: 0;
}

/* Open/Closed states */
#dashSheet.dashboard-open  { transform: translateY(0); }
#dashSheet.dashboard-closed{ transform: translateY(calc(100% - var(--dash-handle-h))); }

/* Optional: cards reused inside Dashboard */
#dashBody .card{border:1px solid #e9ecef;border-radius:14px;padding:10px;margin-bottom:12px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
#dashBody .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

/* Reuse your textarea & buttons from earlier */
#dashBody #noteInput{
  width:100%;min-height:150px;resize:vertical;
  font-size:28px;line-height:1.35;padding:12px;border-radius:12px;border:1px solid #ced4da;
}

#dashBody .btn{border:0;border-radius:10px;padding:6px 10px;font-size:11px;font-weight:800;cursor:pointer}
#dashBody .btn:active{transform:translateY(1px)}
#dashBody #addBtn{background:linear-gradient(135deg,var(--green1),var(--green2));color:#fff}



#dashBody #recentList .item{display:flex;gap:10px;align-items:flex-start;padding:8px 6px;border-bottom:1px dashed #e5e7eb}
#dashBody #recentList .note{flex:1;white-space:pre-wrap;font-size:16px}
#dashBody #recentList .meta{font-size:11px;color:#495057}
#dashBody #recentList .assigned{font-weight:800;color:#0ca678}
#dashBody input[type="text"].small{padding:6px 8px;border:1px solid #ced4da;border-radius:8px;font-size:12px}



/* === Mobile fit & 50% viewport textarea ================================ */
@media (max-width: 640px) {
  /* Ensure the sheet and handle span the full width */
  #dashSheet { width: 100vw; max-width: 100vw; }
  #dashHandle { width: 100%; }

  /* Make the textarea consume half the screen height */
  #dashBody #noteInput{
    width: 100%;
    /* Use small-viewport units to avoid iOS URL bar issues */
    height: 50svh;
    min-height: 50svh;
    max-height: 50svh;
  }

  /* Keep action row from overflowing; stack buttons full-width */
  #dashBody .row{
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
 #dashBody .btn,
#dashBody #addBtn{
  width: 100%;
  margin-left: 0;
  margin-right: 0;
}


  /* Avoid horizontal scroll due to padding */
  #dashBody{
    padding-left: 12px;
    padding-right: 12px;
    box-sizing: border-box;
  }
}

/* === ACTION ROW: keep side-by-side on all sizes ========================= */
#actionRow {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}

/* Left stays left; right stays right via spacer */
#actionRow .left-actions,
#actionRow .right-actions {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex: 0 0 auto !important;
}

/* Spacer pushes the mic to the far right */
#actionRow .spacer {
  flex: 1 1 auto !important;
  min-width: 8px;
}

/* Prevent the global mobile rule from making these buttons full-width */
#actionRow .btn,
#actionRow #addBtn,
#actionRow #voiceToggleBtn {
  width: auto !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}

/* Ensure the row never collapses or wraps weirdly */
#actionRow { flex-wrap: nowrap !important; }
#actionRow .left-actions,
#actionRow .right-actions { flex-wrap: nowrap !important; }

/* Mic visual style stays, but sizing is sane for tight rows */
#voiceToggleBtn {
  border: 1px solid #ced4da;
  background: #F8FAF8;
  border-radius: 10px;
  font-size: 32px;
  padding: 10px 14px;
}

/* On very narrow phones, still keep one line */
@media (max-width: 640px) {
  #actionRow { flex-direction: row !important; }
  #actionRow .btn,
  #actionRow #addBtn,
#actionRow #voiceToggleBtn { width: auto !important; }
}


.usage-counter {
  display: flex;
  align-items: center;
  gap: 8px;
}

#usageCounterBtn {
  border: 1px solid #ced4da;
  background: #f8f9fa;
  border-radius: 10px;
  font-size: 28px;
  padding: 8px 12px;
}

.floatingUtilityBtn {
  position: fixed;
  bottom: 18px;
  width: 72px;
  height: 72px;
  border-radius: 50%;
  border: 0;
  outline: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  font-size: 32px;
  background: linear-gradient(135deg, #fff, #f8f9fa);
  color: #212529;
  box-shadow: 0 8px 24px rgba(0,0,0,.22);
  cursor: pointer;
  z-index: 200101; /* one step above floating mic */
  transition: transform .08s ease, box-shadow .12s ease;
}

.floatingUtilityBtn:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(0,0,0,.25); }
.floatingUtilityBtn:active { transform: translateY(1px); box-shadow: 0 6px 18px rgba(0,0,0,.18); }

#floatingUsageBtn { right: 16px; }
#floatingEmailBtn { right: 102px; }

#floatingUsageBtn .usage-pill {
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 999px;
  background: #e9ecef;
  color: #212529;
  line-height: 1.2;
  white-space: nowrap;
}

.usage-counter .usage-meta {
  display: flex;
  flex-direction: column;
  line-height: 1.2;
  font-size: 14px;
  color: #495057;
}


/* === Mobile textarea height (leave room for buttons) ===================== */
@media (max-width: 640px) {
  #dashBody textarea#noteInput {
    height: 50dvh !important;
    min-height: 50dvh !important;
    max-height: 50dvh !important;
    width: 100% !important;
    box-sizing: border-box;
    resize: vertical;
  }
}



/* === 2x SCALE OVERRIDES (fonts + textarea) ============================== */
/* Global bump for rem/em-based text */
html { font-size: 200%; }

/* Make the green handle label bigger */
#dashHandle { font-size: 2rem; }

/* Double the textarea font + desktop min-height (150px -> 300px) */
#dashBody #noteInput {
  font-size: 75px;     /* was 28px */
  min-height: 550px;   /* was 150px */
}

/* Double common px-based text */
#dashBody .btn                { font-size: 44px; }  /* was 11px */
#dashBody #recentList .note   { font-size: 64px; }  /* was 16px */
#dashBody #recentList .meta   { font-size: 44px; }  /* was 11px */
#dashBody input[type="text"].small { font-size: 48px; }  /* was 12px */
/* === VOICE ROW HELPERS (scoped) ======================================= */
#actionRow .emoji-btn{
  line-height: 1;
  padding: 6px 10px;
}
#actionRow{ gap: 8px; }
#actionRow .left-actions,
#actionRow .right-actions{ flex: 0 0 auto; }

/* Keep mic/ADD row visible at the bottom of its card */
.card { position: relative; }
#actionRow {
  position: sticky;
  bottom: 0;
  background: #fff;
  padding-top: 8px;
  z-index: 2; /* above textarea content */
}
/* Make the mic button easy to see and tap */
#voiceToggleBtn {
  border: 1px solid #ced4da;
  background: #f8f9fa;
  border-radius: 10px;
}


/* === Toast notification (bottom-center) ================================ */
#toast{
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translateX(-50%) translateY(8px);
  background: rgba(33, 37, 41, .96);
  color: #fff;
  padding: 12px 16px;
  border-radius: 10px;
  font-weight: 700;
  font-size: 16px;
  letter-spacing: .2px;
  box-shadow: 0 10px 24px rgba(0,0,0,.25);
  z-index: 10080; /* above overlays/sheets */
  opacity: 0;
  pointer-events: none;
  transition: opacity .18s ease, transform .18s ease;
}
#toast.show{
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
@media (max-width:640px){

  #toast{ 
    width: calc(100vw - 24px);
    text-align: center;
    font-size: 18px;
  }
}
/* === TOP-OF-SCREEN LOADING BAR (BLUE) =================================== */
#loadingBarWrap{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  z-index: 200000;        /* keep above overlays/sheets/toasts */
  overflow: hidden;
  pointer-events: none;
}

#loadingBar{
  position: absolute;
  top: 0;
  left: -40%;
  height: 100%;
  width: 40%;
  /* Blue gradient (was green) */
  background: linear-gradient(90deg, #9ec5fe, #1d4ed8, #9ec5fe);
  animation: none;        /* set by startLoading() */
}

@keyframes indeterminate{
  0%   { left: -40%; width: 40%; }
  50%  { left: 20%;  width: 60%; }
  100% { left: 100%; width: 40%; }
}

/* === RECENT ROW: never wrap; we'll shrink font-size instead === */
.recent-row#recentRow {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;   /* prevent wrap */
  overflow: hidden;    /* clip during measurement */
}

/* Chips take remaining space, single line only */
.recent-row#recentRow .recent-bar.inside-autocomplete {
  flex: 1 1 auto;
  display: flex;
  flex-wrap: nowrap;   /* prevent wrap */
  gap: 6px;
  min-width: 0;        /* allow shrinking */
  overflow: hidden;    /* clip while shrinking */
  white-space: nowrap; /* single line */
}


.assigned-chip-slot { margin-top: 6px; display: flex; flex-wrap: wrap; gap: 6px; }

/* Compact chips just in the recent list‚Äôs chip slot */
.assigned-chip-slot .chip--xs{
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 10px;
  line-height: 1.2;
  box-shadow: none;
}

/* If your chip has internal parts, keep them tiny too */
.assigned-chip-slot .chip--xs .chip-initials,
.assigned-chip-slot .chip--xs .chip-date,
.assigned-chip-slot .chip--xs .chip-text{
  font-size: 11px;
}

/* If there‚Äôs an avatar/icon inside the chip */
.assigned-chip-slot .chip--xs .chip-icon,
.assigned-chip-slot .chip--xs img{
  width: 14px;
  height: 14px;
}

/* NEW CLIENT button sits on the right, doesn't wrap */
#addNewClientBtn {
  flex: 0 0 auto;
  white-space: nowrap;
}

/* Make sure pills themselves don't wrap internal content */
.recent-pill {
  white-space: nowrap;
}

/* === LEFT-LIGHTBULB FOR GREEN SUGGESTION BOXES === */
/* Make the green suggestion block a row: bulb (left) + textarea (right) */
.toplist-suggestion {
  display: flex;              /* row layout */
  align-items: flex-start;    /* top-align the textarea with the icon */
  gap: 10px; 
    background-color: #90EE90;  /* light green */
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  margin-top: 8px;
  width: 100%;
  box-sizing: border-box;                 /* space between bulb and textarea */
}

.toplist-suggestion .bulb {

  flex: 0 0 auto;
  font-size: 1.25em;
  line-height: 1;
  margin-top: 4px;
}

/* Let the textarea fill the remaining width */
.toplist-suggestion .note-textarea,
.toplist-suggestion textarea,
.toplist-suggestion textarea.toplist-textarea {  flex: 1 1 auto;
  width: 100%;
  box-sizing: border-box;
    background: #90EE90;

}



/* Make the green suggestions card a left-bulb / right-textarea row */
.toplist-suggestion {
  display: flex;                 /* row layout */
  align-items: flex-start;
  gap: 10px;
}

.toplist-suggestion .bulb {
  font-size: 1.25em;
  line-height: 1;
  margin-top: 4px;
  flex: 0 0 auto;
}

/* Keep textarea full-width inside the green card */
.toplist-suggestion .note-textarea,
.toplist-suggestion textarea.toplist-textarea {
  flex: 1 1 auto;
  width: 100%;
  background: #90EE90;
  box-sizing: border-box;
   overflow: hidden;  /* no scrollbars; JS will shrink text */
  resize: none;
}

.toplist-suggestion .note-textarea:focus,
.toplist-suggestion textarea:focus,
.toplist-suggestion textarea.toplist-textarea:focus {
  background: white;
}


/* REMOVE UNDERLINES FROM ALL LINKS (KEEP BLUE COLOR) */
a,
a:link,
a:visited,
a:hover,
a:active,
a:focus {
  text-decoration: none !important;
  color: var(--darker-blue, #007bff);
}

/* === CHIP 10x MINI OVERRIDES (scoped) ============================== */
/* Scope 1: chips under the assigned client box */
.assigned-chip-slot {
  /* nothing needed here; just the scope */
}

/* Scope 2: chips shown in the recent bar inside the autocomplete (if used) */
.recent-row#recentRow .recent-bar.inside-autocomplete {
  /* scope for recent mini chips */
}

/* Make ANY .chip (or your custom chip) in these scopes ~10x smaller */
.assigned-chip-slot .chip,
.assigned-chip-slot .chip--xs,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip--xs {
  /* shrink text */
  font-size: 10% !important;      /* ~10x smaller */
  line-height: 1 !important;

  /* shrink padding using em so it scales with the tiny font */
  padding: 0.2em 0.4em !important;
  border-radius: 1em !important;

  /* keep them inline and tight */
  display: inline-flex !important;
  align-items: center !important;
  gap: 0.35em !important;

  /* override any big box-shadow/borders if present */
  box-shadow: none !important;
  border-width: 1px !important;
}

/* If your chip has labeled parts, keep them inheriting the tiny size */
.assigned-chip-slot .chip .chip-initials,
.assigned-chip-slot .chip .chip-date,
.assigned-chip-slot .chip .chip-text,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-initials,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-date,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-text {
  font-size: 1em !important;   /* inherit the 10% scale */
  line-height: 1 !important;
}

/* If the chip includes an icon/avatar/image, scale it with the text */
.assigned-chip-slot .chip .chip-icon,
.assigned-chip-slot .chip img,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-icon,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip img {
  width: 1.2em !important;
  height: 1.2em !important;
  object-fit: cover;
}

/* Optional: tiny separator dot if you render initials/date as separate parts */
.assigned-chip-slot .chip .chip-sep,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-sep {
  font-size: 1em !important;
  opacity: .6;
  margin: 0 .25em !important;
}


/* === CHIP 20x MINI (final reducer to half the previous size) ============ */
/* Apply ONLY in the assigned chip slot and recent-bar scopes */
.assigned-chip-slot .chip,
.assigned-chip-slot .chip--xs,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip--xs {
  font-size: 5% !important;        /* was 10%; now ~2√ó smaller again */
  line-height: 1 !important;
  padding: 0.15em 0.30em !important;
  border-radius: 0.8em !important;
  display: inline-flex !important;
  align-items: center !important;
  gap: 0.25em !important;
  box-shadow: none !important;
  border-width: 1px !important;
  letter-spacing: normal !important;
  transform: none !important;      /* neutralize any external scaling */
  white-space: nowrap !important;  /* keep tiny chips on one line */
  min-height: 0 !important;
  min-width: 0 !important;
}

/* Keep internal parts equally tiny */
.assigned-chip-slot .chip .chip-initials,
.assigned-chip-slot .chip .chip-date,
.assigned-chip-slot .chip .chip-text,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-initials,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-date,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-text {
  font-size: 1em !important;       /* inherit the 5% parent size */
  line-height: 1 !important;
}

/* Icons/avatars inside chips */
.assigned-chip-slot .chip .chip-icon,
.assigned-chip-slot .chip img,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip .chip-icon,
.recent-row#recentRow .recent-bar.inside-autocomplete .chip img {
  width: 1em !important;
  height: 1em !important;
  object-fit: cover !important;
  flex: 0 0 auto !important;
}
/* === FLOATING MIC BUTTON (always visible) ================================ */
#floatingMicBtn{
  position: fixed;
  left: 16px;
  bottom: 18px;
  width: 128px;
  height: 128px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60px;               /* üé§ / ‚èπÔ∏è size */
  border: 0;
  outline: none;
  cursor: pointer;
  z-index: 200100;               /* above toasts/sheets/loading bars */
  background: linear-gradient(135deg, var(--green1), var(--green2));
  color: #fff;
  box-shadow: 0 8px 24px rgba(0,0,0,.25);
  transition: transform .08s ease, box-shadow .12s ease, background .2s ease;
}
#floatingMicBtn:hover{ transform: translateY(-1px); box-shadow: 0 10px 28px rgba(0,0,0,.28); }
#floatingMicBtn:active{ transform: translateY(1px); box-shadow: 0 6px 18px rgba(0,0,0,.22); }

/* ‚Äúinactive‚Äù look when not supported */
#floatingMicBtn.is-disabled{
  background: #ced4da;
  color: #495057;
  cursor: not-allowed;
}

/* Small boost to the inline mic in the action row so it stands out too */
#voiceToggleBtn{
  font-size: 32px;         /* ensure emoji is large enough to notice */
  padding: 10px 14px;
}

</style>
</head>



<body>
  <!-- your dashboard stays under this -->
<!-- Keep these elements once in your HTML -->


<!-- Loading bar -->

  <div id="loadingBarWrap"><div id="loadingBar"></div></div>
<!-- Floating always-visible mic button -->
<button id="floatingMicBtn" aria-label="Start voice input (floating)">üé§</button>
<!-- Floating usage counter (calculator) opposite the mic -->
<button id="floatingUsageBtn" class="floatingUtilityBtn" aria-label="Usage counter" title="Usage counter">
  <span aria-hidden="true">üßÆ</span>
  <span id="floatingUsageCount" class="usage-pill" aria-live="polite">0</span>
  <span id="floatingUsageMinutes" class="usage-pill" aria-live="polite">0m</span>
</button>
<!-- Floating email trigger next to calculator -->
<button id="floatingEmailBtn" class="floatingUtilityBtn" aria-label="Send summary email" title="Send summary email">
  <span aria-hidden="true">‚úâÔ∏è</span>
</button>

  <!-- Toast -->
  <div id="toast" role="status" aria-live="polite"></div>


  <!-- Overlay that slides; tab moves with it -->
  <!-- === DASHBOARD (Notes-style bottom sheet) ============================= -->
<div id="dashOverlay" aria-hidden="true"></div>
<div id="dashSheet" class="dashboard-closed" aria-hidden="true">
  <div id="dashHandle" role="button" aria-controls="dashSheet" aria-expanded="false">
     CHANGE VIEW
  </div>

  <div id="dashBody" role="region" aria-label="Dashboard content">
    <div class="card">
      <textarea id="noteInput"></textarea>
      
<div class="row" id="actionRow" style="margin-top:8px; align-items:center;">
  <!-- LEFT: Voice toggle (üé§ ‚Üí ‚èπÔ∏è) -->
  <div class="left-actions" style="display:flex; align-items:center; gap:8px;">
    <button id="voiceToggleBtn" class="btn emoji-btn" aria-label="Start voice input" title="Start voice">üé§</button>
  </div>

  <!-- Spacer pushes the ADD button to the far right -->
  <div class="spacer" style="flex:1 1 auto;"></div>

  <!-- RIGHT: ADD button + status -->
  <div class="right-actions" style="display:flex; align-items:center; gap:8px;">
    <div id="usageCounterWrap" class="usage-counter" aria-live="polite">
      <button id="usageCounterBtn" class="btn emoji-btn" aria-label="Usage counter" title="Usage counter">üßÆ</button>
      <div class="usage-meta">
        <div id="usageCountDisplay" class="usage-line">0 actions</div>
        <div id="usageMinutesDisplay" class="usage-line">0 min</div>
      </div>
    </div>
    <button id="addBtn" class="btn">ADD</button>
    <span id="addStatus" class="meta" style="margin-left:4px"></span>
  </div>
</div>




    </div>

    <div class="card" id="recentCard">
      <div id="recentList"></div>
    </div>
  </div>
</div>
<!-- ===================================================================== -->


  <!-- Autocomplete (same list as main page, minus category) -->
  <datalist id="clientNamesList"></datalist>

<script>

  /* =========================
   Notes Inbox + Speech Input
   ========================= */

/** Toast helper **/
function showToast(msg, ms=1700){
  const t = document.getElementById('toast');
  if(!t) return;
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), ms);
}

/** Add a note to "recentList" (simulates Notes Inbox) **/
function addNote(text){
  const trimmed = (text || '').trim();
  const area = document.getElementById('noteInput');
  if(!trimmed){
    showToast('Nothing to add');
    return;
  }
  const list = document.getElementById('recentList');
  const item = document.createElement('div');
  item.className = 'item';
  item.innerHTML = `
    <div class="note"></div>
    <div class="meta">Saved ${new Date().toLocaleString()}</div>
  `;
  item.querySelector('.note').textContent = trimmed;
  list.prepend(item);

  // Clear textarea after add
  if(area) area.value = '';
  showToast('Note saved');
}

/** Wire up ADD button (manual add) **/
document.getElementById('addBtn')?.addEventListener('click', () => {
  const text = document.getElementById('noteInput')?.value || '';
  addNote(text);
});

/* =========================
   Web Speech (no triple print)
   =========================
   Why triple printing happens:
   - Multiple listeners get attached across re-renders
   - interimResults are appended repeatedly
   Fix:
   - Single recognition instance
   - interimResults = false (finals only)
   - Append only final transcript once per result
*/
let recognition = null;
let recognizing = false;
let sessionBuffer = '';   // accumulate per session only

/* === Single toggle button for voice: üé§ (start) <-> ‚èπÔ∏è (stop+auto-add) === */
const voiceToggleBtn = document.getElementById('voiceToggleBtn');
/* Floating mic wiring: mirrors the inline üé§ button and stays in sync */
const floatingMicBtn = document.getElementById('floatingMicBtn');

function setFloatingMicUI(listening){
  if(!floatingMicBtn) return;
  floatingMicBtn.textContent = listening ? '‚èπÔ∏è' : 'üé§';
  floatingMicBtn.setAttribute('aria-label', listening ? 'Stop and save to Notes Inbox (floating)' : 'Start voice input (floating)');
}

floatingMicBtn?.addEventListener('click', ()=>{
  if(recognizing){
    stopVoiceAndAutoAdd();
    setVoiceButtonUI(false);    // keep inline button in sync
    setFloatingMicUI(false);    // update floating button UI
  }else{
    startVoice();
    setVoiceButtonUI(true);
    setFloatingMicUI(true);
  }
});

// Keep both buttons synchronized if recognition ends elsewhere
(function syncAllVoiceButtons(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){
    // Speech not supported: disable floating button visually
    if (floatingMicBtn){
      floatingMicBtn.classList.add('is-disabled');
      floatingMicBtn.disabled = true;
      floatingMicBtn.title = 'Speech recognition not supported in this browser';
    }
    return;
  }
  // Poll lightly so UI reflects true listening state even on unexpected onend
  setInterval(()=>{ 
    setVoiceButtonUI(!!recognizing);
    setFloatingMicUI(!!recognizing);
  }, 500);
})();

function setVoiceButtonUI(listening){
  if(!voiceToggleBtn) return;
  if(listening){
    voiceToggleBtn.textContent = '‚èπÔ∏è';
    voiceToggleBtn.setAttribute('aria-label','Stop and save to Notes Inbox');
    voiceToggleBtn.title = 'Stop & save';
  }else{
    voiceToggleBtn.textContent = 'üé§';
    voiceToggleBtn.setAttribute('aria-label','Start voice input');
    voiceToggleBtn.title = 'Start voice';
  }
}

voiceToggleBtn?.addEventListener('click', ()=>{
  if(recognizing){
    stopVoiceAndAutoAdd();
    setVoiceButtonUI(false);
  }else{
    startVoice();
    setVoiceButtonUI(true);
  }
});

/* Also keep the UI in sync if recognition ends for any reason */
(function wireEndSync(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR) return;
  // If you re-create 'recognition' later, the onend below (already set) flips recognizing=false.
  // We add a small interval-based guard to nudge UI if needed.
  setInterval(()=>{ setVoiceButtonUI(!!recognizing); }, 500);
})();


/* =========================
   Usage counter + event log
   ========================= */
const usageTracker = {
  count: 0,
  activeMinutes: 0,
  lastTimestamp: null
};

function updateUsageDisplay(){
  const countEl = document.getElementById('usageCountDisplay');
  const minutesEl = document.getElementById('usageMinutesDisplay');
  const floatingCountEl = document.getElementById('floatingUsageCount');
  const floatingMinutesEl = document.getElementById('floatingUsageMinutes');

  if (countEl) countEl.textContent = `${usageTracker.count} actions`;
  if (minutesEl) minutesEl.textContent = `${usageTracker.activeMinutes.toFixed(1)} min`;
  if (floatingCountEl) floatingCountEl.textContent = usageTracker.count.toString();
  if (floatingMinutesEl) floatingMinutesEl.textContent = `${usageTracker.activeMinutes.toFixed(1)}m`;

  if (countEl) countEl.textContent = `${usageTracker.count} actions`;
  if (minutesEl) minutesEl.textContent = `${usageTracker.activeMinutes.toFixed(1)} min`;
}

function sendUsageToServer(actionLabel, ts){
  try {
    if (google && google.script && google.script.run && typeof google.script.run.logUsageEvent === 'function') {
      google.script.run.logUsageEvent({ action: actionLabel, timestamp: ts });
    }
  } catch(_) { /* ignore logging failures */ }
}

function recordUsage(actionLabel){
  const now = Date.now();
  if (usageTracker.lastTimestamp && (now - usageTracker.lastTimestamp) <= 5 * 60 * 1000) {
    usageTracker.activeMinutes += (now - usageTracker.lastTimestamp) / 60000;
  }
  usageTracker.lastTimestamp = now;
  usageTracker.count += 1;

  updateUsageDisplay();
  sendUsageToServer(actionLabel, now);
}

document.addEventListener('click', function(evt){
  const button = evt.target.closest('button');
  if (button) {
    const label = button.getAttribute('aria-label') || button.textContent.trim() || button.id || 'Button';
    recordUsage(`Button: ${label}`);
    return;
  }

  const suggestion = evt.target.closest('#autocompleteSuggestions > div');
  if (suggestion) {
    recordUsage(`Autocomplete: ${suggestion.textContent.trim()}`);
  }
}, true);

document.addEventListener('change', function(evt){
  const select = evt.target.closest('select');
  if (!select) return;
  const label = select.getAttribute('aria-label') || select.name || select.id || 'Dropdown';
  const value = select.value || '';
  recordUsage(`Dropdown: ${label}${value ? ' -> ' + value : ''}`);
}, true);

document.getElementById('usageCounterBtn')?.addEventListener('click', function(){
  if (typeof showToast === 'function') {
    showToast(`Tracked ${usageTracker.count} actions ¬∑ ${usageTracker.activeMinutes.toFixed(1)} min`);
  }
});

document.getElementById('floatingUsageBtn')?.addEventListener('click', function(){
  if (typeof showToast === 'function') {
    showToast(`Tracked ${usageTracker.count} actions ¬∑ ${usageTracker.activeMinutes.toFixed(1)} min`);
  }
});

document.getElementById('floatingEmailBtn')?.addEventListener('click', function(){
  triggerTopClientsEmail();
});

// Initialize displays on load
updateUsageDisplay();


function ensureRecognition(){
  if(recognition) return recognition;

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){
    showToast('Speech not supported');
    return null;
  }
  const r = new SR();
  r.lang = 'en-US';
  r.continuous = true;        // keep listening until we stop
  r.interimResults = false;   // finals only ‚Üí no echo/multiples

  // Defensive: make sure we don't double-wire handlers
  r.onresult = (event) => {
    let finalChunk = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const res = event.results[i];
      if (res.isFinal) {
        finalChunk += res[0].transcript;
      }
    }
    if (finalChunk) {
      // Append to textarea ONCE per final result
      const ta = document.getElementById('noteInput');
      if (ta) {
        ta.value = (ta.value ? (ta.value + ' ') : '') + finalChunk.trim();
      }
      // Also keep in-session buffer so we can auto-add on stop
      sessionBuffer += (sessionBuffer ? ' ' : '') + finalChunk.trim();
    }
  };

  r.onerror = (e) => {
    // surface a useful message but don't spam the UI
    console.warn('Speech error:', e);
    showToast(e.error === 'not-allowed' ? 'Mic blocked' : 'Speech error');
  };

  r.onend = () => {
    recognizing = false;
  };

  recognition = r;
  return recognition;
}

function startVoice(){
  const r = ensureRecognition();
  if(!r) return;
  if(recognizing){
    showToast('Already listening');
    return;
  }
  sessionBuffer = ''; // reset per session
  try{
    r.start();
    recognizing = true;
    showToast('Listening‚Ä¶');
  }catch(e){
    // Some browsers throw if start() is called too quickly
    console.warn('start() failed', e);
    showToast('Couldn‚Äôt start mic');
  }
}

function stopVoiceAndAutoAdd(){
  if(recognition && recognizing){
    recognition.stop();
    recognizing = false;
  }
  // Auto-add whatever we captured this session
  if(sessionBuffer.trim()){
    addNote(sessionBuffer.trim());
  }else{
    showToast('No speech captured');
  }
  sessionBuffer = '';
}


/* Quality-of-life loading bar helpers you already have styles for */
function startLoading(){
  const lb = document.getElementById('loadingBar');
  if(!lb) return;
  lb.style.animation = 'indeterminate 1.25s infinite';
}
function stopLoading(){
  const lb = document.getElementById('loadingBar');
  if(!lb) return;
  lb.style.animation = 'none';
}
  /* Loading bar */
  const bar = document.getElementById('loadingBar');
  function startLoading(){ bar.style.animation='indeterminate var(--anim) ease-in-out infinite'; }
  function stopLoading(){ bar.style.animation='none'; bar.style.left='-40%'; }
  // Toast helper: shows a message for ~2 seconds
function showToast(msg){
  const t = document.getElementById('toast');
  if(!t) return;
  t.textContent = msg || '';
  t.classList.add('show');
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=> t.classList.remove('show'), 2000);
}

/* Expand/Collapse: tab rides with panel ‚Äî NOTES-style toggle */
/* === DASHBOARD: Notes-style open/close =================================== */
(function(){
  const sheet   = document.getElementById('dashSheet');
  const handle  = document.getElementById('dashHandle');
  const overlay = document.getElementById('dashOverlay');

  if (!sheet || !handle) return;

  function setState(isOpen){
    sheet.classList.toggle('dashboard-open',   isOpen);
    sheet.classList.toggle('dashboard-closed', !isOpen);

    sheet.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    handle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

    if (overlay){
      overlay.style.display = isOpen ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    }
    try { sessionStorage.setItem('v1.dashboardOpen', String(isOpen)); } catch(_){}
  }
  function isOpen(){ return sheet.classList.contains('dashboard-open'); }

  // expose if needed elsewhere
  window.openDashboard   = () => setState(true);
  window.closeDashboard  = () => setState(false);
  window.toggleDashboard = () => setState(!isOpen());

  // wiring
  handle.addEventListener('click', () => window.toggleDashboard());
  if (overlay) overlay.addEventListener('click', () => window.closeDashboard());

  // Esc to close
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && isOpen()) window.closeDashboard();
  });

// initial state ‚Äî default OPEN (and still restore if previously saved)
let startOpen = true;
try {
  const saved = sessionStorage.getItem('v1.dashboardOpen');
  if (saved === 'true') startOpen = true;
  if (saved === 'false') startOpen = false;
} catch(_){}
setState(startOpen);

})();


  /* Autocomplete */
  function loadClientNames(){
    startLoading();
    google.script.run.withSuccessHandler(names=>{
      const dl = document.getElementById('clientNamesList');
      dl.innerHTML = '';
      (names||[]).forEach(n=>{
        const opt=document.createElement('option'); opt.value=n; dl.appendChild(opt);
      });
      stopLoading();
    }).getClientNamesSimple();
  }

  /* Add / Submit (Submit intentionally small; wiring same add unless you want different) */
  const noteInput = document.getElementById('noteInput');
  const addStatus = document.getElementById('addStatus');


const addBtn = document.getElementById('addBtn');

let addNotePending = false;

function addNote(textOverride){
  if (addNotePending) {
    return;
  }

 const rawText = typeof textOverride === 'string' ? textOverride : (noteInput.value || '');
  const txt = rawText.trim();
  if (!txt) {
    addStatus.textContent = '';
    return;
  }

  const preferredClient = (typeof getActiveClientName === 'function')
    ? getActiveClientName()
    : '';

  addNotePending = true;

  startLoading();
  addStatus.textContent = '';
  if (addBtn) {
    addBtn.disabled = true;
  }
  google.script.run
    .withSuccessHandler(_ => {

      if (noteInput) {
        noteInput.value = '';
      }
   loadRecent(() => {
        addBtn.disabled = false;
        showToast('Note added successfully');
      });
    })
    .withFailureHandler(err => {
      console.log(err);
      stopLoading();
   addNotePending = false;
        if (addBtn) {
          addBtn.disabled = false;
        }
              showToast('Error adding note');
    })
    .inboxAddNote(txt, preferredClient);
}


addBtn?.addEventListener('click', () => addNote());

    /* Recent (5) with assign */
  const recentList = document.getElementById('recentList');

  function renderRecent(payload){
    recentList.innerHTML='';
    const items=(payload&&payload.recent)?payload.recent:[];
    if(!items.length){ return; }

    items.forEach(it=>{
      const row=document.createElement('div'); 
      row.className='item';

      // LEFT: note text
      const note=document.createElement('div'); 
      note.className='note'; 
      note.textContent=it.note;

      // RIGHT: timestamp + assign input (auto-assigns on selection)
      const side=document.createElement('div'); 
      side.style.minWidth='280px';

      // Timestamp only (NO green assigned label)
      const meta=document.createElement('div'); 
      meta.className='meta';
      meta.textContent = it.timestamp ? it.timestamp : '';

      // Wider input: 360px (twice the previous 180px)
      const inp=document.createElement('input'); 
      inp.type='text'; 
      inp.className='small'; 
      inp.setAttribute('list','clientNamesList'); 
      inp.style.width='360px';

      // Keep selection visible in the input (no extra green label elsewhere)
      inp.value = it.assigned || '';
      inp.placeholder = it.assigned ? 'Change assignment‚Ä¶' : 'Assign‚Ä¶';

      // Auto-assign handler
      function commitAssign(){
        const name = (inp.value||'').trim();
        if(!name) return;
        startLoading();
        google.script.run
.withSuccessHandler(_=>{
  stopLoading();
  showToast('Client note has been updated successfully');
})

          .withFailureHandler(err=>{
            alert(err && err.message ? err.message : String(err));
            stopLoading();
          })
          .inboxAssignToClient(it.row, name);
      }

      // Assign immediately when a value is chosen or Enter is pressed
      inp.addEventListener('change', commitAssign);
      inp.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ 
          e.preventDefault(); 
          commitAssign(); 
        }
      });

      // Layout row (no Assign button, no green label)
      const r=document.createElement('div'); 
      r.className='row'; 
      r.appendChild(inp);

      side.appendChild(meta);
      side.appendChild(document.createElement('div')).style.height='6px';
      side.appendChild(r);

      row.appendChild(note); 
      row.appendChild(side);
      recentList.appendChild(row);
    });
  }

function loadRecent(done){
  startLoading();
  google.script.run
    .withSuccessHandler(p=>{
      renderRecent(p);
      stopLoading();                 // ‚¨ÖÔ∏è stop only after items render
      if (typeof done === 'function') done();
    })
    .withFailureHandler(e=>{
      console.log(e);
      stopLoading();
      if (typeof done === 'function') done(e);
    })
    .inboxGetRecent(50);
}



  window.addEventListener('load', ()=>{ loadClientNames(); loadRecent(); });

// Mobile textarea height fallback (enforce 50vh on load/resize)
(function(){
  function enforceMobileNoteHeight(){
    const ta = document.getElementById('noteInput');
    if (!ta) return;
    const isMobile = window.matchMedia('(max-width: 640px)').matches;
    if (isMobile) {
      // Try dvh/svh first; fall back to vh if needed
      ta.style.height     = '50dvh';
      ta.style.minHeight  = '50dvh';
      ta.style.maxHeight  = '50dvh';
      // If the browser doesn't understand dvh, set vh as a fallback
      // (some engines keep the last valid value)
      ta.style.height     = '50vh';
      ta.style.minHeight  = '50vh';
      ta.style.maxHeight  = '50vh';
    } else {
      ta.style.height = ta.style.minHeight = ta.style.maxHeight = '';
    }
  }
  window.addEventListener('load', enforceMobileNoteHeight);
  window.addEventListener('resize', enforceMobileNoteHeight);
  window.addEventListener('orientationchange', enforceMobileNoteHeight);
})();


 (function(){
    const sheet   = document.getElementById('notesSheet');
    const handle  = document.getElementById('notesHandle');
    const overlay = document.getElementById('notesOverlay');
    const listEl  = document.getElementById('notesList');
    const dl      = document.getElementById('clientNamesDatalist');

    const addBtn  = document.getElementById('btnAddInbox');
    const newNote = document.getElementById('inboxNewNote');

    // ‚úÖ PUT THESE LINES RIGHT HERE:
    if (overlay && overlay.parentNode !== document.body) {
      document.body.appendChild(overlay);   // moves it (doesn't clone)
    }
    if (sheet && sheet.parentNode !== document.body) {
      document.body.appendChild(sheet);     // moves it under <body>
    }

    // Toggle by tapping the GREEN part (and overlay)
(function(){
  const sheet   = document.getElementById('notesSheet');
  const handle  = document.getElementById('notesHandle');
  const overlay = document.getElementById('notesOverlay');

  if (!sheet || !handle) return; // safety

  function setState(isOpen){
    sheet.classList.toggle('notes-open',   isOpen);
    sheet.classList.toggle('notes-closed', !isOpen);
    sheet.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    handle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

    if (overlay){
      overlay.style.display = isOpen ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    }

    // remember state so re-clicking the tab behaves
    try { sessionStorage.setItem('v1.notesOpen', String(isOpen)); } catch(_){}
  }

  function isOpen(){
    return sheet.classList.contains('notes-open');
  }

  // expose (if other code calls them)
  window.openSheet  = function(){ setState(true);  };
  window.closeSheet = function(){ setState(false); };
  window.toggleSheet= function(){ setState(!isOpen()); };

  // wire clicks
  handle.addEventListener('click', toggleSheet);
  if (overlay) overlay.addEventListener('click', closeSheet);

  // don‚Äôt close when interacting inside the form
  sheet.addEventListener('click', function(e){
    if (e.target.closest('form, textarea, input, select, button, [contenteditable]')) {
      e.stopPropagation();
    }
  }, true);

  // Esc to close
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape' && isOpen()) closeSheet();
  });

  // Initial state (restore last)
  let startOpen = false;
  try { startOpen = sessionStorage.getItem('v1.notesOpen') === 'true'; } catch(_){}
  setState(startOpen);
})();


    // listeners, loaders, etc...
  })();


</script>
<div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>





</body>
</html>












<!DOCTYPE html>
<html>
<head>
    <base target="_top">
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

   <style>
  :root {
    --background-color: #E6F0FF; /* Default background color */
    --text-color: #000000; /* Default text color - black */
    --secondary-color: #f0f0f0; /* Secondary color for hover state - light gray */
    --button-color: #add8e6; /* Light blue color for buttons */
      --submit-button-color: #BFA2DB; /* Define a slightly purple color */
          --darker-blue: #007bff; /* Example darker blue */

  }

  body {
      font-family: Arial, sans-serif; /* Consistent font throughout */
    font-size: 1.5em;
      color: var(--text-color);

  }
/* ... other CSS styles ... */

.note-textarea {
    background-color: white; /* Set background color to white */
  margin: 0 auto; /* Auto margins for horizontal centering */
}

/* ... other CSS styles ... */

input, button, select {
  border-radius: 4px;
  padding: 10px;
  font-size: 1em;
}

#addToCalendarBtn, #addAppointmentBtn {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#futureWorkSection {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  font-size: 14px; /* Adjust the size as needed */
}


#newFollowUp {
  background-color: white; /* Set to light blue as defined in your root variables */
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#pastWorkSection {
  background-color: #D3D3D3; /* Set to light grey */
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    font-size: 16px; /* Adjust the size as needed */

}


#submitTaskBtn {
    color: #000000; /* Black font color */
}


  label, {
    font-weight: bold;
    letter-spacing: 1px;
    text-transform: uppercase;
    font-size: 1em;
    border-radius: 4px;
    padding: 10px;
  margin: 0 auto; /* Auto margins for horizontal centering */

  }
 
 #clientSelect {
  display: none;
}




  body * {
    font-size: 1.5em;
  }

  #newFollowUp, button {
    font-size: 1.5em;
  }

  #categorySelect {
    font-size: 1.5em;
    width: 100%; /* Sets the width to 100% of the parent container */
    box-sizing: border-box; /* Ensures padding and borders are included in the width */
}

.client-mention {
  color: #0066cc;
  text-decoration: underline;
  cursor: pointer;

  /* keep size/shape identical to surrounding text */
  font-size: inherit;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  text-transform: none;
}



#autocompleteSuggestions {
    border: 1px solid #ccc;
    border-top: none;
    position: absolute;
    z-index: 1000;
    background-color: white;
    width: 100%;
    top: 100%;
    left: 0;
    max-height: none; /* Set a maximum height */
    overflow-y: auto;  /* Enable vertical scrolling */
}



  #topClientsDisplay ol {
    list-style-type: decimal;
  }

  #autocompleteSuggestions div {
    padding: 10px;
    cursor: pointer;
  }

  #autocompleteSuggestions div:hover {
    background-color: #f0f0f0;
  }

  .smaller-size {
    transform: scale(0.4);
  }

  button {
    background-color: var(--button-color);
    color: black;
    border: none;
    border-radius: 4px;
    padding: 10px 20px;
    text-transform: uppercase;
    font-weight: bold;
    letter-spacing: 1px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    cursor: pointer;
     display: block; /* Make button a block element */
  margin: 0 auto; /* Auto margins for horizontal centering */
  }

  button:hover, button:focus {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        filter: brightness(85%); /* Darken button on hover/focus */

  }

button:active {
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    transform: translateY(1px);
        filter: brightness(75%); /* Further darken button when active/pressed */

}


 #addAppointmentBtn {
    background-color: red; /* Light red color */
  }


  #newClientForm button {
  background-color: var(--submit-button-color); /* Use the purple color variable */
  }

.button-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px; /* Adjust the space between buttons as needed */
}




  .secondary-button {
    background-color: var(--background-color);
    color: var(--text-color);

  }

  .primary-button {
    background-color: var(--accent-color);
  }
  #newNoteSection button {
  background-color: var(--submit-button-color); /* Use the purple color variable */
}

/* New CSS class for styling the task display */
.task-display {
    font-size: 0.8em; /* Smaller text */
    width: 100%; /* Adjust width as needed */
    padding: 15px; /* More padding for larger box */
    border: 1px solid #ccc; /* Optional border */
    margin-bottom: 10px; /* Spacing between boxes */
}
.update-team-task-btn {
  background-color: var(--submit-button-color); /* Purple background */
  color: var(--text-color); /* Black text color */
  /* Rest of the styling similar to the 'Submit New Note' button */
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  text-transform: uppercase;
  font-weight: bold;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  cursor: pointer;
    font-size: 225%;

}

.update-team-task-btn:hover, .update-team-task-btn:focus {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  filter: brightness(85%);
}

.update-team-task-btn:active {
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  transform: translateY(1px);
  filter: brightness(75%);
}
 .container {
    display: flex; /* Use flexbox for layout */
    justify-content: space-around; /* Space out items evenly */
    align-items: start; /* Align items to the start of the container */
  }

  .notes-section, .follow-ups-section {
    flex-basis: 30%; /* Set a base width for both sections */
    padding: 20px; /* Add some padding */
    margin: 10px; /* Add some margin */
  }

  .divider {
    height: 100%; /* Full height divider */
    width: 1px; /* Thin line as a divider */
    background-color: #000; /* Black color for the divider */
    margin: 0 20px; /* Margin to space out from sections */
  }

#topClientsHr {
    border-top: 2px solid black; /* Adjust the color as needed */
}

#teamTasks3Display textarea {
    width: 100%; /* Make the textbox take full width */
    box-sizing: border-box; /* Include padding and border in the width */
}

#autocompleteSuggestions .autocomplete-active {
  background-color: blue; /* Change to blue */
  color: white;           /* Make text readable on blue background */
}


/* Centering container for client name input */
.client-name-container {
    text-align: center; /* Center align the content */
    margin: 0 auto; /* Center the container */
    width: 100%; /* Set width to full container width */
}

/* Styling for the client name input */
#clientAutocomplete {
    display: inline-block; /* Make the input an inline-block element */
    margin-top: 10px; /* Add some top margin for spacing */
}
#pastWorkSection {
  background-color: #D3D3D3; /* Existing styles */
  /* ... other styles ... */
  text-align: center; /* Center-align content within the section */
}


#newNoteSection {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  text-align: center; /* Center-align content within the section */
}





#categoryChangeSection {
  background: transparent;
  padding: 0;
  margin: 0 0 8px 0;
  border: 0;
  box-shadow: none;
  text-align: left;
}

.category-label {
  display: block; /* Make label a block element */
  margin-bottom: 10px; /* Space between label and select */
}

.category-select {
  display: block;
  margin: 0;
  width: 100%;
}

#loadingBarContainer {
    width: 100%;
    background-color: #f3f3f3;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1001; /* Increase z-index to stay above other elements */
}

/* === GREEN GRADIENT + SMOOTH WIDTH === */
#loadingBar {
    height: 5px;
    width: 0; /* Start empty */
    background: linear-gradient(90deg, #0f9d58, #34a853, #0f9d58);
    background-size: 200% 100%;
    transition: width 0.3s ease; /* <- shorter/smoother */
}

/* Animated shimmer while ‚Äúindeterminate‚Äù */
#loadingBar.indeterminate {
    animation: lgShimmer 1.2s linear infinite;
}

@keyframes lgShimmer {
    0%   { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}



#piechart {
  width: 900px; /* Adjust as necessary */
  height: 500px; /* Adjust as necessary */
  margin: 0 auto; /* Center the div */
}

#heatmap, #futureHeatmap {
  width: 900px; /* Existing width */
  height: 700px; /* Increased height */
  margin: 0 auto; /* Center the div */
}


#heatmap text {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}

#futureHeatmap text {
  font-size: 12px; /* Ensure font size is consistent with the first heatmap */
  transform: none; /* Ensure no scaling is applied */
}

/* If using classes for text labels, you could also do something like this: */
.chart-label {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}

/* CSS rule for adjusting the font size of the scatter plot label */
#scatter_chart_div text {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}



.label-box {
    padding: 5px;
    margin: 5px;
    border: 1px solid #ddd;
    display: inline-block; /* or 'block' if you want each label on a new line */
    background-color: #f0f0f0;
    font-size: 32px;
}

.add-label-dropdown {
  width: auto !important;
  min-width: 0;
  padding: 5px 12px;
  margin: 5px;
  font-size: 32px;
  background-color: lightgreen;
  color: black;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  appearance: none;
}

.add-label-dropdown:focus {
  outline: 3px solid var(--green2, #0ca678);
  outline-offset: 2px;
}

/* Add this CSS rule to initially hide the label section */
#labelsSection {
  display: none;
}

  #labelsDropdown {
      width: 100%;
      box-sizing: border-box; /* Includes padding and border in the width */
      /* Additional styling as needed */
  }


.client-container {
    position: fixed;
    top: 0; /* Set to the height of the loading bar */
    left: 0;
    width: 100%;
    background-color: var(--background-color);
    z-index: 1000; /* Lower than loading bar */
    padding: 10px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#recentRow {
  transition: transform .2s ease, opacity .2s ease, max-height .2s ease, margin .2s ease;
  max-height: 200px;
}

/* Let the green autocomplete slide away like the recent bar when we hide it */
#clientAutocomplete {
  transition: transform .2s ease, opacity .2s ease, max-height .2s ease, margin .2s ease, padding .2s ease;
}

.client-container.hide-recents #recentRow {
  transform: translateY(-120%);
  opacity: 0;
  max-height: 0;
  margin: 0;
  pointer-events: none;
}

.client-container.hide-recents #clientAutocomplete {
  transform: translateY(-120%);
  opacity: 0;
  max-height: 0;
  margin-top: 0;
  margin-bottom: 0;
  padding-top: 0;
  padding-bottom: 0;
  pointer-events: none;
}

#autocompleteSuggestions {
  transition: transform .2s ease, opacity .2s ease, max-height .2s ease, margin .2s ease;
}

.client-container.hide-recents #autocompleteSuggestions,
#autocompleteSuggestions.is-contracted {
  transform: translateY(-12px);
  opacity: 0;
  max-height: 0 !important;
  margin-top: 0;
  pointer-events: none;
  overflow: hidden;
}


body {
    margin-top: 0; /* Adjust the value to match the height of the fixed header */
}



.client-name-container, .client-select-container {
  flex: 1; /* This will allow each child to take up equal space */
  margin-right: 10px; /* Space between the elements, adjust as needed */
}

/* Make sure the input and select elements are 100% width of their containers */
input#clientAutocomplete, select#clientSelect {
  width: 100%;
  box-sizing: border-box; /* Include padding and borders in the element's total width */
}

.labels-container {
  display: flex;
  width: 100%;
  align-items: stretch;
}

  .labels-notes-left {
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .labels-top-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .labels-top-row #labelsDropdown {
    flex: 1 1 auto;
  }

  .labels-top-row .labels-chip-slot {
    flex: 0 0 auto;
  }

#labelsDisplay {
  font-size: 32px;
}

  #labelsAdditionSection {
    flex: 0 0 15%; /* Keep the controls to no more than 15% of the screen width */
    max-width: 15%;
    display: none;
    flex-direction: column;
  gap: 8px;
  font-size: 32px;
}

  #labelsDropdown {
    width: 100%; /* Ensure the dropdown fills its container */
    box-sizing: border-box; /* Include padding and borders in the element's total width */
    font-size: 1em; /* Match the labels/notes sizing */

  }



#toggleNotesButton {
  background-color: #ff9500; /* Solid orange square */
  margin: 0;
  font-size: 24px;
  width: 120px;
  height: 120px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  border-radius: 4px;
}

#hideClientNotesBtn {
  display: none !important;
}

.inline-button {
  display: inline-flex; /* Make button an inline-flex element */
  margin: 0; /* Remove auto margins */
  /* Any other specific styles you want these buttons to have */
}

.labels-buttons-row {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 6px;
}

.labels-buttons-row > button {
  width: 100%;
  font-size: 1em;
}

  .labels-chip-slot {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1em;
  }

.note-chip-inline {
  display: inline-flex;
  margin-left: 10px;
  vertical-align: baseline;
}


/* When you want to display the labelsAdditionSection, you can change its style to 'display: block' or 'display: flex' as needed with JavaScript */

#topClientsBtn, #calendarTasksBtn, #todayButton {
    background-color: var(--darker-blue); /* Use the darker blue color */
}

.highlighted {
    background-color: yellow;
}

/* ===== NAME LINKIFY + HOVER BUBBLE ===== */
.client-mention {
  color: #0066cc;
  text-decoration: underline;
  cursor: pointer;
}

#nameHoverBubble {
  position: absolute;
  z-index: 10002;
  display: none;
  max-width: 380px;
  max-height: 260px;
  overflow-y: auto;
  background: #ffffff;
  border: 1px solid #999;
  border-radius: 8px;
  padding: 8px 10px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
  font-size: 0.9em;
}

#nameHoverBubble .bubble-title {
  font-weight: bold;
  margin-bottom: 6px;
}

#nameHoverBubble .bubble-item {
  padding: 6px 8px;
  border-radius: 6px;
  margin: 4px 0;
  cursor: pointer;
}

#nameHoverBubble .bubble-item:hover {
  background: #f0f6ff;
}


#columnBDropdown, #columnDDropdown {
  width: 100%;
  /* No font-size line here‚Äînow it inherits the same larger 1.5em size as JB/RICKY */
  margin-top: 0px;
  margin-bottom: 0px;
}


/* Hover style for items not active */
#autocompleteSuggestions div:hover:not(.autocomplete-active) {
    background-color: #f0f0f0;
}

/* Style for the active suggestion */
#autocompleteSuggestions div.autocomplete-active {
    background-color: blue;
    color: white;
}

#autocompleteSuggestions {
    position: absolute;
    top: calc(100% + 5px); /* Position it just below the input field */
    left: 0;
    width: 100%;
    z-index: 1001; /* Ensure it's above other elements */
    max-height: 200px; /* Set a maximum height */
    overflow-y: auto; /* Enable vertical scrolling if needed */
    background-color: white;
    border: 1px solid #ccc;
    border-top: none;
}


#pastWorkSection, #futureWorkSection {
  flex: 1;
}

#pastWorkSection, #futureWorkSection {
  box-sizing: border-box;
}

.past-work-label, .future-work-label {
    display: block;
    margin-bottom: 10px;
    font-size: 40px; /* Adjust font size as needed */
    text-align: center; /* Center align labels if desired */


}


.past-work-textarea, .future-work-textarea {
    display: block;
    margin: 0 auto;
    width: 100%;
    height: 150px; /* Adjust height as needed */
        box-sizing: border-box;
            min-width: 0;  /* Allow the textarea to shrink */


}


.update-team-task-btn, .secondary-button {
  margin: 10px auto;
}

#notesDisplay * {
  box-sizing: border-box;
}

#pastWorkSection, #futureWorkSection {
  font-size: 16px;
}

.past-work-wrapper {
  position: relative;
  width: 100%;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.past-work-wrapper .past-work-textarea {
  padding-right: 0;
  flex: 1 1 auto;
}

.past-work-wrapper .update-team-task-btn {
  position: static;
  top: auto;
  right: auto;
  transform: none;
  margin: 0;
  flex: 0 0 auto;
  font-size: 180%;
  padding: 8px 16px;
}

.client-button {
    font-weight: normal;
}

/* Top Clients list buttons only */
#topClientsDisplay .inline-button,
#topClientsDisplay .client-button,
#topClientsDisplay button {
  font-size: 0.7em;  /* tweak as needed */
}

/* Center each filtered client button in its row */
#topClientsDisplay .task-display {
  align-items: center;
  width: 100%;
}

#topClientsDisplay .task-display > div:first-child {
  width: 100%;
  display: flex;
  justify-content: center;
}

#topClientsDisplay .client-button {
  margin: 0 auto;
}


/* Allow parent containers to grow */
#notesDisplay {
    overflow: visible;
}

#notesDisplay div {
    flex-grow: 1;
}

/* Optional: Add styling for the note lines */
.note-line {
    margin-bottom: 5px; /* Adjust as needed */
}

.future-work-actions {
    display: flex;
    flex-wrap: wrap; /* Allow items to wrap to the next line */
    justify-content: flex-end;
    padding-top: 10px;
    align-items: center;
}

#dateInputContainer {
    margin-right: 10px;
    flex: 1 1 auto; /* Allow the container to shrink properly */
    min-width: 0;   /* Allow the container to shrink below its content size */
    
}


#futureWorkDate {
    width: 100%; /* Make sure the input takes full width of its container */
    box-sizing: border-box; /* Include padding and border in the width */
        min-width: 0;  /* Allow the input to shrink below its content size */

}

.future-work-actions button {
    flex: 1 1 auto; /* Allow the button to shrink and grow */
    width: auto; /* Let the button adjust its width automatically */
}

@media (max-width: 600px) {
    /* When the screen width is less than 600px, stack the elements vertically */
    .future-work-actions {
        flex-direction: column;
        align-items: stretch;
    }



    .future-work-actions button {
        width: 100%; /* Button takes full width */
    }
}


#userSelection {
    width: 100%;
    box-sizing: border-box;
    min-width: 0; /* Allow the select dropdown to shrink */
}

#futureWorkSection {
    min-width: 0; /* Allow the entire section to shrink */
}


/* The Modal (background) */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 9999; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black with opacity */
}

/* Modal Content/Box */
.modal-content {
    background-color: #fefefe;
    margin: 5% auto; /* Centered */
    padding: 20px;
    border: 1px solid #888;
    width: 90%; /* Adjust as needed */
    max-width: 800px;
}

/* Close Button */
.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
}



#addNewClientBtn {
    display: inline-block; /* Changes display to inline-block */
    margin: 10px 0;        /* Adds vertical margin, removes horizontal centering */
}

.modal-content input,
.modal-content select {
    width: 100%;          /* Input fields occupy full width */
    box-sizing: border-box; /* Includes padding and border in the element's total width */
    font-size: 1.5em;     /* Adjust font size as needed */
}


.title-button-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

#topClientsTitle {
    font-size: 1.25em;
    font-weight: bold;
    text-align: left; /* Align text to the left */
    margin: 0;        /* Remove default margins */
}

#topClientsByCategoryBtn,
#addNewClientBtn {
    /* Ensure the button has consistent styling */
    font-size: 1em;
    padding: 10px 20px;
    /* Additional styles as needed */
}

#scrollBottomBtn {
    /* Match #addNewClientBtn's font/size so the button text is the same size */
    display: inline-block;
    margin: 10px 0;
    font-size: 1em; /* If your Add New Client is 1em, use 1em here as well */
}



#columnDDropdown {
  padding-top: 5px; /* Reduce padding-top */
  padding-bottom: 5px; /* Reduce padding-bottom */
}

.star-button {
    background-color: lightblue;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
}

.star-button:hover {
    color: gold;
}

.title-button-container {
    display: flex;
    flex-direction: column; /* Stack elements vertically */
    align-items: center;
    margin-bottom: 20px;
}

#topClientsHeader {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px; /* Space between header and "Add New Client" button */
}

#topClientsTitle {
    margin-right: 10px;
    font-size: 1.25em;
    font-weight: bold;
    text-align: center;
}

#topClientsByCategoryBtn {
    /* Adjust styles if needed */
}

#addNewClientBtn {
    /* Center the button */
    margin: 0 auto;
}
.modal-content {
    background-color: #fefefe;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 90%;
    max-width: 800px;
}

#categoriesModalContent {
    font-size: 14px; /* Adjust the font size as needed */
    text-align: center; /* Center the text if desired */
}

#categoriesModalContent p {
    margin: 5px 0; /* Reduce margin between paragraphs */
}


/* Container styling */
.title-button-container {
    display: flex;
    flex-direction: column;
    margin-bottom: 20px;
}

/* Row styling */
.row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%; /* Ensure rows take full width */
}

/* Title text styling */
.title-text {
    font-size: 1.25em;
    font-weight: bold;
    text-align: left;
}

/* Buttons align to the right */
.row button {
    margin-left: auto; /* Push buttons to the right */
}

.title-button-container {
    /* Ensures the container spans the full screen width */
    width: 100vw;
    position: relative;
}

/* Each row now only left-aligns its text. We remove justify-content: space-between so text stays at left */
.row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    position: relative; /* Needed for absolute positioning of buttons */
    width: 100%;
}

/* Absolutely position the buttons to the right edge of the screen */
.row button {
    position: absolute;
    right: 0;
    margin: 0; /* Remove any auto-margins that might shift the buttons */
}

/* Inline controls: date + dropdown + bulb stay on one line with matching size */
#topClientsControlRow {
    gap: 12px;
    flex-wrap: nowrap;
    align-items: center;
    width: 100%;
    font-size: 1.25em;
}

#topClientsControlRow .title-text {
    font-size: inherit;
    font-weight: bold;
    white-space: nowrap;
    overflow: visible;
    text-overflow: clip;
    min-width: 0;
    flex-shrink: 1;
}

#topClientsControlRow select,
#topClientsControlRow button {
    font-size: inherit;
    line-height: 1.2;
    padding: 4px 10px;
    height: auto;
    flex: 0 0 auto;
}

/* Keep controls inline instead of absolutely positioned */
#topClientsControlRow button {
    position: static;
    margin: 0;
}

#topClientsControlRow select {
    position: static;
    min-width: 0;
    flex: 0 0 auto;
}

/* SNIPPET #1: STAR ANIMATION CSS - REPLACEMENT */
.star-animation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  /* Just a slightly dark overlay + big centered star emoji */
  background: rgba(10, 10, 0, 0.75);
  z-index: 999999; /* Sit on top of everything */
  pointer-events: none; /* Don‚Äôt let this block clicks */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 300px; 
}
.star-animation::before {
  content: "‚≠ê";
}


/* SNIPPET TO ADD A GAP BETWEEN THE EMAIL SUMMARY BUTTON ROW 
   AND THE ADD NEW CLIENT BUTTON ROW */
#topClientsControlRow {
  margin-bottom: 20px; /* Adjust as needed to create more or less space */
}

/* Center the date/initials/lightbulb row within the viewport */
#topClientsControlRow {
  justify-content: center;
  text-align: center;
}

#topClientsControlRow > * {
  margin-left: 0;
  margin-right: 0;
}

/* SNIPPET #2 (REPLACED): make filter dropdown look like a button and hide arrow */
/* SNIPPET #2 (RESTORED): native select with arrow */
#topClientsFilterDropdown {
  /* Restore the platform's native dropdown look + arrow */
  appearance: auto !important;
  -webkit-appearance: menulist !important; /* Safari/Chrome */
  -moz-appearance: menulist !important;    /* Firefox */

  /* Undo the button-y overrides */
  background: revert;
  background-image: revert;
  border: revert;
  border-radius: revert;
  padding: revert;
  line-height: revert;
  height: revert;
  cursor: default;

  /* Keep only what you still want */
  font-size: inherit;   /* match the date + bulb size */
  width: auto;          /* optional */
  margin-left: 5px;     /* keep the small gap from nearby controls */
  padding: 3px 18px 3px 6px; /* keep the box snug while leaving room for the arrow (mobile arrow is wider) */
  white-space: nowrap;
  flex: 0 0 auto;
}



.chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  border-radius: 9999px;
  font-weight: 600;           /* to resemble your button text weight */
  line-height: 1.2;
  margin-left: 8px;           /* small gap from the text it follows */
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.08);
  user-select: none;
}

.chip .chip-initials { text-transform: uppercase; }
.chip .chip-sep { opacity: 0.7; }
.chip .chip-date { letter-spacing: 0.2px; }

/* Colors: on top of yellow highlight */
.chip.JB { background: #1E90FF; color: #fff; }   /* blue */
.chip.RB { background: #28A745; color: #fff; }   /* green */
.chip.QC { background: #FF8C00; color: #fff; }   /* orange */
.chip.TEAM { background: #800080; color: #fff; }   /* orange */
.chip.BDAY { background: #FF8C00; color: #fff; }   /* orange */


.chip.EMPTY { background: #f0f0f0; color: #333; }/* placeholder neutral */

/* === CHIP SIZE OVERRIDE (2/3 scale) ‚Äî PASTE AFTER EXISTING .chip RULES === */
.chip {
  /* shrink overall text to 2/3 of the surrounding size */
  font-size: 0.6667em;

  /* shrink paddings and gaps proportionally */
  padding: 1.333px 5.333px;   /* was 2px 8px */
  gap: 4px;                   /* was 6px */

  /* keep pill shape, borders, weights, etc. */
  border-radius: 9999px;
  font-weight: 600;
  line-height: 1.2;

  /* optional: slightly smaller left margin to match scale */
  margin-left: 5.333px;       /* was 8px */
}

/* inner bits scale automatically with font-size.
   leaving these for clarity in case you customize later */
.chip .chip-initials { text-transform: uppercase; }
.chip .chip-sep { opacity: 0.7; }
.chip .chip-date { letter-spacing: 0.2px; }

/* Keep your color classes as-is; no changes needed:
   .chip.JB, .chip.RB, .chip.QC, .chip.EMPTY */

.chip .chip-sep {
  color: #000;   /* force black */
  opacity: 1;    /* make fully opaque */
}




/* Wrapper anchors the absolute button & suggestions */
.client-input-wrap {
  position: relative;
  width: 100%;        /* fill available width */
  /* no max-width, no auto-centering */
}

/* Keep input‚Äôs *outer* size unchanged; just add internal space for the button */
#clientAutocomplete {
  width: 100%;
  box-sizing: border-box;
  padding-right: 130px; /* room for the button; tweak if your button is wider/narrower */
}

/* Put the existing NEW CLIENT button on the right edge of the bar */
#addNewClientBtn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;             /* override global button { margin: 0 auto } */
  display: inline-block;  /* override global button { display: block } */
  z-index: 2;            /* sit above the input */
}

#notesDisplay strong {
  font-size: inherit; /* Prevents bold from shrinking or enlarging */
  font-weight: bold;  /* Keep bold effect */
}

#topClientsDisplay strong {
  font-size: inherit;  /* keep same size as surrounding note text */
  font-weight: bold;   /* still be bold */
}

/* ‚Äî‚Äî‚Äî Ricky‚Äôs Suggestion block: green wrapper, white textarea ‚Äî‚Äî‚Äî */
.toplist-suggestion{
  background-color:#90EE90;   /* light green */
  padding:10px;
  border:1px solid #ccc;
  border-radius:4px;
  margin-top:8px;
}
.toplist-suggestion .note-textarea{
  background:white;           /* keep input white */
}

/* Make SUGGESTIONS button match SCROLL DOWN sizing */
#suggestionsToggleBtn{
  display:inline-block;
  font-size: 1em;             /* same as #scrollBottomBtn */
}

/* Toolbar row (JB/RB/QC + filter arrow + SUGGESTIONS) */
.top-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Make the Suggestions button match your toolbar sizing */
#suggestionsToggleBtn {
  display: inline-block;
  padding: 6px 10px;
  font-size: 1em; /* same visual scale as your other controls */
}

/* Ricky‚Äôs Suggestion: full-width green block, textarea stays white */
.toplist-suggestion {
  background-color: #90EE90; /* light green */
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;

  /* FULL-WIDTH rules */
  width: 100%;
  box-sizing: border-box;
  margin-left: 0;
  margin-right: 0;
}
.toplist-suggestion .note-textarea {
  background: white;     /* input stays white */
  width: 100%;           /* full width inside the green block */
  box-sizing: border-box;
    overflow: hidden;      /* hide scrollbars; JS shrinks text instead */
  resize: none;          /* keep size fixed so font shrinking is visible */
}

#editNotesButton { font-size: 0.66em; }

  .recent-bar { display:flex; flex-wrap:wrap; gap:.5rem; padding:.5rem 0; }
  .recent-pill {
    display:flex; align-items:center; gap:.4rem;
    border:1px solid #ddd; border-radius:9999px; padding:.35rem .7rem; cursor:pointer;
    font-size:.9rem; background:#fff;
  }
  .rc-name { font-weight:600; }
  .rc-cat { font-size:.75rem; padding:.05rem .4rem; border:1px solid #eee; border-radius:8px; }
  .rc-chip { font-size:.7rem; opacity:.8; }
  .rc-dot { width:.5rem; height:.5rem; border-radius:50%; background:#4caf50; }
  .rc-muted { opacity:.35; } /* when Column L empty */
/* OVERRIDE: keep recent chips full strength */
.recent-bar .rc-muted { opacity: 1 !important; }

/* Make the blue box visually contain chips + input cleanly */
.client-input-wrap {
  position: relative;           /* already present, keep it */
  background: #ffffff;          /* white interior so chips/input stand out */
  border: 2px solid #1E90FF;    /* blue outline */
  border-radius: 10px;
  padding: 10px 140px 12px 12px; /* top/right/bottom/left; right = room for NEW CLIENT button */
  box-shadow: 0 2px 5px rgba(0,0,0,0.06);
}

.category-overlay {
  position: static;
  display: none;
  width: 100%;
  pointer-events: auto;
}

#categoryChangeSection select {
  width: 100%;
  height: auto;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 1em;
  padding: 10px;
  box-sizing: border-box;
  pointer-events: auto;
}

/* Chips bar when placed inside the autocomplete wrapper */
.recent-bar.inside-autocomplete {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 0 0 8px 0;           /* space below chips before the input */
  padding: 0;
}

/* Keep the input border simple since the blue box provides the outline */
#clientAutocomplete {
  border: 1px solid #ccc;
  border-radius: 6px;
  padding-right: 130px;        /* already present; keep for the button on the right */
  width: 100%;
  box-sizing: border-box;
}

/* Ensure the suggestion list still anchors just under the input and stays within the blue box */
/* Keep suggestions visually inside the blue box and not covering content below */
#autocompleteSuggestions {
  position: absolute;
  z-index: 1001;      /* above the input, below the loading bar (1001 is fine) */
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px); /* just below the input inside the blue box */
  max-height: 200px;
  overflow-y: auto;
  background-color: white;
  border: 1px solid #ccc;
  border-top: none;
}


/* Keep the NEW CLIENT button floating over the right edge of the blue box */
#addNewClientBtn {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;
  z-index: 2;
}

/* Chip visuals (already present)‚Äîno change needed; this just ensures consistent scale in the tighter space */
.chip { font-size: 0.6667em; }

/* === INLINE NEW CLIENT BUTTON INSIDE CHIPS BAR === */

/* Make the blue box padding uniform now that the button isn't absolutely positioned */
.client-input-wrap {
  padding: 10px 12px 12px 12px; /* override previous padding with big right space */
}

/* Chips bar already flexes; just keep it tidy */
.recent-bar.inside-autocomplete {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 0 0 8px 0;
  padding: 0;
}

/* NEW CLIENT button styled to sit among the chips, with two stacked lines */
#addNewClientBtn,
.recent-add-btn {
  display: inline-flex;
  flex-direction: column;      /* stack NEW / CLIENT */
  align-items: center;
  justify-content: center;
  gap: 2px;
  font-weight: 700;
  line-height: 1.1;
  padding: .35rem .7rem;
  border-radius: 9999px;
  border: 1px solid #ddd;
  background: var(--submit-button-color);  /* your purple */
  color: var(--text-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,.12);
  /* Sit at the end of the chips row */
  order: 99;
}

/* Remove any absolute positioning from earlier */
#addNewClientBtn {
  position: static !important;
  right: auto !important;
  top: auto !important;
  transform: none !important;
  margin: 0;                   /* inline with chips */
}

/* Input no longer needs extra right padding for an absolute button */
#clientAutocomplete {
  padding-right: 12px !important;
    background-color: #90EE90 !important;  /* ensure the field stays light green */
}

#clientAutocomplete:focus,
#clientAutocomplete:active,
#clientAutocomplete:disabled,
#clientAutocomplete[readonly] {
  background-color: #90EE90 !important;  /* keep all states consistent */
  
}

/* Keep suggestions neatly inside the blue box */
#autocompleteSuggestions {
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px);
}

/* === Chips (left) + NEW CLIENT (right) inline row inside blue box === */
.recent-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 0 0 8px 0; /* space below row before the input */
}

/* Let chips use all the leftover width; wrap nicely */
.recent-row .recent-bar.inside-autocomplete {
  flex: 1 1 auto;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  min-width: 0; /* allow wrapping in narrow screens */
}

/* Make the blue box padding uniform now that the button isn't absolute */
.client-input-wrap {
  padding: 10px 12px 12px 12px !important; /* override any earlier larger right padding */
  border: 2px solid #1E90FF;
  border-radius: 10px;
  background: #fff;
}

/* NEW CLIENT button: real button, stacked text, sits on the right */
#addNewClientBtn.recent-add-btn {
  display: inline-flex;
  flex-direction: column;     /* "NEW" on top of "CLIENT" */
  align-items: center;
  justify-content: center;
  gap: 2px;
  font-weight: 700;
  line-height: 1.1;
  padding: .4rem .8rem;
  border-radius: 9999px;
  border: 1px solid #ddd;
  background: var(--submit-button-color); /* your purple */
  color: var(--text-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,.12);
  white-space: nowrap;        /* keep the two-line label neat */
}

/* Strip any old absolute positioning */
#addNewClientBtn {
  position: static !important;
  right: auto !important;
  top: auto !important;
  transform: none !important;
  margin: 0 !important;
}

/* Input no longer needs huge right padding (button is not on top of it) */
#clientAutocomplete {
  padding-right: 12px !important;
}

/* Keep suggestions neatly inside the blue box */
#autocompleteSuggestions {
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px);
}

/* === AUTOCOMPLETE: force one-line baseline (actual shrinking is done by JS) === */
/* paste AFTER your last #autocompleteSuggestions {...} block */
#clientAutocomplete,
#autocompleteSuggestions div {
  white-space: nowrap;      /* never wrap; we‚Äôll shrink instead */
  overflow: hidden;         /* avoid accidental overflow during resize */
  text-overflow: clip;      /* no ellipsis; we‚Äôre going to scale text down */
  line-height: 1.2;         /* keeps rows tidy when we shrink font-size */
}


/* === SUGGESTION ROWS: one line, overflow hidden; baseline stays large === */
#autocompleteSuggestions > div {
  white-space: nowrap;     /* never wrap; we‚Äôll shrink font-size if needed */
  overflow: hidden;        /* clip while we measure/shrink */
  text-overflow: clip;     /* no ellipsis, we‚Äôre shrinking instead */
  width: 100%;             /* make the available width explicit */
  box-sizing: border-box;
}


/* Hide status dots in recent chips */
.rc-dot { display: none !important; }
/* === RECENT CLIENTS: show ONLY the name === */
#recentClientsBar .rc-cat,
#recentClientsBar .rc-chip,
#recentClientsBar .rc-dot {
  display: none !important;
}

/* Mobile: show only the first two recent clients to keep the row compact */
@media (max-width: 640px) {
  #recentClientsBar .recent-pill:nth-child(n+3) {
    display: none !important;
  }
}

/* keep the pill compact now that only the name shows */
#recentClientsBar .recent-pill {
  gap: 0.25rem;
  padding: .35rem .6rem;
}

#recentClientsBar .rc-name {
  font-weight: 600;
}

/* === NEW CLIENT button: standard look, right side of the blue box === */
#addNewClientBtn {
  position: absolute;       /* anchor to the blue box */
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;                /* no auto-centering */
  display: inline-block;    /* standard button look */
  white-space: nowrap;      /* keep "NEW CLIENT" on one line */
}

/* Ensure the input leaves room for the absolutely-positioned button */
#clientAutocomplete {
  padding-right: 130px !important;
}

/* Make sure the blue wrapper keeps the absolute button inside it */
.client-input-wrap {
  position: relative !important;
}


/* === NEW CLIENT button (two-line), aligned right of recent chips === */

/* Make the row a proper flex container; chips take space, button sits at the end */
.recent-row#recentRow {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
}

/* Keep chips on a single line; JS will shrink font-size to fit */
.recent-row#recentRow .recent-bar.inside-autocomplete {
  flex: 1 1 auto;
  display: flex;
  flex-wrap: nowrap;
  gap: 6px;
  min-width: 0;
  margin-right: 0px;
}

/* Two-line NEW CLIENT pill on the right; standard button styling + stacked text */
#addNewClientBtn {
  margin-left: auto;            /* push button to the right */
  display: inline-flex;
  flex-direction: column;       /* NEW above CLIENT */
  align-items: center;
  justify-content: center;
  white-space: normal;          /* allow the line break */
  line-height: 1.1;             /* tighten the two lines slightly */
  padding: 10px 20px;           /* match your standard button padding */
  border-radius: 4px;           /* match your global button radius */
  background: var(--submit-button-color); /* same purple you use for submit-style buttons */
  color: var(--text-color);
  font-weight: bold;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  cursor: pointer;
}

/* Keep spans block-level so the text stacks cleanly with no weird gaps */
#addNewClientBtn span { display: block; }

/* Hover/active states consistent with other buttons */
#addNewClientBtn:hover, #addNewClientBtn:focus {
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  filter: brightness(85%);
}
#addNewClientBtn:active {
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  transform: translateY(1px);
  filter: brightness(75%);
}

/* Ensure the input no longer reserves right-side padding (button is in-row now) */
#clientAutocomplete {
  padding-right: 12px !important;
}

/* Make sure the blue wrapper is the containing context */
.client-input-wrap {
  position: relative !important;
    padding: 10px 12px !important;

}

/* Ensure consistent, not-huge sizing for the button */
#addNewClientBtn,
#addNewClientBtn.recent-add-btn {
  font-size: 1rem;     /* prevent inherited upsizing */
  line-height: 1.1;    /* tight lines so it looks clean */
  display: inline-flex;
  flex-direction: column;  /* NEW over CLIENT */
  align-items: center;
  gap: 2px;                /* single, small gap between lines */
  min-width: 0;            /* allow shrink-to-fit alongside recent chips */
}

/* Stack spans cleanly (no extra breaks) */
#addNewClientBtn span {
  display: block;
  margin: 0;              /* no extra space */
  padding: 0;
}
/* FIX: Nudge the NEW CLIENT button slightly left */
#addNewClientBtn {
  margin-right: 30px !important;
}

/* ‚Äî QUICK HIDE: Scroll button + Tasks box ‚Äî */
#scrollBottomBtn { display: none !important; }
#updateTasksContainer { display: none !important; }

/* === FORCE "NEW CLIENT" TO ONE LINE INSIDE THE PURPLE BUTTON === */
#addNewClientBtn,
#addNewClientBtn.recent-add-btn {
  display: inline-flex;
  flex-direction: row !important;   /* override any earlier column setting */
  align-items: center;
  gap: 6px;                         /* space between NEW and CLIENT */
  white-space: nowrap !important;   /* never wrap to two lines */
  line-height: 1.1;
}

#addNewClientBtn span {
  display: inline !important;       /* inline so they sit on one line */
}

/* === Keep all four recent items shrinking together ====================== */
#recentRow { 
  font-size: 1rem;                 /* shared base size for the bar */
}

/* Let every direct child shrink (3 recents + NEW CLIENT) */
#recentRow > * {
  flex-shrink: 1;
  font-size: 1em !important;      /* keep siblings on the same scale */
}

#recentRow .recent-bar.inside-autocomplete {
  flex-wrap: nowrap;               /* JS will shrink font-size instead of wrapping */
  min-width: 0;                    /* allow chips to contract */
}

/* Prevent chip text from overflowing when the bar shrinks */
#recentRow .recent-pill {
  min-width: 0;
}

#recentRow .recent-pill .rc-name {
  display: block;
  min-width: 0;
  overflow: visible;            /* never hide behind ellipses */
  text-overflow: clip;          /* rely on font shrink instead */
}

/* Keep pill text bound to the shared row font size */
#recentRow .recent-pill,
#recentRow .recent-pill .rc-name {
  font-size: 1em !important;
}

/* NEW CLIENT shrinks with the row and keeps em-based padding */
#addNewClientBtn,
#addNewClientBtn.recent-add-btn {
  flex: 0 1 auto;
  min-width: 0;
  font-size: 1em !important;       /* lock to row sizing */
  padding: 0.45em 0.9em;
  gap: 0.35em;
  margin-right: 0 !important;      /* avoid forced overflow */
  white-space: nowrap !important;  /* stay on one line; shrink instead */
}

#addNewClientBtn span {
  display: inline-block !important;
  font-size: 1em !important;       /* keep both words the same scale */
}

.cat-pill {
  position: relative;
  display: inline-flex;
  align-items: center;
  max-width: min(42vw, 380px);
  border: 1px solid #cfcfcf;
  border-radius: 999px;
  padding: 4px 28px 4px 10px;
  background: #fff;
  height: 32px;
}
.cat-input {
  border: 0; outline: 0; width: 100%;
  font: inherit; line-height: 1;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.cat-input::placeholder { color: #777; }
.cat-caret {
  position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
  font-size: 10px; pointer-events: none;
}

/* Calendar icon button */
.calendar-btn {
  border: 0;
  background: transparent;
  color: inherit;
  border-radius: 4px;
  height: 40px;
  width: 40px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
}
.calendar-btn .calendar-emoji {
  font-size: 28px;
  line-height: 1;
}

/* Modal */
.modal {
  position: fixed; inset: 0; background: rgba(0,0,0,.4);
  display: flex; align-items: center; justify-content: center;
  z-index: 1000;
}
.modal-card {
  width: 50vw; height: 50vh; background: #fff; border-radius: 12px;
  display: flex; flex-direction: column; overflow: hidden;
}
.modal-header, .modal-footer {
  padding: 12px 16px; border-bottom: 1px solid #eee;
  display: flex; align-items: center; justify-content: space-between;
}
.modal-footer { border-top: 1px solid #eee; border-bottom: 0; }
.modal-body { padding: 16px; display: grid; gap: 12px; }
.form-row { display: grid; grid-template-columns: 120px 1fr; gap: 8px; align-items: center; }
.modal-close, .btn-secondary, .btn-primary {
  border: 0; border-radius: 8px; height: 32px; padding: 0 12px; cursor: pointer;
}
.btn-secondary { background: #efefef; }
.btn-primary { background: #21a45e; color: #fff; }

/* Appointment scheduling modal */
.appointment-modal-card {
  width: min(520px, 92vw);
  height: auto;
  box-shadow: 0 12px 40px rgba(0,0,0,.18);
}

.appointment-modal-header {
  gap: 6px;
}

.appointment-modal-title {
  font-size: 20px;
  font-weight: 800;
}

.appointment-modal-subtitle {
  font-size: 13px;
  color: #6b7280;
  margin-top: 2px;
}

.appointment-modal-body {
  background: #f8fafc;
  padding: 18px 18px 10px;
  gap: 14px;
}

.appointment-field {
  display: flex;
  flex-direction: column;
  gap: 6px;
  font-size: 14px;
  font-weight: 700;
  color: #1f2937;
}

.appointment-field input {
  width: 100%;
  padding: 10px 12px;
  font-size: 14px;
  border-radius: 10px;
  border: 1px solid #cbd5e1;
  background: #fff;
}

.appointment-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.appointment-icon-btn {
  background-color: transparent;
  color: #1f2937;
  width: 44px;
  height: 44px;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}


</style>


</head>
<body onload="loadAllHeatmaps()">
    <!-- Loading Bar -->

  <div id="loadingBarContainer" style="display: none;">
    <div id="loadingBar"></div>
</div>

<!-- Hover bubble for name suggestions -->
<div id="nameHoverBubble" role="listbox" aria-label="Related clients"></div>

<div class="client-container">
  <div class="client-input-wrap">
    <!-- RECENT CLIENTS: inside the blue box, above the input -->
<!-- RECENT CLIENTS: inside the blue box, chips on the left; NEW CLIENT on the right -->
<div class="recent-row" id="recentRow">
  <div id="recentClientsBar" class="recent-bar inside-autocomplete"></div>

  <!-- Single, two-line button on the right -->
  <button id="addNewClientBtn" type="button" class="recent-add-btn" onclick="displayAddNewClientModal()">
    <span>NEW</span><span>CLIENT</span>
  </button>
</div>


</div>

    <input type="text" id="clientAutocomplete"
           placeholder="Type Client Name"
           oninput="autocompleteClient()">

           <!-- Category combo + Calendar icon (hidden until a client is selected) -->
<div id="catCalWrap" style="display:none; gap:8px; align-items:center; margin-left:auto;">
  <!-- Category pill (combobox) -->
  <div class="cat-pill" title="" >
    <input id="categoryCombo"
           type="text"
           placeholder="Select category"
           list="categoryList"
           aria-label="Category"
           aria-expanded="false"
           aria-autocomplete="list"
           class="cat-input" />
    <span class="cat-caret" aria-hidden="true">‚ñº</span>
    <datalist id="categoryList"></datalist>
  </div>

  <!-- Calendar button -->
  <button id="calendarBtn" class="calendar-btn" title="Open calendar">
    <!-- simple calendar glyph (text style, no color fill) -->
    <span class="calendar-emoji" aria-hidden="true">&#x1F5D3;&#xFE0E;</span>
  </button>
</div>


  </div>

  <select id="clientSelect" onchange="showClientNotes()" style="display: none;">
    <option value="" disabled selected>Select a Client</option>
  </select>
</div>






  <div class="labels-container">
    <div class="labels-notes-left">
      <div class="labels-top-row">
          <select id="labelsDropdown" onchange="addLabelToClient(this.value)">
            <option value="" disabled selected>ADD</option>
          <!-- Options will be dynamically populated here -->
          <option value="NEW LABEL">NEW LABEL</option>
        </select>
        <div id="labelsChipSlot" class="labels-chip-slot"></div>
      </div>
      <div id="labelsDisplay">
        <!-- Labels will be displayed here -->
      </div>
      <div id="notesDisplay">
          <!-- Notes will be displayed here -->
      </div>
    </div>
    <div id="labelsAdditionSection">
        <div id="categoryChangeSection" class="category-overlay" aria-hidden="true" style="display:none;">
          <select id="categorySelect" class="category-select">
            <option value="">‚ñº</option>
          </select>
        </div>

      <div id="labelsButtonsRow" class="labels-buttons-row"></div>



    </div>
  </div>





  <div id="workSectionsContainer" style="display: flex; flex-direction: row; justify-content: space-between; align-items: stretch;">

    
    <!-- Past Work submission -->
    <div id="pastWorkSection" style="flex: 1 1 100%; padding-right: 0; display: none; flex-direction: column; justify-content: flex-end; width: 100%; max-width: 100%;">
        <div class="past-work-wrapper">
          <textarea id="newPastWork" class="past-work-textarea"></textarea>
          <button type="button" class="update-team-task-btn" onclick="submitPastWork()">SUBMIT</button>
        </div>
<!-- In-Progress (Loaded) with left-side bulb -->
<div class="inprogress-bulb-row" style="background-color:#90EE90; padding:10px; border:1px solid #ccc; border-radius:4px; display:flex; align-items:flex-start; gap:10px;">
  <span aria-hidden="true" style="font-size:1.25em; line-height:1; margin-top:4px;">üí°</span>
  <textarea id="loadedInProgressArea"
            style="flex:1 1 auto; width:100%; min-height:60px; background-color:white; box-sizing:border-box;"
            onblur="onInProgressLoadedBlur(this.value)"></textarea>
</div>

<br>


    </div>
<!-- Future Work submission (deprecated/removed) -->
<!-- intentionally left blank -->


</div>



</div>




<!-- Area to display clients based on selected category -->
<div id="categoryClientsDisplay">
    <!-- Clients will be displayed here -->
</div>

<br>
<!-- Add the HIDE CLIENT NOTES button here -->
<button id="hideClientNotesBtn" class="secondary-button" onclick="hideClientNotes()" style="display:none;">HIDE CLIENT NOTES</button>

<!-- Appointment scheduling modal -->
<div id="appointmentModal" class="modal" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="appointmentModalTitle" aria-hidden="true">
  <div class="modal-card appointment-modal-card">
    <div class="modal-header appointment-modal-header">
      <div>
        <div id="appointmentModalTitle" class="appointment-modal-title">Schedule appointment</div>
        <div id="appointmentModalSubtitle" class="appointment-modal-subtitle">Choose a date and start time for this client.</div>
      </div>
      <button type="button" class="modal-close" aria-label="Close appointment modal" onclick="closeAppointmentModal()">‚úï</button>
    </div>
    <div class="modal-body appointment-modal-body">
      <label class="appointment-field">
        <span>Date</span>
        <input type="date" id="appointmentDate" class="appointment-input">
      </label>
      <label class="appointment-field">
        <span>Start time</span>
        <input type="time" id="appointmentTime" class="appointment-input">
      </label>
    </div>
    <div class="modal-footer appointment-modal-footer">
      <button type="button" class="btn-secondary" onclick="closeAppointmentModal()">Cancel</button>
      <button type="button" class="btn-primary" onclick="submitAppointmentToCalendar()">Add to calendar</button>
    </div>
  </div>
</div>


<hr style="border: 4px solid black;">
<!-- Removed the 'button-container' div -->
<!-- Container for title and buttons -->
<div id="titleButtonContainer" class="title-button-container">
    <!-- Inline row: Date + filter dropdown + bulb -->
    <div class="row" id="topClientsControlRow">
        <div id="dateTitle" class="title-text"></div>

        <!-- FILTER DROPDOWN (unchanged) -->
        <select id="topClientsFilterDropdown">
            <option value="JB">JB</option>
            <option value="RB">RB</option>
            <option value="QC">QC</option>
            <option value="TEAM">TEAM</option>
            <option value="BDAY">BDAY</option>
            <option value="BRIEFCASE">üíº</option>
            <option value="STAR">‚≠ê</option>
            <option value="GRADCAP">üéì</option>
            <option value="PHONE">üìû</option>
        </select>

        <!-- NEW: SUGGESTIONS button inline with the dropdown -->
        <button id="suggestionsToggleBtn" type="button" class="secondary-button" onclick="toggleSuggestions()">
            üí°
        </button>
    </div>

    <!-- Second Row: Top Clients Title and Add New Client Button -->
    <div class="row" id="topClientsAddNewRow">
        <div id="topClientsTitle" class="title-text"></div>
        <!-- SNIPPET A: REPLACEMENT BUTTON -->
        <button id="scrollBottomBtn" class="secondary-button" onclick="scrollToBottomInOneSecond()">SCROLL DOWN</button>
    </div>

</div>



<!-- Modal for displaying categories -->
<div id="categoriesModal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close" onclick="closeCategoriesModal()">&times;</span>
        <h2>Category: #</h2>
        <div id="categoriesModalContent">
            <!-- Content will be dynamically added here -->
        </div>
    </div>
</div>


<div id="topClientsDisplay"></div> <!-- Client display area -->

<!-- Modal for adding new client -->
<div id="addClientModal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close" onclick="closeAddClientModal()">&times;</span>
        <div id="addClientModalContent">
            <!-- Content will be dynamically added -->
        </div>
    </div>
</div>

<!-- Modal for NEW CATEGORY -->
<div id="newCategoryModal" class="modal" style="display:none;">
  <div class="modal-content">
    <span class="close" onclick="closeNewCategoryModal()">&times;</span>
    <h2>Add New Category</h2>
    <p>Type a new category name (this will be saved to the selected client and appear in the list next load):</p>
    <input id="newCategoryInput" type="text" placeholder="e.g., Referral, Prospect A, Family" />
    <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end;">
      <button class="secondary-button" onclick="closeNewCategoryModal()">Cancel</button>
      <button onclick="confirmNewCategory()">Save</button>
    </div>
  </div>
</div>

<!-- Appointment modal -->
<div id="apptModal" class="modal" style="display:none;">
  <div class="modal-card">
    <div class="modal-header">
      <span id="apptTitle">Schedule appointment</span>
      <button id="apptClose" class="modal-close" aria-label="Close">‚úï</button>
    </div>
    <div class="modal-body">
      <label class="form-row">
        <span>Date</span>
        <input id="apptDate" type="date" />
      </label>
      <label class="form-row">
        <span>Time</span>
        <input id="apptTime" type="time" />
      </label>
    </div>
    <div class="modal-footer">
      <button id="apptCancel" class="btn-secondary">Cancel</button>
      <button id="apptSave" class="btn-primary">Save</button>
    </div>
  </div>
</div>


<hr>
<!-- ==================================== -->
<!-- BEGIN SNIPPET B: ADVANCED TOGGLE     -->
<!-- ==================================== -->
<hr style="border: 3px solid black;"> 

<div id="advancedContainer" style="display: none;">
    <button onclick="displayFilteredClients('all')">All</button>

    <div id="quadrantSelection" style="display: grid; grid-template-columns: repeat(2, auto); gap: 20px; margin-bottom: 20px;">
      <button id="immediateBtn" onclick="selectButton('immediateBtn', '#FF0000', 'strictPast')">IMMEDIATE</button>
      <button id="pendingBtn" onclick="selectButton('pendingBtn', '#FFFF00', 'strictUpcoming')">PENDING</button>
      <button id="deferredBtn" onclick="selectButton('deferredBtn', '#FFA500', 'flexiblePast')">DEFERRED</button>
      <button id="adjustableBtn" onclick="selectButton('adjustableBtn', '#0000FF', 'flexibleUpcoming')">ADJUSTABLE</button>
    </div>

    <button onclick="displayFilteredClients('others')">Others</button>

    <hr>
    <button id="todayButton" class="secondary-button" onclick="showTodaysTasks()">APPOINTMENTS</button>
    <div id="todaysTasksDisplay" style="display:none;"></div>

    <hr>
    <div id="timeSensitiveTasksDisplay">
        <!-- Time-sensitive tasks will be displayed here -->
    </div>

    <hr>
    <hr>
    <div id="tasksDisplay"></div> <!-- Make sure this element is present -->

    <hr>
    <button id="birthdaysBtn" class="secondary-button" onclick="displayBirthdays()">Birthdays</button>
    <!-- Birthdays Display Section -->
    <div id="birthdaysDisplay">
        <!-- Birthday information will be populated here -->
    </div>

    <hr>
    <button id="loadNotesButton" class="secondary-button">TODAY</button>
    <div id="notesDisplayArea">

      <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
        <button onclick="filterClients('Sun')" style="width: 110px; height: 60px; font-size: small;">Sun</button>
        <button onclick="filterClients('Mon')" style="width: 110px; height: 60px; font-size: small;">Mon</button>
        <button onclick="filterClients('Tues')" style="width: 110px; height: 60px; font-size: small;">Tues</button>
        <button onclick="filterClients('Wed')" style="width: 110px; height: 60px; font-size: small;">Wed</button>
        <button onclick="filterClients('Thurs')" style="width: 110px; height: 60px; font-size: small;">Thurs</button>
        <button onclick="filterClients('Fri')" style="width: 110px; height: 60px; font-size: small;">Fri</button>
        <button onclick="filterClients('Sat')" style="width: 110px; height: 60px; font-size: small;">Sat</button>
      </div>

      <div id="clientDisplay"></div>

      <hr> 
      <button id="graphsBtn" onclick="toggleGraphs()">GRAPHS</button>
      <br>
      <div id="graphsContainer">

        <div id="tableContainer"></div>
        <div id="piechart" class="centered-chart"></div>
        <div id="heatmap" class="centered-chart"></div>
        <div id="futureHeatmap" class="centered-chart"></div>
        <div id="scatter_chart_div" class="centered-chart"></div>

      </div> <!-- /graphsContainer -->
    </div> <!-- /notesDisplayArea -->

</div> <!-- /advancedContainer -->
<!-- ==================================== -->
<!--  END SNIPPET B                      -->
<!-- ==================================== -->



<!-- COMMENT OUT ENDS HERE -->

<!-- Add this div to your HTML -->

<!-- Rest of your HTML content ... -->

<!-- SNIPPET #2: UPDATE BUTTON + TASKS DISPLAY -->


<div id="updateTasksContainer" style="border:3px solid black; padding:10px; margin:10px;">
  <h2>TASKS FROM SPREADSHEET</h2>
  <!-- We will dynamically populate the tasks here -->
  <div id="tasksList"></div>
</div>
<!-- END SNIPPET #2 -->


<script>

/* === FIT-TO-ONE-LINE ENGINE (input + suggestions) === */

/* Shared, hidden measurer for input text (so we can accurately measure "Name (Category)" in an <input>) */
(function initFitMeasurer(){
  const measurer = document.createElement('span');
  measurer.id = '__fit_measurer__';
  measurer.style.cssText = [
    'position:absolute','visibility:hidden','white-space:nowrap','pointer-events:none',
    'left:-99999px','top:-99999px'
  ].join(';');
  document.documentElement.appendChild(measurer);
})();

/* Returns the pixel width the input‚Äôs current value would occupy at a given font-size */
function measureInputTextPx(inputEl, fontPx){
  const measurer = document.getElementById('__fit_measurer__');
  if (!measurer || !inputEl) return 0;

  // Copy relevant computed styles so measurement matches
  const cs = getComputedStyle(inputEl);
  measurer.style.fontFamily   = cs.fontFamily;
  measurer.style.fontWeight   = cs.fontWeight;
  measurer.style.letterSpacing= cs.letterSpacing;
  measurer.style.textTransform= cs.textTransform;
  measurer.style.fontStyle    = cs.fontStyle;
  measurer.style.lineHeight   = cs.lineHeight;
  measurer.style.fontSize     = (fontPx || parseFloat(cs.fontSize)) + 'px';
  measurer.textContent        = inputEl.value || inputEl.placeholder || '';

  return measurer.getBoundingClientRect().width;
}

/* Shrink an element‚Äôs font-size until its scrollWidth fits within clientWidth (one line) */
function fitElementTextToOneLine(el, opts){
  if (!el) return;
  const cs = getComputedStyle(el);
  const maxPx = Math.max(10, parseFloat(cs.fontSize) || 16); // current as ceiling
  const minPx = Math.max(10, (opts && opts.minPx) || 10);    // don‚Äôt go below 10px unless you choose

  // Determine available width (account for padding)
  const rect = el.getBoundingClientRect();
  const style = cs;
  const padX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
  const available = Math.max(0, rect.width - padX);

  // Choose measuring method
  const isInput = (el.tagName === 'INPUT' && el.type === 'text');

  // Binary search for the largest font-size that fits
  let lo = minPx, hi = maxPx, best = minPx;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    let contentWidth;

    if (isInput) {
      contentWidth = measureInputTextPx(el, mid);
    } else {
      const prev = el.style.fontSize;
      el.style.fontSize = mid + 'px';
      // Force single-line overflow metrics
      contentWidth = el.scrollWidth;
      el.style.fontSize = prev;
    }

    if (contentWidth <= available) {
      best = mid;          // fits ‚Üí try to go larger
      lo = mid + 1;
    } else {
      hi = mid - 1;        // doesn‚Äôt fit ‚Üí go smaller
    }
  }

  // Apply only if we actually need to shrink
  const currentPx = parseFloat(cs.fontSize) || maxPx;
  if (best < currentPx) {
    el.style.fontSize = best + 'px';
  } else {
    // Reset in case a previous shrink is no longer necessary
    el.style.fontSize = '';
  }
}

/* Fit the autocomplete input‚Äôs current "Name (Category)" to one line */
function fitClientInputNow(){
  const input = document.getElementById('clientAutocomplete');
  if (!input) return;
  fitElementTextToOneLine(input, { minPx: 6 });
}

/* === HELPER: shrink a suggestion row only if it overflows === */
function shrinkSuggestionRow(row, minPx = 10) {
  if (!row) return;

  const cs = getComputedStyle(row);

  // Remember each row‚Äôs natural "big" font once; never grow beyond it.
  if (!row.__baseFontPx) {
    row.__baseFontPx = parseFloat(cs.fontSize) || 16;
  }

  // Start from the natural big size each time we re-evaluate.
  row.style.fontSize = row.__baseFontPx + 'px';

  // If it fits already, we‚Äôre done‚Äîkeep it big.
  if (row.scrollWidth <= row.clientWidth) return;

  // Otherwise, binary search down from base ‚Üí min to find the largest that fits.
  let lo = Math.max(10, minPx), hi = row.__baseFontPx, best = lo, prevInline = row.style.fontSize;

  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    row.style.fontSize = mid + 'px';

    if (row.scrollWidth <= row.clientWidth) {
      best = mid;      // fits ‚Üí try larger
      lo = mid + 1;
    } else {
      hi = mid - 1;    // doesn‚Äôt fit ‚Üí go smaller
    }
  }

  // Apply the best size we found (never larger than the row‚Äôs base).
  row.style.fontSize = Math.min(best, row.__baseFontPx) + 'px';
}


/* === REPLACEMENT: fit ALL visible suggestion rows by shrinking only if needed === */
function fitAllSuggestionRows() {
  const box = document.getElementById('autocompleteSuggestions');
  if (!box) return;

  // Prefer direct children as rows; if your renderer nests, the fallback ensures coverage.
  let rows = box.querySelectorAll(':scope > div');
  if (!rows.length) rows = box.querySelectorAll('#autocompleteSuggestions *:not(style):not(script)');

  rows.forEach(function(row) {
    shrinkSuggestionRow(row, 10);
  });
}


/* Re-fit on window resize (zoom/viewport changes often alter available width) */
window.addEventListener('resize', function(){
  fitClientInputNow();
  fitAllSuggestionRows();
});


/* === REPLACEMENT: Slow-grow (to ~90%), finish to 100, then shrink & hide === */
(function initLoadingBarController(){
  const container = document.getElementById('loadingBarContainer');
  const bar = document.getElementById('loadingBar');
  if (!container || !bar) return;

  let refCount = 0;           // how many concurrent loads
  let growTimer = null;       // interval driving slow growth
  let current = 0;            // current width as 0..100
  let target = 0;             // target width (we ease toward it)
  const MAX_IDLE = 90;        // idle ceiling while loading (don‚Äôt hit 100% until done)

  function startGrowLoop(){
    if (growTimer) return;
    growTimer = setInterval(() => {
      // ease toward target
      const delta = target - current;
      // small easing factor for a steady slow feel
      current += delta * 0.18;
      // clamp and paint
      if (current < 0) current = 0;
      if (current > 100) current = 100;
      bar.style.width = current.toFixed(2) + '%';
    }, 120);
  }

  (function(){
  let raf = null;
  window.addEventListener('resize', function(){
    if (raf) return;
    raf = requestAnimationFrame(function(){
      raf = null;
      fitAllSuggestionRows();
    });
  });
})();


  function stopGrowLoop(){
    if (growTimer) { clearInterval(growTimer); growTimer = null; }
  }

  function showNow(){
    container.style.display = 'block';
    bar.classList.add('indeterminate');
    // kick off at a tiny width so it feels instant
    current = Math.max(current, 6);
    target  = Math.max(target, 35);
    bar.style.width = current + '%';
    startGrowLoop();
  }

  function finishThenShrink(){
    // 1) finish to 100 quickly
    bar.classList.add('indeterminate'); // keep shimmer for the sprint
    target = 100;
    // when we visually reach ~100%, shrink back to zero and hide
    const checkDone = () => {
      if (current >= 99.5) {
        stopGrowLoop();
        // 2) short pause so the eye catches ‚Äúcomplete‚Äù
        setTimeout(() => {
          bar.classList.remove('indeterminate');
          // 3) animate shrink-to-zero
          target = 0;
          current = 100; // ensure starting point is full
          startGrowLoop();
          // after the shrink animation, hide & reset
          setTimeout(() => {
            stopGrowLoop();
            container.style.display = 'none';
            current = 0;
            target = 0;
            bar.style.width = '0%';
          }, 320); // slightly longer than the CSS 0.3s transition
        }, 180);
      } else {
        requestAnimationFrame(checkDone);
      }
    };
    requestAnimationFrame(checkDone);
  }

  // Public API
  window.showLoadingBar = function(){
    const wasZero = (refCount === 0);
    refCount++;
    if (wasZero) {
      showNow();
      // keep creeping toward MAX_IDLE during long loads
      target = Math.max(target, 55);
      setTimeout(() => { if (refCount > 0) target = Math.max(target, 72); }, 300);
      setTimeout(() => { if (refCount > 0) target = Math.max(target, 86); }, 1000);
      // never exceed MAX_IDLE until we‚Äôre told to hide
      const capIdle = setInterval(() => {
        if (refCount === 0) { clearInterval(capIdle); return; }
        if (target > MAX_IDLE) target = MAX_IDLE;
      }, 200);
    } else {
      // another request started ‚Üí nudge target a bit so it feels alive
      target = Math.min(Math.max(target, current + 6), MAX_IDLE);
    }
  };

  window.hideLoadingBar = function(){
    refCount = Math.max(0, refCount - 1);
    if (refCount === 0) finishThenShrink();
  };

  // Optional ‚Äúoh-no‚Äù lever if something goes haywire
  window.forceHideLoadingBar = function(){
    refCount = 0;
    stopGrowLoop();
    container.style.display = 'none';
    bar.classList.remove('indeterminate');
    current = 0; target = 0;
    bar.style.width = '0%';
  };
})();

// Global: whether suggestion textareas in the Top Clients list are visible
window.__suggestionsVisible = false;

function toggleSuggestions() {
  window.__suggestionsVisible = !window.__suggestionsVisible;
  applySuggestionsVisibility();
}


// ===== REQUEST TOKEN to prevent stale paints =====
let __topClientsRenderToken = 0;

function fetchAndRenderTopClientsFromDropdown() {
  const dd = document.getElementById('topClientsFilterDropdown');
  const wantedFilter = dd && dd.value ? dd.value.trim() : 'JB';
  const token = ++__topClientsRenderToken;

  google.script.run
    .withSuccessHandler(function (clients) {
      if (token !== __topClientsRenderToken) return;

      // Read again then NORMALIZE before render
      const dd2 = document.getElementById('topClientsFilterDropdown');
      const raw = dd2 && dd2.value ? dd2.value.trim() : wantedFilter;
      const currentFilter = normalizeTopClientsFilter(raw);

     if (typeof showTopClients === 'function') {
  showTopClients(clients, currentFilter);
}

// sanitize bulbs right after the list is painted
sanitizeSuggestionBulbs();

if (typeof wireToplistSuggestionTextareas === 'function') wireToplistSuggestionTextareas();
if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();

// run one more time after visibility toggles could hide/show blocks
sanitizeSuggestionBulbs();

    })
    .withFailureHandler(function (err) {
      console.error('fetchAndRenderTopClientsFromDropdown failed:', err);
    })
    .getTopClients();
}


function fitToplistSuggestionTextarea(textarea) {
  try {
    if (!textarea) return;

    const computed = window.getComputedStyle(textarea);
    const baseFont = parseFloat(textarea.dataset.baseFontSize || computed.fontSize || '16');
    if (!textarea.dataset.baseFontSize) {
      textarea.dataset.baseFontSize = String(baseFont);
    }

    let baseHeight = parseFloat(textarea.dataset.baseHeight || '');
    if (!baseHeight || Number.isNaN(baseHeight) || baseHeight <= 0) {
      const minHeight = parseFloat(computed.minHeight);
      if (!Number.isNaN(minHeight) && minHeight > 0) {
        baseHeight = minHeight;
      } else if (textarea.clientHeight > 0) {
        baseHeight = textarea.clientHeight;
      } else {
        const computedHeight = parseFloat(computed.height);
        baseHeight = (!Number.isNaN(computedHeight) && computedHeight > 0) ? computedHeight : 60;
      }
      textarea.dataset.baseHeight = String(baseHeight);
    }

    const clampHeight = baseHeight;
    textarea.style.minHeight = clampHeight + 'px';
    textarea.style.maxHeight = clampHeight + 'px';
    textarea.style.height = clampHeight + 'px';
    textarea.style.overflow = 'hidden';
    textarea.style.resize = 'none';

    const minFont = parseFloat(textarea.dataset.minFontSize || '8');
    let fontSize = baseFont;

    const overflows = () => textarea.scrollHeight > textarea.clientHeight + 0.5;

    textarea.style.fontSize = fontSize + 'px';

    while (overflows() && fontSize > minFont) {
      fontSize -= 1;
      textarea.style.fontSize = fontSize + 'px';
    }

    if (fontSize < baseFont) {
      while (!overflows() && fontSize < baseFont) {
        const next = Math.min(baseFont, fontSize + 1);
        textarea.style.fontSize = next + 'px';
        if (overflows()) {
          textarea.style.fontSize = fontSize + 'px';
          break;
        }
        fontSize = next;
      }
    }

    textarea.dataset.currentFontSize = String(fontSize);
  } catch (err) {
    console.error('fitToplistSuggestionTextarea error:', err);
  }
}

function scheduleSuggestionTextareaFit(textarea) {
  if (!textarea) return;
  const raf = window.requestAnimationFrame || function (cb) { return setTimeout(cb, 0); };
  raf(function () { fitToplistSuggestionTextarea(textarea); });
}


function applySuggestionsVisibility() {
  var blocks = document.querySelectorAll('.toplist-suggestion');
  blocks.forEach(function(b) {
    var visible = !!window.__suggestionsVisible;
    b.style.display = visible ? 'flex' : 'none';
    if (visible) {
      var ta = b.querySelector('textarea');
      if (ta) scheduleSuggestionTextareaFit(ta);
    }
  });

  // after visibility flips, re-enforce the single-left-bulb layout
  sanitizeSuggestionBulbs();
}

// === SINGLE SOURCE OF TRUTH: list <- dropdown value ===
function syncClientsListToDropdown(){
  var dd = document.getElementById('topClientsFilterDropdown');
  var val = dd && dd.value ? dd.value : 'JB';
  // Persist current choice + currently-open client (if any)
  try {
    saveUIState({
      filter: val,
      client: (document.getElementById('clientSelect')||{}).value || ''
    });
  } catch(_) {}

  // Stamp today‚Äôs date header and clear the title (your existing UI behavior)
  stampTodayDateTitle();
  (function clearTitle(){
    var titleEl = document.getElementById('topClientsTitle');
    if (!titleEl) return;
    titleEl.innerText = '';
    titleEl.style.display = 'none';
  })();

  fitTopClientsHeaderControls();

// Drive the render using a single, token-protected fetch
fetchAndRenderTopClientsFromDropdown();

}

// ===== CANONICAL: Re-render list strictly from dropdown =====
function retriggerTopClientsFilter() {
  // Always go through the same path
  syncClientsListToDropdown();
}

// Safe programmatic setter that also re-renders
function setFilterAndSync(value) {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  dd.value = (value || '').trim();
  syncClientsListToDropdown();
}

// On boot, if nothing is chosen yet, default to JB and immediately sync the list.
(function setInitialTopClientsFilter(){
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  if (!dd.value) dd.value = 'JB';
  syncClientsListToDropdown();
})();

// ===== Header helpers: keep the date, dropdown, and bulb in sync on one row =====
function formatTopClientsDates() {
  var now = new Date();
  return {
    longDate: now.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric'
    }).toUpperCase(),
    shortDate: now.toLocaleDateString('en-US', {
      month: '2-digit',
      day: '2-digit',
      year: '2-digit'
    })
  };
}

function stampTodayDateTitle() {
  var dt = document.getElementById('dateTitle');
  var dates = formatTopClientsDates();
  if (dt) {
    dt.dataset.longDate = dates.longDate;
    dt.dataset.shortDate = dates.shortDate;
    dt.innerText = dates.longDate;
  }
  return dates;
}

function updateDropdownWidthToFit(dd) {
  if (!dd) return;
  var label = '';
  if (dd.selectedIndex >= 0 && dd.options[dd.selectedIndex]) {
    label = dd.options[dd.selectedIndex].text || '';
  }
  label = label || dd.value || '';

  var cs = getComputedStyle(dd);
  var font = [cs.fontWeight, cs.fontSize, cs.fontFamily].join(' ');
  var canvas = updateDropdownWidthToFit.__canvas || (updateDropdownWidthToFit.__canvas = document.createElement('canvas'));
  var ctx = canvas.getContext('2d');
  ctx.font = font;

  var textWidth = ctx.measureText(label).width;
  var paddingLeft = parseFloat(cs.paddingLeft) || 0;
  var paddingRight = parseFloat(cs.paddingRight) || 0;
  var arrowAllowance = Math.max(24, (parseFloat(cs.fontSize) || 16) * 1.6); // space for the native arrow + mobile buffer

  var px = Math.ceil(textWidth + paddingLeft + paddingRight + arrowAllowance);
  dd.style.width = px + 'px';
  dd.style.minWidth = px + 'px';
}

function fitTopClientsHeaderControls(preferShortFormat) {
  var container = document.getElementById('topClientsControlRow');
  var dateEl = document.getElementById('dateTitle');
  var dd = document.getElementById('topClientsFilterDropdown');
  var bulb = document.getElementById('suggestionsToggleBtn');
  if (!container || !dateEl || !dd || !bulb) return;

  var dates = formatTopClientsDates();
  var longDate = (dateEl.dataset && dateEl.dataset.longDate) || dates.longDate;
  var shortDate = (dateEl.dataset && dateEl.dataset.shortDate) || dates.shortDate;

  // ensure dataset stays current
  dateEl.dataset.longDate = longDate;
  dateEl.dataset.shortDate = shortDate;

  var baseSize = parseFloat(container.dataset.baseFontSize || getComputedStyle(container).fontSize) || 16;
  container.dataset.baseFontSize = baseSize;
  var minSize = 8;
  var baseGap = parseFloat(container.dataset.baseGap || getComputedStyle(container).columnGap || 12);
  container.dataset.baseGap = baseGap;

  function applySize(px) {
    var val = px + 'px';
    container.style.fontSize = val;
    dateEl.style.fontSize = val;
    dd.style.fontSize = val;
    bulb.style.fontSize = val;
    var gapPx = Math.max(4, baseGap * (px / baseSize));
    container.style.columnGap = gapPx + 'px';
  }

  function tryDate(text) {
    dateEl.textContent = text;
    var size = baseSize;
    applySize(size);
    updateDropdownWidthToFit(dd);

    var fits = container.scrollWidth <= container.clientWidth;
    while (!fits && size > minSize) {
      size = Math.max(minSize, size - 0.5);
      applySize(size);
      updateDropdownWidthToFit(dd);
      fits = container.scrollWidth <= container.clientWidth;
      if (size === minSize) break;
    }
    return fits;
  }

  var firstChoice = preferShortFormat ? shortDate : longDate;
  var fitsLong = tryDate(firstChoice);
  if (!fitsLong && firstChoice !== shortDate) {
    tryDate(shortDate);
  }

  // Final guard: if space is still tight, lock to the compact date and minimum size
  // so the dropdown and bulb never overlap the date text.
  if (container.scrollWidth > container.clientWidth) {
    dateEl.textContent = shortDate;
    applySize(minSize);
    updateDropdownWidthToFit(dd);
  }
}

window.addEventListener('resize', function(){
  fitTopClientsHeaderControls();
});

window.addEventListener('load', function(){
  var dd = document.getElementById('topClientsFilterDropdown');
  if (dd) {
    updateDropdownWidthToFit(dd);
    dd.addEventListener('change', function(){
      updateDropdownWidthToFit(dd);
      fitTopClientsHeaderControls();
    });
  }
  stampTodayDateTitle();
  fitTopClientsHeaderControls();
});






function applyDefaultJBFilter() {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;

  // Select JB in the dropdown (this makes the visible label "JB")
  dd.value = 'JB';

  // Seed the date header and title immediately
  (function seedHeaders(){
    stampTodayDateTitle();

    var tt = document.getElementById('topClientsTitle');
    if (tt) {
      tt.innerText = '';
      tt.style.display = 'none';
    }
  })();

  fitTopClientsHeaderControls();

setFilterAndSync('JB'); // uses the canonical path

}



/* ===== PASTE #1 ‚Äî helpers for soft refresh + wiring ===== */
function refreshTopClientsPreservingScroll() {
  try {
    const y = window.scrollY || 0;
    const dd = document.getElementById('topClientsFilterDropdown');
    const currentFilter = (dd && dd.value) ? dd.value : 'JB';

    google.script.run
      .withSuccessHandler(function (clients) {
showTopClients(clients, normalizeTopClientsFilter(currentFilter));

// sanitize bulbs right after re-render
sanitizeSuggestionBulbs();

// Re-wire suggestion textareas so blur-save continues to work
wireToplistSuggestionTextareas();

// Keep your Suggestions toggle state
if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();

// and sanitize once more after visibility logic
sanitizeSuggestionBulbs();

        requestAnimationFrame(function () { window.scrollTo(0, y); });
        if (typeof hideLoadingBar === 'function') hideLoadingBar();
      })
      .withFailureHandler(function (err) {
        console.error('refreshTopClientsPreservingScroll error:', err);
        if (typeof hideLoadingBar === 'function') hideLoadingBar();
      })
      .getTopClients();
  } catch (e) {
    console.error('refreshTopClientsPreservingScroll try/catch error:', e);
    if (typeof hideLoadingBar === 'function') hideLoadingBar();
  }
}

/* ===== REPLACEMENT: wireToplistSuggestionTextareas (no full refresh on blur) ===== */
function wireToplistSuggestionTextareas() {
  const nodes = document.querySelectorAll('#topClientsDisplay .toplist-suggestion textarea.note-textarea, #topClientsDisplay .toplist-suggestion textarea.toplist-textarea');

  nodes.forEach(function (ta) {
        if (ta.dataset.wiredSuggestion === 'true') return;
    ta.dataset.wiredSuggestion = 'true';

    // Never let clicks/focus bubble up and cause row-level re-renders
    ['mousedown', 'click', 'focus'].forEach(function(ev){
      ta.addEventListener(ev, function (e) { e.stopPropagation(); }, true);
    });

    // Find the client name (prefer data attribute)
    let clientName = ta.getAttribute('data-client');
    if (!clientName) {
      const host = ta.closest('[data-client]');
      if (host) clientName = host.getAttribute('data-client');
    }
    if (!clientName) {
      const btn = ta.closest('div')?.querySelector('button.inline-button');
      if (btn) clientName = btn.innerText.trim();
    }
    if (!clientName) return; // can't save without a client

    ta.setAttribute('data-client', clientName);
    ta.classList.add('inProgressArea');
    if (!ta.hasAttribute('data-last-saved')) {
      ta.setAttribute('data-last-saved', ta.value || '');
    }
    let dirty = false;

        const getBaseline = () => {
      const stored = ta.getAttribute('data-last-saved');
      return stored != null ? stored : '';
    };

    const syncDirty = () => {
      dirty = (ta.value !== getBaseline());
    };


    ta.addEventListener('input', function () {
      syncDirty();
    });

    // Ctrl/‚åò+Enter = quick commit
    ta.addEventListener('keydown', function (e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        ta.blur();
      }
      e.stopPropagation();
    }, true);

    // SAVE ONLY ON BLUR ‚Äî but DO NOT re-render the whole list
    ta.addEventListener('blur', function () {
      const baseline = getBaseline();
      const pendingValue = ta.value;
      if (!dirty || pendingValue.trim() === baseline.trim()) {
        dirty = false;
        return;
      }


      if (typeof showLoadingBar === 'function') showLoadingBar();

      google.script.run
        .withSuccessHandler(function () {
          // Keep the screen exactly as-is; just lock in the new value
          dirty = false;
          ta.setAttribute('data-last-saved', pendingValue || '');

          // Small visual ack near the textarea
          if (typeof showInlineSavedBadge === 'function') {
            showInlineSavedBadge(ta);
          }
      if (typeof updateInProgressDom === 'function') {
            updateInProgressDom(clientName, pendingValue);
          }          if (typeof hideLoadingBar === 'function') hideLoadingBar();
        })
        .withFailureHandler(function (err) {
          alert('Error saving In Progress: ' + (err && err.message ? err.message : err));
          ta.value = baseline; // revert
          dirty = false;
                    ta.setAttribute('data-last-saved', baseline || '');

          if (typeof hideLoadingBar === 'function') hideLoadingBar();
        })
        // ‚¨áÔ∏è CHANGE THIS if your server save function has a different name
        .updateClientColumnL(clientName, pendingValue);
    }, true);
  });
}
/* ===== END REPLACEMENT ===== */

/* Tiny helper for a subtle "Saved" badge */
function showInlineSavedBadge(textarea) {
  try {
    let badge = document.createElement('span');
    badge.textContent = 'Saved';
    badge.style.marginLeft = '8px';
    badge.style.fontSize = '0.8em';
    badge.style.opacity = '0.85';
    badge.style.background = '#e8f5e9';
    badge.style.border = '1px solid #c8e6c9';
    badge.style.borderRadius = '10px';
    badge.style.padding = '2px 8px';
    // place after textarea
    let parent = textarea.parentNode;
    parent.appendChild(badge);
    setTimeout(() => { badge.remove(); }, 1500);
  } catch (_) {}
}

/* ===== END PASTE #1 ===== */

// Initial setup of button colors

document.getElementById('immediateBtn').style.backgroundColor = '#FFCCCC';
document.getElementById('pendingBtn').style.backgroundColor = '#FFFFCC';
document.getElementById('deferredBtn').style.backgroundColor = '#FFD9B3';
document.getElementById('adjustableBtn').style.backgroundColor = '#ADD8E6';




var clientsData = [];
/* ===== NAME LINKIFY + HOVER BUBBLE HELPERS ===== */
var __clientNames = [];           // Full client names (Column A)
var __nameTokens = [];            // Unique tokens from names (first/last/etc., len > 3)
var __nameUnionRegex = null;      // Combined regex (longest-first) of full names + tokens
var __hideBubbleTimer = null;

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function escapeHTML(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/** Split a full name into reasonable tokens (letters, digits, apostrophes, hyphens). */
function tokenizeNameParts(name) {
  // Split on anything that‚Äôs NOT allowed inside a name token
  // (space, commas, slashes, ampersands, periods, etc.)
  return String(name)
    .split(/[^A-Za-z0-9'-]+/)
    .map(t => t.trim())
    .filter(t => t.length > 3); // only >3 chars per your rule
}

/** Build the master arrays + union regex from clientsData (Column A). */
function rebuildClientNameIndex() {
  try {
    // 1) Collect full names (>3 chars)
    __clientNames = (clientsData || [])
      .map(c => (c && c.clientName) ? String(c.clientName).trim() : '')
      .filter(n => n && n.length > 3);

    // Dedupe full names (case-insensitive)
    const seenFull = new Set();
    __clientNames = __clientNames.filter(n => {
      const key = n.toLowerCase();
      if (seenFull.has(key)) return false;
      seenFull.add(key);
      return true;
    });

    // 2) Tokenize into first/last/etc. (>3 chars), dedupe
    const tokenSet = new Set();
    __clientNames.forEach(n => {
      tokenizeNameParts(n).forEach(tok => tokenSet.add(tok));
    });
    __nameTokens = Array.from(tokenSet);

    // 3) Combine (full names + tokens), longest-first to prefer full names when contiguous
    const parts = Array.from(new Set(
      __clientNames.concat(__nameTokens).map(escapeRegex)
    )).sort((a, b) => b.length - a.length);

    __nameUnionRegex = parts.length
      ? new RegExp('(?:^|\\b)(' + parts.join('|') + ')(?:\\b|$)', 'gi')
      : null;
  } catch (e) {
    console.error('rebuildClientNameIndex error:', e);
    __clientNames = [];
    __nameTokens = [];
    __nameUnionRegex = null;
  }
}

/** Wrap occurrences of full names OR known tokens with span.client-mention. */
function linkifyText(plainEscaped) {
  if (!__nameUnionRegex) return plainEscaped;
  // plainEscaped is already escaped; replacing safe text substrings is fine.
  return plainEscaped.replace(__nameUnionRegex, function (_full, captured) {
    const shown = captured;
    return '<span class="client-mention" data-fragment="' + escapeHTML(shown) + '">' + escapeHTML(shown) + '</span>';
  });
}
// === DATE BOLDING + SAFE NOTE HTML PIPELINE ===
// We work on *escaped* text so we can safely inject <strong> tags.
// Matches leading or standalone dates like 6/6/24, 06/06/24, 06/06/2024 (optionally followed by a colon).
function boldDatesEscaped(escapedText) {
  if (!escapedText) return escapedText;

  // 1) Bold a date at the very start of a line (beginning or after a <br>)
  const startOfLineDate = /(^|<br\s*\/?>)\s*(\d{1,2}\/\d{1,2}\/\d{2,4})(?=\b:?\s)/g;
  let out = escapedText.replace(startOfLineDate, function(_, br, date) {
    return (br || '') + '<strong>' + date + '</strong>';
  });

  // 2) Also bold any other date tokens that appear elsewhere in the line (optional; keep if you want all dates bold)
  const anyDate = /\b(\d{1,2}\/\d{1,2}\/\d{2,4})\b/g;
  out = out.replace(anyDate, function(match) {
    // Avoid double-wrapping if already bolded
    if (/^<strong>.*<\/strong>$/.test(match)) return match;
    return '<strong>' + match + '</strong>';
  });

  return out;
}

// Given a *plain* note string, return safe HTML with bolded dates and linkified names/tokens.
function formatNoteHTML(plainText) {
  const escaped = escapeHTML(String(plainText || ''));
  const withBoldDates = boldDatesEscaped(escaped);
  // Reuse your existing name linkifier on the escaped+bolded text
  return linkifyText(withBoldDates);
}

// PASTE THIS WHOLE BLOCK **IMMEDIATELY AFTER** the closing brace of formatNoteHTML(...)
// (i.e., after: function formatNoteHTML(plainText) { ... })
function renderNoteLine(lineText, chipHTML) {
  // lineText is the original plain text for the note line (no HTML)
  // chipHTML is a string like `<span class="chip ...">...</span>` or '' if none
  const safeNoteHTML = formatNoteHTML(lineText);
  return chipHTML ? (safeNoteHTML + ' ' + chipHTML) : safeNoteHTML;
}


/** Attach hover/click handlers to mentions inside a container. */
function attachMentionHandlers(container) {
  if (!container) return;
  const mentions = container.querySelectorAll('.client-mention');
  mentions.forEach(function (el) {
    el.addEventListener('click', function (e) {
      e.stopPropagation();
      const frag = (el.getAttribute('data-fragment') || '').trim();
      if (!frag) return;

      // If the fragment exactly equals a full client name, load it directly.
      const exact = __clientNames.find(n => n.toLowerCase() === frag.toLowerCase());
      if (exact) {
        selectClientFromButton(exact);
        scrollToTop();
        hideNameBubble();
        return;
      }

      // Otherwise show chooser bubble anchored to this token.
      showNameBubbleForFragment(frag, el.getBoundingClientRect());
    });

    el.addEventListener('mouseenter', function (e) {
      e.stopPropagation();
      const frag = (el.getAttribute('data-fragment') || '').trim();
      showNameBubbleForFragment(frag, el.getBoundingClientRect());
    });

    el.addEventListener('mousemove', function (e) {
      positionBubbleNearMouse(e.clientX, e.clientY);
    });

    el.addEventListener('mouseleave', function () {
      scheduleHideNameBubble();
    });
  });
}

/** Build the suggestion list for the hovered fragment and show bubble. */
function showNameBubbleForFragment(fragment, rect) {
  clearTimeout(__hideBubbleTimer);
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble) return;

  const term = String(fragment || '').trim();
  if (!term) {
    bubble.style.display = 'none';
    return;
  }

  // Primary: names that include the fragment (case-insensitive)
  const lc = term.toLowerCase();
  const set = new Set();
  let candidates = __clientNames.filter(n => {
    const keep = n.toLowerCase().indexOf(lc) !== -1;
    if (keep) set.add(n);
    return keep;
  });

  // If fewer than 10 and the fragment has multiple words, also expand by each part
  if (candidates.length < 10 && /\s+/.test(term)) {
    const parts = term.split(/\s+/).map(s => s.trim()).filter(s => s.length > 3);
    parts.forEach(function (p) {
      const plc = p.toLowerCase();
      __clientNames.forEach(function (n) {
        if (set.size < 10 && n.toLowerCase().indexOf(plc) !== -1) set.add(n);
      });
    });
    candidates = Array.from(set);
  }

  candidates = candidates.slice(0, 10);

  let html = '<div class="bubble-title">Related to ‚Äú' + escapeHTML(term) + '‚Äù</div>';
  if (!candidates.length) {
    html += '<div class="bubble-item" style="opacity:.7; cursor:default;">No matches</div>';
  } else {
    candidates.forEach(function (name) {
      html += '<div class="bubble-item" data-name="' + escapeHTML(name) + '">' + escapeHTML(name) + '</div>';
    });
  }
  bubble.innerHTML = html;

  // Click on an item loads that client.
  bubble.querySelectorAll('.bubble-item').forEach(function (item) {
    item.addEventListener('click', function (e) {
      e.stopPropagation();
      const nm = item.getAttribute('data-name');
      if (nm && nm !== 'No matches') {
        selectClientFromButton(nm);
        scrollToTop();
      }
      hideNameBubble();
    });
  });

  // Keep bubble alive while hovering it
  bubble.onmouseenter = function () {
    clearTimeout(__hideBubbleTimer);
  };
  bubble.onmouseleave = function () {
    scheduleHideNameBubble();
  };

  bubble.style.display = 'block';
  positionBubbleByRect(rect);
}

// Negative X shifts left; tweak as you like
const NAME_BUBBLE_OFFSETS = {
  rectX: -20,  // when first showing (by rect)
  rectY: 6,
  mouseX: -24, // when following the mouse
  mouseY: 8
};

function positionBubbleByRect(rect) {
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble || !rect) return;

  const padding = 8;
  const x = rect.left + window.scrollX + (NAME_BUBBLE_OFFSETS?.rectX || 0);
  const y = rect.bottom + window.scrollY + (NAME_BUBBLE_OFFSETS?.rectY || 0);

  const maxLeft = window.scrollX + document.documentElement.clientWidth - bubble.offsetWidth - padding;
  const maxTop  = window.scrollY + document.documentElement.clientHeight - bubble.offsetHeight - padding;

  bubble.style.left = Math.max(window.scrollX + padding, Math.min(x, maxLeft)) + 'px';
  bubble.style.top  = Math.max(window.scrollY + padding, Math.min(y, maxTop)) + 'px';
}

function positionBubbleNearMouse(clientX, clientY) {
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble || bubble.style.display !== 'block') return;

  const padding = 8;
  const x = clientX + window.scrollX + (NAME_BUBBLE_OFFSETS?.mouseX || 0);
  const y = clientY + window.scrollY + (NAME_BUBBLE_OFFSETS?.mouseY || 0);

  const maxLeft = window.scrollX + document.documentElement.clientWidth - bubble.offsetWidth - padding;
  const maxTop  = window.scrollY + document.documentElement.clientHeight - bubble.offsetHeight - padding;

  bubble.style.left = Math.max(window.scrollX + padding, Math.min(x, maxLeft)) + 'px';
  bubble.style.top  = Math.max(window.scrollY + padding, Math.min(y, maxTop)) + 'px';
}


function scheduleHideNameBubble() {
  clearTimeout(__hideBubbleTimer);
  __hideBubbleTimer = setTimeout(hideNameBubble, 220);
}

function hideNameBubble() {
  const bubble = document.getElementById('nameHoverBubble');
  if (bubble) bubble.style.display = 'none';
}
/* ===== END NAME LINKIFY + HOVER BUBBLE HELPERS ===== */

/*** DASHBOARD TASKS loader/renderer ***/
function showTasksFromSpreadsheet() {
  var container = document.getElementById('updateTasksContainer');
  var box = document.getElementById('tasksList');
  if (!box) return;

  // make sure it‚Äôs visible
  if (container) container.style.display = 'block';

  box.innerHTML = '<div style="opacity:.7;font-style:italic;">Loading tasks‚Ä¶</div>';

  google.script.run
    .withSuccessHandler(function(rows) {
      renderTasksFromDashboardIntegration(rows);
    })
    .withFailureHandler(function(err) {
      box.innerHTML = '<div style="color:red;">Failed to load tasks: ' +
                      (err && err.message ? err.message : err) + '</div>';
    })
    .getTasksForDashboardIntegration();
}

function renderTasksFromDashboardIntegration(rows) {
  var box = document.getElementById('tasksList');
  if (!box) return;

  if (!rows || !rows.length) {
    box.innerHTML = '<div style="opacity:.7;">No tasks found in Tasks!A2:A.</div>';
    return;
  }

  var html = rows.map(function(t) {
    var txt = (t && t.fullTask) ? String(t.fullTask) : '';
    var row = (t && t.rowIdInTasks) ? t.rowIdInTasks : '';
    return (
      '<div class="task-display" data-row="'+ row +'">' +
        '<div><strong>' + escapeHtmlForTasks(txt) + '</strong></div>' +
        '<div style="margin-top:8px;"><button type="button" onclick="deleteTaskCard('+ row +')">Delete</button></div>' +
      '</div>'
    );
  }).join('');

  box.innerHTML = html;
}

function deleteTaskCard(rowIndex) {
  if (!rowIndex) return;
  if (!confirm('Delete this task (row ' + rowIndex + ')?')) return;

  google.script.run
    .withSuccessHandler(function() {
      showTasksFromSpreadsheet(); // refresh after delete
    })
    .withFailureHandler(function(err) {
      alert('Failed to delete: ' + (err && err.message ? err.message : err));
    })
    .deleteTaskRow(rowIndex);
}

function escapeHtmlForTasks(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}


document.addEventListener('DOMContentLoaded', function() {
    showLoadingBar(); // Show the loading bar
    /***** SNIPPET: IMMEDIATELY SHOW DATE & EMAIL SUMMARY BUTTON *****/
{ 
  // Get today's date in short format
  stampTodayDateTitle();
  fitTopClientsHeaderControls();

  // Force the EMAIL SUMMARY button to be visible immediately
  // (In case any default CSS hides it, this ensures it's displayed.)
document.getElementById('scrollBottomBtn').style.display = 'inline-block';
}
/***** END SNIPPET *****/

    // Hide label controls until a client is selected
    (function(){
      var labelsTopRow = document.querySelector('.labels-top-row');
      var labelsDisplay = document.getElementById('labelsDisplay');
      var labelsAddition = document.getElementById('labelsAdditionSection');
      if (labelsTopRow) labelsTopRow.style.display = 'none';
      if (labelsDisplay) labelsDisplay.style.display = 'none';
      if (labelsAddition) labelsAddition.style.display = 'none';
    })();

    google.script.run.withSuccessHandler(function(data){
      clientsData = data;
      rebuildClientNameIndex();

      populateClientDropdown(clientsData); // Update the dropdown with the client data
      hideLoadingBar(); // Hide the loading bar after populating the dropdown
    }).getAllClientsData();
    google.script.run.withSuccessHandler(populateLabelsDropdown).getAllLabels();
    handleUserSelectionChange();
    updateCategoryLabel(); // Initialize the category label
    displayTable(); // Call displayTable here instead of using window.onload
        google.script.run.withSuccessHandler(function(categories) {
        populateCategoryDropdown(categories);
    }).getUniqueCategories();


  if (typeof fitRecentRowOneLine === 'function') fitRecentRowOneLine();


});

document.addEventListener('DOMContentLoaded', function() {
    adjustBodyMarginTop();
});



window.addEventListener('resize', adjustBodyMarginTop);

function adjustBodyMarginTop() {
    var clientContainer = document.querySelector('.client-container');
    var clientContainerHeight = clientContainer.offsetHeight;
    document.body.style.marginTop = clientContainerHeight + 'px';
}
// === AUTO-SPACING FOR FIXED HEADER (keeps date/labels/buttons visible) ===
// This re-runs the margin-top sizing whenever the blue box height changes.
function ensureHeaderSpacing() {
  // run a few times across the paint cycle to catch async/layout changes
  try {
    adjustBodyMarginTop();
    requestAnimationFrame(adjustBodyMarginTop);
    setTimeout(adjustBodyMarginTop, 0);
  } catch (e) {}
}
/* === RECENT CHIPS: update only when client notes are HIDDEN (cache 4, show up to 3) === */
// Keep an extra slot in memory so we can drop the active client and still show up to 3 recents
var RECENT_CACHE_LIMIT = 4;
window.__recentClients = Array.isArray(window.__recentClients) ? window.__recentClients : []; // most-recent-first, max 4

function getActiveClientName() {
  // Prefer the tracked autocomplete text, then fall back to the select/dropdown
  if (typeof currentClientName !== 'undefined' && currentClientName) {
    return String(currentClientName).trim();
  }

  var select = document.getElementById('clientSelect');
  if (select && select.value) return String(select.value).trim();

  var auto = document.getElementById('clientAutocomplete');
  if (auto && auto.value) return String(auto.value).trim();

  return '';
}

function formatRecentClientName(name) {
  if (!name) return '';

  const cleaned = String(name)
    .replace(/\[.*?\]/g, ' ')
    .replace(/dob[^a-zA-Z]*/gi, ' ');

  const parts = cleaned.match(/[A-Za-z]+/g);
  if (!parts || !parts.length) return '';

  const firstInitial = parts[0] ? parts[0][0].toUpperCase() : '';
  const lastName = parts.length > 1 ? parts[parts.length - 1].toUpperCase() : '';

  return lastName ? `${firstInitial} ${lastName}` : firstInitial;
}

function renderRecentClientsBar(){
  var bar = document.getElementById('recentClientsBar');
  if (!bar) return;

  // Desktop can show up to 3 recents; on narrow/mobile viewports, cap at 2
  var maxRecents = (typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(max-width: 640px)').matches) ? 2 : 3;

  // Enforce the viewport-specific cap at render time as well, excluding the active client
  var active = getActiveClientName();
  var activeNorm = active ? active.toLowerCase() : '';
  var list = (window.__recentClients || []).filter(function(name){
    return !activeNorm || String(name).toLowerCase() !== activeNorm;
  }).slice(0, maxRecents);

  bar.innerHTML = list.map(function(name){
    return '<span class="recent-pill"><span class="rc-name">'+ escapeHTML(formatRecentClientName(name || '')) +'</span></span>';
  }).join('');

  // keep the fixed header spacing correct if anything changes height
  if (typeof ensureHeaderSpacing === 'function') ensureHeaderSpacing();

  // After drawing chips, fit the whole row to one line
  if (typeof fitRecentRowOneLine === 'function') fitRecentRowOneLine();
}

// Repaint the recent chips when the viewport crosses the mobile breakpoint
if (typeof window !== 'undefined' && window.addEventListener) {
  window.addEventListener('resize', renderRecentClientsBar);
}

function updateRecentsOnHide(clientName){
  if (!clientName) return;
  var norm = String(clientName).toLowerCase();

  // remove existing occurrence (de-dupe)
  var arr = (window.__recentClients || []).filter(function(n){
    return String(n).toLowerCase() !== norm;
  });

  // add to the front
  arr.unshift(clientName);

  // cap at cache limit so we can drop the active client and still show 3 recents
  window.__recentClients = arr.slice(0, RECENT_CACHE_LIMIT);

  // persist (merge with current UI state if available)
  try {
    if (typeof saveUIState === 'function') {
      var dd = document.getElementById('topClientsFilterDropdown');
      var clientSel = document.getElementById('clientSelect');
      var state = {
        filter: (dd && dd.value) ? dd.value : '',
        client: (clientSel && clientSel.value) ? clientSel.value : '',
        recents: window.__recentClients
      };
      saveUIState(state);
    } else if (window.localStorage) {
      localStorage.setItem('__ui_recents__', JSON.stringify(window.__recentClients));
    }
  } catch(_) {}

  renderRecentClientsBar();
}

// Optional: restore persisted recents on boot if available (MAX 3)
(function restoreRecentsFromUIState(){
  try {
    if (typeof restoreUIState === 'function') {
      var st = restoreUIState();
      if (st && Array.isArray(st.recents)) {
        window.__recentClients = st.recents.slice(0, RECENT_CACHE_LIMIT);
        renderRecentClientsBar();
        return;
      }
    }
    if (window.localStorage) {
      var raw = localStorage.getItem('__ui_recents__');
      if (raw) {
        var arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          window.__recentClients = arr.slice(0, RECENT_CACHE_LIMIT);
          renderRecentClientsBar();
        }
      }
    }
  } catch(_) {}
})();

/**
 * Shrinks the font-size of the entire recent row (chips + NEW CLIENT button)
 * so that it always fits on a single line inside the blue .client-input-wrap.
 * It uses a binary search between the row's "natural" base font-size and minPx.
 */
function fitRecentRowOneLine() {
  var wrap = document.querySelector('.client-input-wrap');
  var row  = document.getElementById('recentRow');
  if (!wrap || !row) return;

  var csRow = getComputedStyle(row);

  // Remember the natural base font once, so we never "grow" beyond it.
  if (!row.__baseFontPx) {
    row.__baseFontPx = parseFloat(csRow.fontSize) || 16;
  }

  // Available width inside the blue box, minus a small safety padding
  var wrapRect = wrap.getBoundingClientRect();
  var padLeft  = parseFloat(getComputedStyle(wrap).paddingLeft)  || 0;
  var padRight = parseFloat(getComputedStyle(wrap).paddingRight) || 0;
  var available = Math.max(0, wrapRect.width - padLeft - padRight - 2 /*safety*/);

  // Start from the natural base each time we evaluate
  row.style.fontSize = row.__baseFontPx + 'px';

  // Early exit: if it already fits, keep the big size
  if (row.scrollWidth <= available) return;

  var minPx = 6;                  // allow tighter shrink before wrapping
  var lo = minPx, hi = row.__baseFontPx, best = lo;

  // Binary search for the largest font-size that still fits
  while (lo <= hi) {
    var mid = Math.floor((lo + hi) / 2);
    row.style.fontSize = mid + 'px';

    if (row.scrollWidth <= available) {
      best = mid;      // fits ‚Üí try larger
      lo = mid + 1;
    } else {
      hi = mid - 1;    // too wide ‚Üí go smaller
    }
  }

  row.style.fontSize = Math.min(best, row.__baseFontPx) + 'px';
}

// Re-fit on window resize and after first paint
window.addEventListener('resize', fitRecentRowOneLine);
window.addEventListener('load',   fitRecentRowOneLine);

// If the recent bar DOM changes (chips added/removed), re-fit
(function observeRecentBar(){
  var bar = document.getElementById('recentClientsBar');
  if (!bar || !('MutationObserver' in window)) return;
  var mo = new MutationObserver(function(){ requestAnimationFrame(fitRecentRowOneLine); });
  mo.observe(bar, { childList: true, subtree: true, attributes: true });
})();

(function () {
  var header = document.querySelector('.client-container');
  if (!header) return;

  // 1) Watch the header itself for size changes (chips wrapping, etc.)
  if ('ResizeObserver' in window) {
    var ro = new ResizeObserver(ensureHeaderSpacing);
    ro.observe(header);
  }

  // 2) Watch the recent chips container for DOM changes
  var recent = document.getElementById('recentClientsBar');
  if (recent && 'MutationObserver' in window) {
    var mo = new MutationObserver(ensureHeaderSpacing);
    mo.observe(recent, { childList: true, subtree: true, attributes: true });
  }

  // 3) Also bump spacing on key UI interactions that can affect height
  ['input', 'click'].forEach(function (ev) {
    var el = document.getElementById('clientAutocomplete');
    if (el) el.addEventListener(ev, ensureHeaderSpacing, true);
  });

  // 4) Run once after load
  window.addEventListener('load', ensureHeaderSpacing);
})();

// Hide the recent clients/new client bar when scrolling down to maximize space
(function installRecentHideOnScroll(){
  var container = document.querySelector('.client-container');
  var row = document.getElementById('recentRow');
  if (!container || !row) return;

  var lastY = window.scrollY || document.documentElement.scrollTop || 0;
  var ticking = false;

  function applyState(shouldHide){
    var changed = false;
    var suggestionsEl = document.getElementById('autocompleteSuggestions');
    if (shouldHide && !container.classList.contains('hide-recents')) {
      container.classList.add('hide-recents');
      changed = true;
    } else if (!shouldHide && container.classList.contains('hide-recents')) {
      container.classList.remove('hide-recents');
      changed = true;
    }

    if (suggestionsEl) {
      if (shouldHide) {
        suggestionsEl.classList.add('is-contracted');
        suggestionsEl.style.display = 'none';
      } else {
        suggestionsEl.classList.remove('is-contracted');
        suggestionsEl.style.display = '';
      }
    }

    if (changed && typeof ensureHeaderSpacing === 'function') {
      ensureHeaderSpacing();
    }
  }

  function onScrollPosition(y){
    var delta = y - lastY;
    var hide = y > 40 && delta > 3;
    var show = delta < -3 || y <= 10;

    if (hide) applyState(true);
    else if (show) applyState(false);

    lastY = y;
    ticking = false;
  }

  window.addEventListener('scroll', function(){
    var currentY = window.scrollY || document.documentElement.scrollTop || 0;
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(function(){ onScrollPosition(currentY); });
    }
  }, { passive: true });
})();


var currentClientName = '';

var inputElement = document.getElementById('clientAutocomplete');
/* === SNIPPET (REPLACEMENT): balanced show/hide per autocomplete call === */
(function installAutocompleteLoadingWrapper(){
  // We‚Äôll make sure each call to autocompleteClient pairs exactly one show with one hide.
  let tries = 0;
  const maxTries = 50;
  // Track only typing-related shows, so we don‚Äôt interfere with other areas using the bar.
  let typingInFlight = 0;

  const tick = () => {
    tries++;
    const ready = (typeof window.autocompleteClient === 'function') && !window.autocompleteClient.__wrapped;
    if (!ready) {
      if (tries < maxTries) setTimeout(tick, 100);
      return;
    }

    const orig = window.autocompleteClient;

    const wrapped = function wrappedAutocompleteClient(/* ...args */) {
      // Show only once per concurrent invocation
      typingInFlight++;
      try { if (typeof window.showLoadingBar === 'function') window.showLoadingBar(); } catch(_) {}

      try {
        // Run the original (usually synchronous DOM update)
        const result = orig.apply(this, arguments);

        // After the frame paints suggestions, hide for this call
        requestAnimationFrame(() => {
          setTimeout(() => {
            typingInFlight = Math.max(typingInFlight - 1, 0);
            if (typingInFlight === 0) {
              try { if (typeof window.hideLoadingBar === 'function') window.hideLoadingBar(); } catch(_) {}
            }
          }, 0);
        });

        return result;
      } catch (err) {
        // If the original throws, still balance the count
        typingInFlight = Math.max(typingInFlight - 1, 0);
        if (typingInFlight === 0) {
          try { if (typeof window.hideLoadingBar === 'function') window.hideLoadingBar(); } catch(_) {}
        }
        throw err;
      }
    };

    wrapped.__wrapped = true;
    window.autocompleteClient = wrapped;

    // IMPORTANT: we intentionally DO NOT add any extra `input` listener that calls showLoadingBar().
    // The wrapper handles showing/hiding per call, so refCounts stay balanced.
  };

  tick();
})();


/* === WIRING: run fit after suggestions render & after a client loads into the input === */

/* 1) When autocomplete suggestions are (re)painted, re-fit each row */
(function observeSuggestionList(){
  const box = document.getElementById('autocompleteSuggestions');
  if (!box || !('MutationObserver' in window)) return;

  const mo = new MutationObserver(function(){
    // Whenever innerHTML changes (new suggestions), fit rows on next frame
    requestAnimationFrame(fitAllSuggestionRows);
  });
  mo.observe(box, { childList: true, subtree: false });
})();

/* 2) Whenever the input value changes (typing or programmatic), re-fit it */
(function wireInputRefitter(){
  const input = document.getElementById('clientAutocomplete');
  if (!input) return;

  // User typing
  input.addEventListener('input', function(){
    requestAnimationFrame(fitClientInputNow);
  });

  window.addEventListener('resize', function(){
    requestAnimationFrame(fitClientInputNow);
  });

  // Programmatic changes (e.g., when a client is loaded into the input)
  // Wrap showClientNotes to run the fitter after it sets the input value.
  (function wrapShowClientNotesOnce(){
    if (typeof window.showClientNotes !== 'function' || window.showClientNotes.__wrappedForFit) return;
    const orig = window.showClientNotes;
    window.showClientNotes = function wrappedShowClientNotes(){
      const out = orig.apply(this, arguments);
      // After the UI updates, fit the input text
      requestAnimationFrame(fitClientInputNow);
      return out;
    };
    window.showClientNotes.__wrappedForFit = true;
  })();

   // Guarantee any direct `.value = ...` assignments also trigger a refit.
  (function wrapValueSetter(){
    if (input.__fitValueWrapped) return;
    const proto = Object.getPrototypeOf(input);
    const desc = proto && Object.getOwnPropertyDescriptor(proto, 'value');
    if (!desc || typeof desc.get !== 'function' || typeof desc.set !== 'function') return;

    Object.defineProperty(input, 'value', {
      configurable: true,
      enumerable: desc.enumerable,
      get: function(){
        return desc.get.call(this);
      },
      set: function(v){
        desc.set.call(this, v);
        requestAnimationFrame(fitClientInputNow);
      }
    });

    Object.defineProperty(input, '__fitValueWrapped', {
      value: true,
      configurable: true,
      writable: false,
      enumerable: false
    });
  })();

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', function(){
      requestAnimationFrame(fitClientInputNow);
    });
  }


  // Also fit immediately on first load (in case a value is prefilled)
  requestAnimationFrame(fitClientInputNow);
})();

/* 3) When suggestions first appear due to typing, make sure they fit too */
document.addEventListener('DOMContentLoaded', function(){
  // If your autocomplete fills #autocompleteSuggestions synchronously,
  // this ensures a first-fit if it was pre-rendered.
  fitAllSuggestionRows();
});


inputElement.addEventListener('click', function() {
    if (inputElement.value === currentClientName) {
        inputElement.style.color = 'lightgray'; // Set text color to gray when clicked
    }
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
        hideClientNotes(); // Call the function when the input is clicked into

});

inputElement.addEventListener('input', function() {
    if (inputElement.value !== currentClientName) {
        inputElement.style.color = 'black'; // Set text color to black when typing new text
    }
});

inputElement.addEventListener('blur', function() {
    if (inputElement.value === '') {
        inputElement.value = currentClientName;
        inputElement.style.color = 'black'; // Restore text color to black
    }
});

var suggestions = null;

// Add the click event listener here
inputElement.addEventListener('click', function() {
    inputElement.value = ''; // Clear the input field
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
});

inputElement.addEventListener('keydown', function(e) {
    if (!suggestions) return; // No suggestions to navigate

    var currentFocus = suggestions.querySelector('.autocomplete-active');
    if (e.key === "ArrowDown") {
        // Handle down arrow key
        if (currentFocus) {
            if (currentFocus === suggestions.lastChild) {
                // Move cursor to the left of the first character in the textarea
                inputElement.focus();
                inputElement.selectionStart = 0;
                inputElement.selectionEnd = 0;
                currentFocus.classList.remove('autocomplete-active');
            } else {
                // Move to next suggestion
                currentFocus.classList.remove('autocomplete-active');
                var next = currentFocus.nextElementSibling;
                if (next) {
                    next.classList.add('autocomplete-active');
                    next.scrollIntoView({ block: 'nearest' });
                }
            }
        } else {
            // No option is highlighted, cursor is in the textarea
            if (document.activeElement === inputElement) {
                // Highlight first suggestion
                if (suggestions.firstChild) {
                    suggestions.firstChild.classList.add('autocomplete-active');
                    suggestions.firstChild.scrollIntoView({ block: 'nearest' });
                }
            }
        }
        e.preventDefault();
    } else if (e.key === "ArrowUp") {
        // Handle up arrow key
        if (currentFocus) {
            if (currentFocus === suggestions.firstChild) {
                // Move cursor to the left of the first character in the textarea
                inputElement.focus();
                inputElement.selectionStart = 0;
                inputElement.selectionEnd = 0;
                currentFocus.classList.remove('autocomplete-active');
            } else {
                // Move to previous suggestion
                currentFocus.classList.remove('autocomplete-active');
                var prev = currentFocus.previousElementSibling;
                if (prev) {
                    prev.classList.add('autocomplete-active');
                    prev.scrollIntoView({ block: 'nearest' });
                }
            }
        } else {
            // No option is highlighted, cursor is in the textarea
            if (document.activeElement === inputElement) {
                // Highlight last suggestion
                if (suggestions.lastChild) {
                    suggestions.lastChild.classList.add('autocomplete-active');
                    suggestions.lastChild.scrollIntoView({ block: 'nearest' });
                }
            }
        }
        e.preventDefault();
    } else if (e.key === "Enter") {
        // Handle enter key
        e.preventDefault();
        if (currentFocus) {
            currentFocus.click();
        }
    }
});







function selectButton(buttonId, selectedColor, clientFilter) {
  // Reset all button colors
  document.getElementById('immediateBtn').style.backgroundColor = '#FFCCCC';
  document.getElementById('pendingBtn').style.backgroundColor = '#FFFFCC';
  document.getElementById('deferredBtn').style.backgroundColor = '#FFD9B3';
  document.getElementById('adjustableBtn').style.backgroundColor = '#ADD8E6';

  // Highlight selected
  document.getElementById(buttonId).style.backgroundColor = selectedColor;

  // If these buttons are meant to scope a different panel, call that logic here.
  // Do NOT touch the Top Clients filter list directly; it‚Äôs driven only by the dropdown.
}


document.addEventListener('DOMContentLoaded', function fastFirstPaint() {
  // Ensure a default in the dropdown, then reuse the canonical fetch+render
  var dd = document.getElementById('topClientsFilterDropdown');
  if (dd && !dd.value) dd.value = 'JB';

  // Wire the change handler immediately so user changes take effect
  initTopClientsFilterAfterList();

  // First paint goes through the same code path as every other repaint
  fetchAndRenderTopClientsFromDropdown();
});


// === PATCH 2: Auto-rewire textareas after any Top Clients re-render ===
(function () {
  var root = document.getElementById('topClientsDisplay');
  if (!root || !('MutationObserver' in window)) return;

  var rewire = function () {
    if (typeof wireToplistSuggestionTextareas === 'function') {
      wireToplistSuggestionTextareas();
    }
    // also fix bulbs after any DOM change
    sanitizeSuggestionBulbs();
  };

  // Run once now
  rewire();

  // On any child change, rewire + sanitize
  var mo = new MutationObserver(function () { rewire(); });
  mo.observe(root, { childList: true, subtree: true });
})();




/* PASTE #3 ‚Äî ignore clicks inside suggestion blocks */
document.addEventListener('DOMContentLoaded', function () {
  var wrap = document.getElementById('topClientsDisplay');

// === PATCH 3: Harden click guard inside Top Clients list ===
(function () {
  var wrap = document.getElementById('topClientsDisplay');
  if (!wrap) return;

  // Capture phase to stop *before* row handlers see the event.
  wrap.addEventListener('mousedown', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);

  wrap.addEventListener('click', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);

  wrap.addEventListener('focusin', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);
})();



  if (!wrap) return;
  wrap.addEventListener('click', function(e){
    if (e.target.closest('.toplist-suggestion')) {
      // Don‚Äôt let row/card click handlers do anything while editing the textarea
      e.stopPropagation();
      return;
    }
  }, true);
});

window.addEventListener('load', function(){
  // Next tick: restore prior state, then ensure list matches dropdown
  setTimeout(function(){
    if (typeof restoreUIState === 'function') restoreUIState();
    syncClientsListToDropdown();
  }, 0);
});


function initTopClientsFilterAfterList(){
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  if (!dd._wired) {
    dd.addEventListener('change', function(){
      // Single source of truth: always go through syncClientsListToDropdown
      syncClientsListToDropdown();
    });
    dd._wired = true;
  }
}







   document.getElementById('loadNotesButton').addEventListener('click', function() {
        google.script.run.withSuccessHandler(displayTodayNotes).getTodayNotes();
      });

    // Load the Visualization API and the corechart package.
    google.charts.load('current', {packages: ['corechart']});

    // Set a callback to run when the Google Visualization API is loaded.
    google.charts.setOnLoadCallback(getAndDrawHeatmapData);
        google.charts.setOnLoadCallback(drawScatterPlot);


    // ... rest of your JavaScript functions ...





      // Populate client dropdown
function populateClientDropdown(clients) {
    var clientSelect = document.getElementById('clientSelect');
    clientSelect.innerHTML = ''; // Clear existing options first

    // Add a blank default option
    var defaultOption = document.createElement('option');
    defaultOption.textContent = 'Select a Client'; // Text for the placeholder option
    defaultOption.value = ''; // No value for the placeholder option
    defaultOption.disabled = true; // Make the placeholder option disabled
    defaultOption.selected = true; // Make the placeholder option selected by default
    clientSelect.appendChild(defaultOption);

    // Add the client options
    clients.forEach(function(client) {
        var option = document.createElement('option');
        option.value = client.clientName;
        option.textContent = client.clientName + (client.category ? ' (' + client.category + ')' : '');
        clientSelect.appendChild(option);
    });
    hideLoadingBar(); // Hide the loading bar after populating the dropdown
}

// Event listener for STRICT/FLEXIBLE dropdown (guarded)
(function() {
  var el = document.getElementById('columnBDropdown');
  if (!el) return;
  el.addEventListener('change', function() {
    showLoadingBar();
    updateSettings(this.value).then(() => {
      hideLoadingBar();
    }).catch((error) => {
      console.error("Failed to update settings: ", error);
      hideLoadingBar();
    });
  });
})();

// Event listener for day of the week dropdown (guarded)
(function() {
  var el = document.getElementById('columnDDropdown');
  if (!el) return;
  el.addEventListener('change', function() {
    showLoadingBar();
    updateDaySettings(this.value).then(() => {
      hideLoadingBar();
    }).catch((error) => {
      console.error("Failed to update day settings: ", error);
      hideLoadingBar();
    });
  });
})();


function updateSettings(value) {
    // Replace with actual code to handle the change in settings
    return new Promise((resolve, reject) => {
        // Simulate asynchronous operation with setTimeout
        setTimeout(() => {
            resolve();
        }, 1000); // Simulate a delay of 1 second
    });
}

function updateDaySettings(value) {
    // Replace with actual code to handle the change in day settings
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, 1000); // Simulate a delay of 1 second
    });
}


function showClientNotes() {
    var clientName = document.getElementById('clientSelect').value;
    // NOTE: recent chips no longer update here (only on hide).
    var clientSelect = document.getElementById('clientSelect');
    var clientAutocomplete = document.getElementById('clientAutocomplete');
    // SNIPPET: CLEAR LOADED IN-PROGRESS AREA

    // So we don't see old text while the new client data is loading
    document.getElementById('loadedInProgressArea').value = '';

    // Set the autocomplete value based on the dropdown selection
    clientAutocomplete.value = clientName ? clientSelect.options[clientSelect.selectedIndex].text : '';

    if (clientName) {
        clientAutocomplete.style.color = 'black'; // Set text color to black when client is loaded
        currentClientName = clientAutocomplete.value; // Store the current client name

        // Log the open client so the recent buttons stay populated on first load
        if (typeof onClientOpened === 'function') {
            onClientOpened(clientName);
        }
    } else {
        clientAutocomplete.style.color = ''; // Default color
        currentClientName = '';
    }
// Reset values and set displays based on selection
document.getElementById('newPastWork').value = '';
document.getElementById('categorySelect').value = '';
setCategoryPlaceholderText('');
hideCategoryOverlay();

var displayStyle = clientName ? 'block' : 'none';

// Only show the labels row and label list when a client is loaded
var labelsTopRow = document.querySelector('.labels-top-row');
if (labelsTopRow) {
  labelsTopRow.style.display = clientName ? '' : 'none';
}
var labelsDisplayEl = document.getElementById('labelsDisplay');
if (labelsDisplayEl) {
  labelsDisplayEl.style.display = clientName ? '' : 'none';
}

// Show only the Past Work section (Future Work is deprecated)
document.getElementById('workSectionsContainer').style.display = clientName ? 'flex' : 'none';
document.getElementById('pastWorkSection').style.display = displayStyle;

// Hide deprecated Future Work UI if it still exists (safety)
var fw = document.getElementById('futureWorkSection');
if (fw) fw.style.display = 'none';

// Keep the rest of the UI behavior unchanged
document.getElementById('categoryChangeSection').style.display = displayStyle;
var appointmentBtn = document.getElementById('addAppointmentBtn');
if (appointmentBtn) {
  appointmentBtn.style.display = displayStyle;
}
document.getElementById('labelsAdditionSection').style.display = displayStyle;
var hideClientNotesBtn = document.getElementById('hideClientNotesBtn');
if (hideClientNotesBtn) {
  hideClientNotesBtn.style.display = 'none';
}
document.getElementById('notesDisplay').style.display = 'block';


    updateCategoryLabel();

    // **Show loading bar before starting asynchronous operations**
    showLoadingBar();

    // **Create a counter for pending async operations**
    var pendingOps = 2;

    // Start asynchronous operation to populate labels dropdown
    google.script.run.withSuccessHandler(function(labels) {
        populateLabelsDropdown(labels);
        pendingOps--;
        if (pendingOps === 0) {
            hideLoadingBar();
        }
    }).getAllLabels();

    // Fetch client details and handle them with a success handler
    google.script.run.withSuccessHandler(function(data) {
        // After successful fetch, set up the dropdowns and display data
     // After successful fetch, set up the dropdowns and display data
setupColumnDropdowns(data);

// ‚≠ê Set chip cache FIRST (so displayNotes sees it)
window.__chipForCurrentClient = {
  initials: (data.chipInitials || "").toUpperCase(),
  date: data.chipDate || ""   // already MM/DD/YY per our server plan
};

displayClientDetails(data);

// Update the category select value based on fetched client data
updateCategorySelectValue(data.category);
setCategoryPlaceholderText(data.category || __currentCategory || '');
positionCategoryDropdownOverAutocomplete();

        pendingOps--;
        if (pendingOps === 0) {
            hideLoadingBar();
        }
    }).getClientDetails(clientName);

    // Persist "which client is open" along with current filter
saveUIState({
  filter: (document.getElementById('topClientsFilterDropdown')||{}).value || '',
  client: (document.getElementById('clientSelect')||{}).value || ''
});

}


var inputElement = document.getElementById('clientAutocomplete');
var suggestions = null;

// Clear the input and reset text color when clicked
inputElement.addEventListener('click', function() {
    inputElement.value = ''; // Clear the input field
    inputElement.style.color = ''; // Reset color to default
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
    hideCategoryOverlay();
});

// Reset text color when the user types
inputElement.addEventListener('input', function() {
    inputElement.style.color = ''; // Reset color to default
    hideCategoryOverlay();
});

window.addEventListener('resize', positionCategoryDropdownOverAutocomplete);

function setupColumnDropdowns(data) {
    setupColumnBDropdown(data);
    setupColumnDDropdown(data);
}

function normalizeTopClientsFilter(val) {
  const raw = (val || '').toString().trim();
  // Map emojis/aliases to canonical keys your renderer understands
  const map = {
    'JB':'JB', 'RB':'RB', 'QC':'QC', 'TEAM':'TEAM', 'BDAY':'BDAY',
    'üíº':'BRIEFCASE', '‚≠ê':'STAR', 'üéì':'GRADCAP', 'üìû':'PHONE'
  };
  return map.hasOwnProperty(raw) ? map[raw] : raw.toUpperCase();
}

// === CATEGORY CHANGE GUARDS ===
let __suppressCategoryChange = false;     // don't fire when we set value in code
let __categoryReqToken = 0;               // ignore stale success/failure
let __categoryInFlight = false;           // optional: disable UI while saving
let __currentCategory = '';               // last category we know is applied

function wireCategorySelectChange(){
  const sel = document.getElementById('categorySelect');
  if (!sel || sel.__wired) return;

  sel.addEventListener('change', function(){
    if (__suppressCategoryChange) return;               // ignore programmatic set
    const newCat = (sel.value || '').trim();
    // Dedupe: don't call server if the value didn't actually change
    if (newCat === (__currentCategory || '')) return;
    setCategoryPlaceholderText(newCat || '');
    positionCategoryDropdownOverAutocomplete();
    requestCategoryChange(newCat);
  });

  sel.__wired = true;
}

/* Call this to programmatically set the dropdown value WITHOUT triggering save */
function updateCategorySelectValue(newValue){
  const sel = document.getElementById('categorySelect');
  if (!sel) return;
  __suppressCategoryChange = true;
  sel.value = (newValue || '');
  __currentCategory = (newValue || '');  // keep our local notion in sync
  setCategoryPlaceholderText(__currentCategory || '');
  positionCategoryDropdownOverAutocomplete();
  // release on next tick so real user changes still work
  setTimeout(() => { __suppressCategoryChange = false; }, 0);
}

/* Single, tokened pipeline to update category on the server */
function requestCategoryChange(newCategory){
  const clientName = (document.getElementById('clientSelect')||{}).value || '';
  if (!clientName || !newCategory) return;

  const token = ++__categoryReqToken;
  __categoryInFlight = true;
  try { if (typeof showLoadingBar === 'function') showLoadingBar(); } catch(_){}

  google.script.run
    .withSuccessHandler(function(){
      // Only act if this is the latest request
      if (token !== __categoryReqToken) return;
      __currentCategory = newCategory;                       // lock in
      __categoryInFlight = false;
      setCategoryPlaceholderText(__currentCategory || '');
      positionCategoryDropdownOverAutocomplete();
      try { if (typeof hideLoadingBar === 'function') hideLoadingBar(); } catch(_){}
      // Optional toast near the select
      try {
        const sel = document.getElementById('categorySelect');
        if (sel) {
          const ok = document.createElement('span');
          ok.textContent = 'Saved';
          ok.style.marginLeft = '8px';
          ok.style.fontSize = '0.8em';
          ok.style.opacity = '0.85';
          ok.style.background = '#e8f5e9';
          ok.style.border = '1px solid #c8e6c9';
          ok.style.borderRadius = '10px';
          ok.style.padding = '2px 8px';
          sel.parentNode.appendChild(ok);
          setTimeout(() => ok.remove(), 1200);
        }
      } catch(_){}
    })
    .withFailureHandler(function(err){
      // Ignore failures from stale requests
      if (token !== __categoryReqToken) return;
      __categoryInFlight = false;
      try { if (typeof hideLoadingBar === 'function') hideLoadingBar(); } catch(_){}
      alert('Category change failed: ' + (err && err.message ? err.message : err));
      // Revert UI to the last known good category
      updateCategorySelectValue(__currentCategory);
    })
    // TODO: replace with your server function name/signature
    .updateClientCategory(clientName, newCategory);
}


/* === HELPER: repaint Top Clients using the CURRENT dropdown filter === */
function repaintTopClientsWithCurrentFilter(clients) {
  // Read the dropdown safely
  var dd = document.getElementById('topClientsFilterDropdown');
  var raw = (dd && dd.value) ? dd.value : 'JB';
  var currentFilter = normalizeTopClientsFilter(raw);

  // Use your standard renderer, passing the filter explicitly
  if (typeof showTopClients === 'function') {
    showTopClients(clients, currentFilter);
  } else if (typeof showTopClientsOnLoad === 'function') {
    showTopClientsOnLoad(clients, currentFilter);
  }

  // Re-wire suggestion textareas + keep visibility state
  if (typeof wireToplistSuggestionTextareas === 'function') wireToplistSuggestionTextareas();
  if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
}


function setupColumnBDropdown(data) {
  var columnBDropdown = document.getElementById('columnBDropdown');
  if (!columnBDropdown) return; // Future Work UI removed
  columnBDropdown.innerHTML = '';
  var blankOption = document.createElement('option');
  blankOption.value = "";
  columnBDropdown.appendChild(blankOption);
  ['STRICT', 'FLEXIBLE'].forEach(function(optionValue) {
    var option = document.createElement('option');
    option.value = optionValue;
    option.text = optionValue;
    columnBDropdown.appendChild(option);
  });
  columnBDropdown.value = data.columnB || "";
}


function setupColumnDDropdown(data) {
  var columnDDropdown = document.getElementById('columnDDropdown');
  if (!columnDDropdown) return; // Future Work UI removed
  columnDDropdown.innerHTML = '';
  ['','Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'].forEach(function(day) {
    var option = document.createElement('option');
    option.value = day;
    option.text = day;
    columnDDropdown.appendChild(option);
  });
  columnDDropdown.value = data.columnD || "";
}

function displayClientDetails(data) {
    var labelsDisplay = document.getElementById('labelsDisplay');
    labelsDisplay.innerHTML = '';
    if (data.notes) {
        displayNotes(data.notes);
    }
displayLabels(Array.isArray(data.labels) ? data.labels : []);

// SNIPPET #4: Ensure the loaded "In Progress:" is set from data.columnL
// Seed the In Progress textarea and remember the last-saved value
var loadedInProgressArea = document.getElementById('loadedInProgressArea');
var selectedClientName = '';
var clientSelectEl = document.getElementById('clientSelect');
if (clientSelectEl && clientSelectEl.value) {
  selectedClientName = clientSelectEl.value;
} else if (data && data.notes && data.notes.length && data.notes[0].clientName) {
  selectedClientName = data.notes[0].clientName;
}
if (selectedClientName) {
  loadedInProgressArea.setAttribute('data-client', selectedClientName);
} else {
  loadedInProgressArea.removeAttribute('data-client');
}
loadedInProgressArea.classList.add('inProgressArea');
var seed = data.columnL || '';
loadedInProgressArea.value = seed;
loadedInProgressArea.setAttribute('data-last-saved', seed);

// Prevent clicks/focus from bubbling and triggering any container logic
['mousedown','click','focus','keydown'].forEach(function(ev){
  loadedInProgressArea.addEventListener(ev, function(e){
    // Ctrl/Cmd+Enter commits quickly
    if ((ev === 'keydown') && ((e.ctrlKey || e.metaKey) && e.key === 'Enter')) {
      e.preventDefault();
      loadedInProgressArea.blur(); // triggers save
      return;
    }
    e.stopPropagation();
  }, true);
});

loadedInProgressArea.value = seed;
loadedInProgressArea.setAttribute('data-last-saved', seed);

// Prevent clicks/focus from bubbling and triggering any container logic
['mousedown','click','focus','keydown'].forEach(function(ev){
  loadedInProgressArea.addEventListener(ev, function(e){
    // Allow Ctrl/Cmd+Enter to commit quickly
    if ((ev === 'keydown') && ((e.ctrlKey || e.metaKey) && e.key === 'Enter')) {
      e.preventDefault();
      loadedInProgressArea.blur(); // triggers safe save
      return;
    }
    e.stopPropagation();
  }, true);
});
// === Paste this as the LAST line inside your "client notes are ready" function ===
loadCategoriesForClientAfterNotes();


}




function labelContainsEmoji(labelText) {
    if (!labelText) return false;
    return /[\p{Extended_Pictographic}]/u.test(labelText);
}



function displayLabels(labelsArray) {
    var labelsDisplay = document.getElementById('labelsDisplay');
    labelsDisplay.innerHTML = '';

    // Reuse the dropdown as an inline label-like control at the end of the list
    var addLabelDropdown = document.getElementById('labelsDropdown');
    if (addLabelDropdown) {
        addLabelDropdown.classList.add('label-box', 'add-label-dropdown');
        addLabelDropdown.selectedIndex = 0; // Keep placeholder visible after refresh
    }
    
    var emojiLabels = [];
    var nonEmojiLabels = [];


    labelsArray.forEach(function(labelObj) {
              if (labelContainsEmoji(labelObj.label)) {
            emojiLabels.push(labelObj);
        } else {
            nonEmojiLabels.push(labelObj);
        }
    });

    var orderedLabels = emojiLabels.concat(nonEmojiLabels);

    orderedLabels.forEach(function(labelObj) {
        var labelDiv = document.createElement('div');
        labelDiv.className = 'label-box';
        labelDiv.textContent = labelObj.label;

        // Apply light blue background and black text to labels from columns H-K
        if (labelObj.isBlue) {
            labelDiv.style.backgroundColor = 'lightblue';
            labelDiv.style.color = 'black';
        } else {
            // Set the background to light green for labels that are not light blue
            labelDiv.style.backgroundColor = 'lightgreen';

            // Only add onclick event if the background is not blue
            labelDiv.onclick = function() {
                confirmAndRemoveLabel(labelObj.label);
            };
        }

        labelsDisplay.appendChild(labelDiv);
    });

    if (addLabelDropdown) {
        labelsDisplay.appendChild(addLabelDropdown);
    }
}






function confirmAndRemoveLabel(label) {
    var clientName = document.getElementById('clientSelect').value;
    if (confirm('Are you sure you want to remove the label "' + label + '" from ' + clientName + '?')) {
        google.script.run.withSuccessHandler(function() {
            alert('Label removed successfully!');
            showClientNotes(); // Assuming this function refreshes client details
        }).withFailureHandler(function(error) {
            alert('Error removing label: ' + error.message);
        }).removeLabelFromClient(clientName, label);
    }
}

function openNewCategoryModal() {
  var m = document.getElementById('newCategoryModal');
  if (m) {
    document.getElementById('newCategoryInput').value = '';
    m.style.display = 'block';
  }
}

function closeNewCategoryModal() {
  var m = document.getElementById('newCategoryModal');
  if (m) m.style.display = 'none';
}

// When user confirms a new category: set dropdown to it and persist via updateCategory()
function confirmNewCategory() {
  var input = document.getElementById('newCategoryInput');
  var name = (input ? String(input.value || '').trim() : '');
  if (!name) {
    alert('Please type a category name.');
    return;
  }

  // Set the dropdown to the new value, close modal, then save
  var sel = document.getElementById('categorySelect');
  closeNewCategoryModal();

  // Add it to the dropdown immediately for this session
  // (it will be truly "permanent" after we save it to the client and re-pull unique categories)
  if (sel) {
    var exists = Array.from(sel.options).some(function(opt){ return opt.value.toLowerCase() === name.toLowerCase(); });
    if (!exists) {
      var opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      // insert alphabetically before the sentinel NEW CATEGORY‚Ä¶
      var inserted = false;
      for (var i = 0; i < sel.options.length; i++) {
        var o = sel.options[i];
        if (o.value && o.value !== '__NEW__' && o.value.localeCompare(name, 'en', {sensitivity:'base'}) > 0) {
          sel.add(opt, o);
          inserted = true;
          break;
        }
      }
      if (!inserted) sel.add(opt, sel.querySelector('option[value="__NEW__"]') || null);
    }
    sel.value = name;
  }

  // Persist: assign this new category to the currently loaded client
  // Your existing updateCategory() reads #categorySelect and #clientSelect
  updateCategory();
  updateCategoryLabel();

  // Refresh master list so the new category appears next time (pulls Column F uniques)
  google.script.run
    .withSuccessHandler(function(categories){
      populateCategoryDropdown(categories);
      // keep the just-saved value selected
      var sel2 = document.getElementById('categorySelect');
      if (sel2) sel2.value = name;
    })
    .getUniqueCategories();
}

/* Save the selected dropdown category to Column F for the currently loaded client. */
function updateCategory() {
  var clientSel = document.getElementById('clientSelect');
  var catSel    = document.getElementById('categorySelect');
  if (!clientSel || !catSel) return;

  var clientName = String(clientSel.value || '').trim();
  var category   = String(catSel.value || '').trim();

  if (!clientName) {
    alert('Please select a client first.');
    return;
  }
  if (!category) {
    alert('Please pick a category.');
    return;
  }

  // Visual feedback (optional)
  if (typeof showLoadingBar === 'function') showLoadingBar();

google.script.run
  .withSuccessHandler(function(res){
    if (typeof hideLoadingBar === 'function') hideLoadingBar();

    if (typeof updateCategoryLabel === 'function') updateCategoryLabel();

    // ‚¨áÔ∏è re-run the Top Clients filter now
    retriggerTopClientsFilter();

    google.script.run
      .withSuccessHandler(function(categories){
        if (typeof populateCategoryDropdown === 'function') {
          populateCategoryDropdown(categories);
          var sel = document.getElementById('categorySelect');
          if (sel) sel.value = category;
        }
      })
      .getUniqueCategories();

          // Refresh the autocomplete + dropdown data so the updated category appears immediately.
    if (typeof refreshUIWithNewCategory === 'function') {
      refreshUIWithNewCategory(clientName, category);
    }
  })

    .withFailureHandler(function(err){
      if (typeof hideLoadingBar === 'function') hideLoadingBar();
      alert('Failed to save category: ' + (err && err.message ? err.message : err));
    })
    .updateClientCategory(clientName, category);
}



function loadCategoriesForClientAfterNotes() {
  // Ensure the select exists (it's okay if the section is hidden at first)
  var sel = document.getElementById('categorySelect');
  if (!sel) {
    console.warn('loadCategoriesForClientAfterNotes: #categorySelect not found in DOM yet.');
    return;
  }

  if (!(window.google && google.script && google.script.run)) {
    console.error('google.script.run is not available yet.');
    return;
  }

  google.script.run
    .withSuccessHandler(function (cats) {
      // Populate the dropdown, but DO NOT unhide the section here.
      // Visibility is controlled strictly by showClientNotes() when a client is loaded.
      populateCategoryDropdown(Array.isArray(cats) ? cats : []);
      // Intentionally do NOT do:
      //   document.getElementById('categoryChangeSection').style.display = 'block';
    })
    .withFailureHandler(function (err) {
      console.error('Failed to load categories:', err);
    })
    .getUniqueCategories();
}


function updateCategorySelectValue(currentCategory) {
  var sel = document.getElementById('categorySelect');
  if (!sel) return;

  if (currentCategory) {
    // If the current category isn't yet in the dropdown (e.g., just created),
    // temporarily insert it before the sentinel so it's selectable.
    var exists = Array.from(sel.options)
      .some(function (o) { return o.value.toLowerCase() === String(currentCategory).toLowerCase(); });

    if (!exists) {
      var opt = document.createElement('option');
      opt.value = currentCategory;
      opt.textContent = currentCategory;
      var sentinel = sel.querySelector('option[value="__NEW__"]');
      sel.add(opt, sentinel); // insert before NEW CATEGORY‚Ä¶
    }
  }
  sel.value = currentCategory || '';
}

function sanitizeSuggestionBulbs() {
  document.querySelectorAll('.toplist-suggestion').forEach(card => {
    // 1) Ensure there is exactly one .bulb element as the first child
    let bulbs = Array.from(card.querySelectorAll('.bulb'));
    if (bulbs.length === 0) {
      const span = document.createElement('span');
      span.className = 'bulb';
      span.setAttribute('aria-hidden', 'true');
      span.textContent = 'üí°';
      card.insertBefore(span, card.firstChild);
    } else {
      // keep the first; remove any extras
      bulbs.slice(1).forEach(b => b.remove());
      // move the first to the front if it isn't already
      if (card.firstElementChild !== bulbs[0]) {
        card.insertBefore(bulbs[0], card.firstChild);
      }
    }

    // 2) If some renderer dropped raw ‚Äúüí°‚Äù text nodes, remove those
    Array.from(card.childNodes).forEach(n => {
      if (n.nodeType === Node.TEXT_NODE && n.nodeValue && n.nodeValue.trim() === 'üí°') {
        n.parentNode.removeChild(n);
      }
    });
  });
}

       // Helper function to create a regex pattern for different date formats
function createDatePattern(date) {
    let day = ('0' + date.getDate()).slice(-2);
    let month = ('0' + (date.getMonth() + 1)).slice(-2);
    let year2d = date.getFullYear().toString().substr(-2);
    let year4d = date.getFullYear().toString();

    // Patterns for different date formats
    let patterns = [
        `${month}/${day}/${year2d}`, // MM/DD/YY
        `${month}/${day}/${year4d}`, // MM/DD/YYYY
        `${parseInt(month)}/${day}/${year2d}`, // M/DD/YY
        `${parseInt(month)}/${day}/${year4d}`, // M/DD/YYYY
        `${month}/${parseInt(day)}/${year2d}`, // MM/D/YY
        `${month}/${parseInt(day)}/${year4d}`, // MM/D/YYYY
        `${parseInt(month)}/${parseInt(day)}/${year2d}`, // M/D/YY
        `${parseInt(month)}/${parseInt(day)}/${year4d}`  // M/D/YYYY
    ];

    // Combine into a single regex pattern
    return new RegExp(patterns.join('|'), 'g');
}
// Global variable to track the visibility state
var notesExpanded = false;


/***************************************
PASTE THIS ENTIRE BLOCK
***************************************/
/***************************************
REPLACE ENTIRE toggleNotesVisibility FUNCTION WITH THIS
***************************************/
/***************************************
REPLACE ENTIRE toggleNotesVisibility FUNCTION WITH THIS
***************************************/
function toggleNotesVisibility() {
  // Capture previous state before toggling visibility
  var wasExpanded = !!notesExpanded;

  // Flip the global boolean
  notesExpanded = !notesExpanded;

  // Only toggle within the UNHIGHLIGHTED section
  var container = document.getElementById('unhighlightedNotes');
  if (!container) return;

  var olderNotes = container.querySelectorAll('.older-note');
  olderNotes.forEach(function(line) {
    line.style.display = notesExpanded ? 'block' : 'none';
  });

  var toggleButton = document.getElementById('toggleNotesButton');
  if (toggleButton) {
    // Update accessibility label to reflect state without visible symbols
    toggleButton.setAttribute('aria-pressed', notesExpanded ? 'true' : 'false');
    toggleButton.setAttribute('aria-label', notesExpanded ? 'Hide older notes' : 'Show older notes');
  }

  // If the user collapses the block (was expanded ‚Üí now collapsed), scroll to the top.
  if (wasExpanded && !notesExpanded) {
    // Use the global helper (defined below). If you have your own scrollToTop already, this will call it.
    scrollToTop();
  }
}
/***************************************
END REPLACEMENT
***************************************/


/***************************************
END OF PASTE
***************************************/
<!-- Example of where to paste in your .html or .gs file -->



// === GROUP & NORMALIZE NOTE LINES INTO DATED BLOCKS ===
// Each block has { date: Date|null, lines: string[] }.
// - A line with a date starts a new block.
// - Undated lines "inherit" the most recent block's date.
// - 2+ blank lines are collapsed to a single "" entry (one visual <br>).
function groupLinesIntoBlocks(allLines) {
  const blocks = [];
  let current = null;
  let pendingBlank = false;

  function pushCurrent() {
    if (current && current.lines.length) blocks.push(current);
    current = null;
    pendingBlank = false;
  }

  for (let raw of allLines) {
    const line = String(raw || "").replace(/\s+$/, ""); // trim right side; keep left spaces if user typed them
    const hasDate = !!extractDateFromLine(line);

    if (hasDate) {
      // New dated block
      pushCurrent();
      current = { date: extractDateFromLine(line), lines: [line] };
      pendingBlank = false;
      continue;
    }

    // Undated line
    // If no current block, start a null-date bucket (goes last after sort).
    if (!current) current = { date: null, lines: [] };

    if (line.trim() === "") {
      // Collapse 2+ blanks ‚Üí single ""
      if (!pendingBlank) {
        current.lines.push(""); // represents a single <br>
        pendingBlank = true;
      }
    } else {
      current.lines.push(line);
      pendingBlank = false;
    }
  }

  pushCurrent();

  // Sort: dated blocks by ascending date; null-date blocks last.
  blocks.sort(function(a, b) {
    const ta = a.date ? a.date.getTime() : Infinity;
    const tb = b.date ? b.date.getTime() : Infinity;
    return ta - tb;
  });

  return blocks;
}

// Render a block's lines into safe HTML with single <br> for "" entries.
// Uses your existing formatNoteHTML() so names/date-bolding still apply.
function renderBlockHTML(block) {
  const parts = [];
  for (let i = 0; i < block.lines.length; i++) {
    const line = block.lines[i];
    if (line === "") {
      parts.push("<br>"); // collapsed blank
    } else {
      parts.push(formatNoteHTML(line));
    }
  }
  return parts.join("");
}

// Extract a Date from a line like M/D/YY, MM/DD/YYYY, etc.
// Returns Date or null if none found.
function extractDateFromLine(line) {
  var m = (line || '').match(/\b(\d{1,2})\/(\d{1,2})\/(\d{2,4})\b/);
  if (!m) return null;
  var month = parseInt(m[1], 10);
  var day   = parseInt(m[2], 10);
  var year  = parseInt(m[3], 10);
  if (year < 100) year = 2000 + year; // 24 ‚Üí 2024
  // Basic sanity
  if (month < 1 || month > 12 || day < 1 || day > 31) return null;
  return new Date(year, month - 1, day);
}





function displayNotes(notes) {
  var notesDisplay = document.getElementById('notesDisplay');
  notesDisplay.innerHTML = '';

  // Toggle note action visibility based on whether a client is selected
  var hasClient = !!((document.getElementById('clientSelect') || {}).value);
  var displayStyle = hasClient ? 'flex' : 'none';

  if (!notes || notes.length === 0) {
    notesDisplay.innerHTML = '<p>No notes to display.</p>';
    return;
  }

  // Collect lines from Column C only (ignore Column E)
  var allLines = [];
  notes.forEach(function(n) {
    if (n.note && n.note !== 'N/A') {
      n.note.split('\n').forEach(function(line) {
        // Keep all lines (including blank) ‚Äî groupLinesIntoBlocks will collapse 2+ blanks.
        allLines.push(String(line || ""));
      });
    }
  });

  if (allLines.length === 0) {
    notesDisplay.innerHTML = '<p>No notes to display.</p>';
    return;
  }

  // Build dated blocks with inheritance + blank-line collapsing
  var blocks = groupLinesIntoBlocks(allLines);

  // Container
  var container = document.createElement('div');
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.alignItems = 'stretch';
  container.style.width = '100%';
  container.style.position = 'relative';

  // === UNHIGHLIGHTED (older blocks, hidden by default) ===
  var unhighlightedWrap = document.createElement('div');
  unhighlightedWrap.id = 'unhighlightedNotes';
  unhighlightedWrap.style.display = 'flex';
  unhighlightedWrap.style.flexDirection = 'column';
  unhighlightedWrap.style.gap = '5px';
  container.appendChild(unhighlightedWrap);

  var toggleBtn = document.createElement('button');
  toggleBtn.id = 'toggleNotesButton';
  toggleBtn.onclick = toggleNotesVisibility;
  toggleBtn.type = 'button';
  toggleBtn.setAttribute('aria-label', 'Show older notes');
  toggleBtn.setAttribute('aria-pressed', 'false');

  var toggleRow = document.createElement('div');
  toggleRow.style.display = 'flex';
  toggleRow.style.justifyContent = 'center';
  toggleRow.style.margin = '0';
  toggleRow.appendChild(toggleBtn);
  container.appendChild(toggleRow);

  // === BUTTON ROW (moved beside the label dropdown) ===
  var buttonRow = document.createElement('div');
  buttonRow.className = 'labels-buttons-row';
  buttonRow.style.flexDirection = 'column';
  buttonRow.style.alignItems = 'center';
  buttonRow.style.gap = '10px';

  var editBtn = document.createElement('button');
  editBtn.id = 'editNotesButton';
  editBtn.className = 'secondary-button inline-button';
  editBtn.title = 'Edit notes';
  editBtn.setAttribute('aria-label', 'Edit notes');
  editBtn.style.fontSize = '1em';
  editBtn.style.marginLeft = '0';
  editBtn.innerHTML = '‚úèÔ∏è';
  editBtn.onclick = function (e) {
    e.stopPropagation();
    // Flatten blocks back to the user's raw lines (join with \n)
    var flattened = [];
    blocks.forEach(function(b){
      b.lines.forEach(function(line){
        // Turn the collapsed "" back into a blank line on edit
        flattened.push(line === "" ? "" : line);
      });
    });
    editCombinedNotes(container, flattened.join('\n'));
  };

  var apptBtn = document.getElementById('addAppointmentBtn');
  if (!apptBtn) {
    apptBtn = document.createElement('button');
    apptBtn.id = 'addAppointmentBtn';
    apptBtn.type = 'button';
  }
  apptBtn.className = 'secondary-button inline-button appointment-icon-btn';
  apptBtn.title = 'Add appointment to calendar for this client';
  apptBtn.setAttribute('aria-label', 'Add appointment to calendar for this client');
  apptBtn.innerHTML = 'üìÖ';
  apptBtn.style.display = displayStyle;
  apptBtn.onclick = function (e) {
    e.stopPropagation();
    showAppointmentInput();
  };

  buttonRow.appendChild(apptBtn);
  buttonRow.appendChild(editBtn);

  var labelsButtonsRow = document.getElementById('labelsButtonsRow');
  if (labelsButtonsRow) {
    labelsButtonsRow.innerHTML = '';
    labelsButtonsRow.appendChild(buttonRow);
  } else {
    container.appendChild(buttonRow);
  }

  var chipSlot = document.getElementById('labelsChipSlot');
  if (chipSlot) {
    chipSlot.innerHTML = '';
  }

  var chipInfo = window.__chipForCurrentClient || { initials: "", date: "" };
  var currentClientId = document.getElementById('clientSelect').value || "";
  var noteChipEl = null;
  if (currentClientId) {
    noteChipEl = createChipElement(
      currentClientId,
      (chipInfo.initials || "").toUpperCase(),
      chipInfo.date || ""
    );
    noteChipEl.classList.add('note-chip-inline');
  }

  // === HIGHLIGHTED (newest 3 blocks) ===
  var highlightedWrap = document.createElement('div');
  highlightedWrap.id = 'highlightedNotes';
  highlightedWrap.style.display = 'flex';
  highlightedWrap.style.flexDirection = 'column';
  highlightedWrap.style.gap = '5px';
  container.appendChild(highlightedWrap);

  // Determine which blocks are "top 3" newest
  var lastIdx = blocks.length - 1;
  var highlightCount = Math.min(3, blocks.length);
  var firstHighlightIdx = lastIdx - (highlightCount - 1);

  // Render blocks: newest 3 highlighted, older hidden by default
  blocks.forEach(function(block, i) {
    var div = document.createElement('div');
    div.style.fontSize = '32px';
    div.style.marginBottom = '0px';
    div.classList.add('note-line');

    // Render whole block as one "note" (date + its continuation lines)
    div.innerHTML = renderBlockHTML(block);

    if (i >= firstHighlightIdx) {
      // Newest 3 blocks ‚Üí highlighted
      div.classList.add('latest-note');
      div.style.backgroundColor = 'yellow';
      highlightedWrap.appendChild(div);

    } else {
      // Older blocks ‚Üí hidden by default; toggled by MORE/LESS
      div.classList.add('older-note');
      div.style.display = 'none';
      unhighlightedWrap.appendChild(div);
    }
  });

  if (noteChipEl && highlightedWrap.children.length) {
    var latestNote = highlightedWrap.lastElementChild;
    if (latestNote) {
      // Remove trailing line breaks so the chip sits on the last text line
      latestNote.innerHTML = latestNote.innerHTML.replace(/(<br\s*\/?>(\s|&nbsp;)*)+$/i, '');
      // Ensure a single space before the chip for inline alignment with the final text
      latestNote.append(document.createTextNode(' '));
      latestNote.appendChild(noteChipEl);
    }
  }

// Always show the row; only hide the toggle button if no older blocks
var hasOlder = unhighlightedWrap.children.length > 0;
toggleBtn.style.display = hasOlder ? 'inline-block' : 'none';
buttonRow.style.display = 'flex'; // keep the row visible so ‚úèÔ∏è stays


  notesDisplay.appendChild(container);

  // Mentions hover/click handlers on both areas
  attachMentionHandlers(highlightedWrap);
  attachMentionHandlers(unhighlightedWrap);
}






  /* ===== UI STATE (client + filter) ‚Äî ADD THIS BLOCK ONCE ===== */
const UI_STATE_KEY = 'uiState.v1';

function getCurrentUIState() {
  const dd = document.getElementById('topClientsFilterDropdown');
  const sel = document.getElementById('clientSelect');
  return {
    filter: dd ? dd.value : '',
    client: sel ? sel.value : ''
  };
}

function saveUIState(state) {
  try {
    localStorage.setItem(UI_STATE_KEY, JSON.stringify(state || getCurrentUIState()));
  } catch (_) {}
}

function restoreUIState() {
  // Always start in JB on a fresh load
  const dd = document.getElementById('topClientsFilterDropdown');
  if (dd) {
    dd.value = 'JB';
    if (typeof handleTopClientsFilterChange === 'function') {
      handleTopClientsFilterChange('JB');
    }
  }

  // Optionally restore the last open client (but keep JB filter)
  let raw = null, st = null;
  try { raw = localStorage.getItem(UI_STATE_KEY); } catch (_){}
  if (!raw) return;

  try { st = JSON.parse(raw) || {}; } catch (_){ st = {}; }

  if (st.client) {
    const sel = document.getElementById('clientSelect');
    if (sel) {
      sel.value = st.client;
      const clientAutocomplete = document.getElementById('clientAutocomplete');
      if (clientAutocomplete && sel.selectedIndex >= 0) {
        clientAutocomplete.value = sel.options[sel.selectedIndex].text;
      }
      if (typeof showClientNotes === 'function') showClientNotes();
    }
  }
}



/* Call this whenever you want a hard reload that returns to the same spot */
function reloadPreservingState() {
  saveUIState();   // snapshot current filter/client
  location.reload();
}
/* ===== END UI STATE BLOCK ===== */


// REPLACE EVERYTHING in editCombinedNotes(...) with this version
function editCombinedNotes(contentElement, existingText) {
  // Create a textarea with the existing text (all Column C lines)
  var textarea = document.createElement('textarea');
  textarea.value = existingText;
  textarea.style.width = '100%';
  textarea.style.boxSizing = 'border-box';
  textarea.style.resize = 'vertical';

  // === Mirror the client notes font exactly ===
  // Try to read computed styles from a rendered .note-line (the same look as client notes).
  (function syncToNoteFont() {
    // Prefer the newest highlighted note first, then any note-line
    var sample = document.querySelector('#highlightedNotes .note-line') ||
                 document.querySelector('.note-line');

    if (sample) {
      var cs = window.getComputedStyle(sample);
      textarea.style.fontFamily = cs.fontFamily || 'inherit';
      textarea.style.fontSize   = cs.fontSize   || '32px';
      textarea.style.lineHeight = cs.lineHeight || '1.3';
      textarea.style.fontWeight = cs.fontWeight || 'normal';
      textarea.style.letterSpacing = cs.letterSpacing || 'normal';
    } else {
      // Fallback if notes aren‚Äôt rendered yet
      textarea.style.fontFamily = 'inherit';
      textarea.style.fontSize   = '32px';
      textarea.style.lineHeight = '1.3';
    }
  })();

  // Replace the contentElement with the textarea
  var parent = contentElement.parentNode;
  parent.replaceChild(textarea, contentElement);

  // Ensure proper height
  setTimeout(function(){ adjustTextareaHeight(textarea); }, 0);
  textarea.addEventListener('input', function(){ adjustTextareaHeight(this); });

  textarea.addEventListener('blur', function() {
    var newText = textarea.value;
    if (newText !== existingText) {
      if (confirm('Save changes to NOTES (Column C)?')) {
        var clientName = document.getElementById('clientSelect').value;
        showLoadingBar();
        google.script.run
          .withSuccessHandler(function() {
            hideLoadingBar();
            alert('Notes updated successfully.');
            // Refresh the client view + top clients
            showClientNotes();
retriggerTopClientsFilter();

            google.script.run.sendEditSummaryEmail(clientName, 'pastWork', existingText, newText);
          })
          .withFailureHandler(function(error) {
            hideLoadingBar();
            alert('Error saving edits: ' + error.message);
            // Rebuild the UI (without changes)
            showClientNotes();
          })
          .updateNotes(clientName, 'pastWork', newText); // <-- COLUMN C ONLY
      } else {
        // Rebuild the UI (no changes)
        showClientNotes();
      }
    } else {
      // No changes; rebuild
      showClientNotes();
    }
  });

  textarea.focus();
  textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
}


function adjustTextareaHeight(textarea) {
    textarea.style.height = 'auto'; // Reset height
    textarea.style.height = textarea.scrollHeight + 'px'; // Set new height
}

/**
 * highlightLatestDate(lines, element, style, chipInfo)
 * - lines: array of strings (each line of FOLLOW UPS or PAST)
 * - element: container to append into
 * - style: inline style string
 * - chipInfo (optional): { clientName, initials, chipDate, enableChip }
 *   Only when enableChip === true do we inject the chip (FOLLOW UPS only).
 */
function highlightLatestDate(lines, element, style, chipInfo) {
  var latestDate = null;
  var latestLine = null;

  lines.forEach(function(line) {
    var lineElement = document.createElement('div');
    lineElement.style = style;
    lineElement.innerHTML = line;
    var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);

    if (dates) {
      var date = new Date(dates[0]);
      if (!latestDate || date > latestDate) {
        latestDate = date;
        latestLine = lineElement;
      }
    }
    lineElement.classList.add('non-highlighted-note');
    element.appendChild(lineElement);
  });

  if (latestLine) {
    latestLine.style.backgroundColor = 'yellow';
    latestLine.classList.remove('non-highlighted-note');

    // If this is FOLLOW UPS, append the chip INSIDE the yellow highlight
    if (chipInfo && chipInfo.enableChip) {
      var initials = chipInfo.initials || '';
      var mmddyy   = chipInfo.chipDate || '';
      var clientName = chipInfo.clientName || (typeof currentClientName !== 'undefined' ? currentClientName : '');

      // create and insert chip after the text
      var chipEl = createChipElement(clientName, initials, mmddyy);
      latestLine.appendChild(chipEl);
    }
  }
}



function normalizeChipDate(raw) {
  if (!raw) return '';
  raw = String(raw).trim();
  let m, d, y;

  const m1 = raw.match(/^(\d{1,4})[-\/](\d{1,2})[-\/](\d{1,4})$/);
  if (m1) {
    const a = parseInt(m1[1], 10);
    const b = parseInt(m1[2], 10);
    const c = parseInt(m1[3], 10);
    if (String(m1[1]).length === 4) { // YYYY-MM-DD
      y = a; m = b; d = c;
    } else {                          // MM/DD/YY(YY)
      m = a; d = b; y = c;
    }
  } else {
    const dt = new Date(raw);
    if (isNaN(dt)) return raw;
    m = dt.getMonth() + 1;
    d = dt.getDate();
    y = dt.getFullYear();
  }
  if (y < 100) y = 2000 + y; // 24 -> 2024
  const yy = String(y).slice(-2);
  return `${m}/${d}/${yy}`;   // M/D/YY (no leading zeros)
}

function showCalendarInput() {
    var calendarSection = document.getElementById('calendarInputSection');
    if (calendarSection.style.display === 'none' || calendarSection.style.display === '') {
        calendarSection.style.display = 'block';
    } else {
        calendarSection.style.display = 'none';
    }
}

function logPastWorkSubmissionToInbox(noteText, clientName) {
    var trimmed = (noteText || '').trim();
    if (!trimmed) return;

    try {
        google.script.run.inboxAddNote(trimmed, clientName || '');
    } catch (e) {
        console.log('Unable to mirror submit to inbox:', e);
    }
}

function submitPastWork() {
    var clientName = document.getElementById('clientSelect').value;
    var pastWorkContent = document.getElementById('newPastWork').value;

    // Show the loading bar
    showLoadingBar();

    // Update past work on the server
    google.script.run.withSuccessHandler(function(wasUpdated) {
        if (wasUpdated) {
showStarAnimation(); // SNIPPET #3


            alert('Past work updated successfully.');

            logPastWorkSubmissionToInbox(pastWorkContent, clientName);

retriggerTopClientsFilter();



google.script.run
  .withSuccessHandler(function (clients) {
    repaintTopClientsWithCurrentFilter(clients);  // ‚Üê always matches dropdown
  })
  .getTopClients();


            // Optionally, refresh the notes for the selected client
            showClientNotes();

            // Send an email notification if needed
            google.script.run.sendEmailNotification(clientName, pastWorkContent);
        } else {
            alert('Failed to update past work. Please try again.');
        }
        document.getElementById('newPastWork').value = ''; // Clear the textarea

        // Hide the loading bar after processing is complete
        hideLoadingBar();
    }).updatePastWork(clientName, pastWorkContent);
}







// Re-apply the current dropdown filter after any category change/save
function retriggerTopClientsFilter(){
  var dd = document.getElementById('topClientsFilterDropdown');
  var current = (dd && dd.value) ? dd.value : 'JB';
  if (typeof handleTopClientsFilterChange === 'function') {
    handleTopClientsFilterChange(current);
  } else if (typeof syncClientsListToDropdown === 'function') {
    // Fallback: full sync
    syncClientsListToDropdown();
  }
}



// Refresh dropdown/autocomplete data after a category change so UI reflects it immediately.
function refreshUIWithNewCategory(clientName, newCategory) {
  google.script.run
    .withSuccessHandler(function (clients) {
      clientsData = Array.isArray(clients) ? clients : [];
      if (typeof rebuildClientNameIndex === 'function') {
        rebuildClientNameIndex();
      }

      populateClientDropdown(clientsData);

      var clientSelect = document.getElementById('clientSelect');
      if (clientSelect) {
        clientSelect.value = clientName;
      }

    selectUpdatedClient(clientName, newCategory);
    })
    .withFailureHandler(function (err) {
      console.error('Failed to refresh clients after category update:', err);
    })
    .getAllClientsData();
    }


// Select the updated client in the dropdown and reload notes
function selectUpdatedClient(clientName, newCategory) {
    var clientSelect = document.getElementById('clientSelect');
    var clientAutocomplete = document.getElementById('clientAutocomplete');
   var updatedClientText = newCategory ? clientName + ' (' + newCategory + ')' : clientName;
    if (clientSelect) {
        clientSelect.value = clientName;
    }

   if (clientAutocomplete) {
        clientAutocomplete.value = updatedClientText;
        clientAutocomplete.style.color = 'black';
    }

    if (typeof currentClientName !== 'undefined') {
        currentClientName = updatedClientText;
    }

    if (typeof showClientNotes === 'function' && clientSelect) {
        showClientNotes();
    }
}


// Rest of your existing functions...


function displayTimeSensitiveTasks() {
    var tasksDisplay = document.getElementById('timeSensitiveTasksDisplay');
    // Check if the display area is already populated
    if (tasksDisplay.innerHTML.trim() !== '') {
        tasksDisplay.innerHTML = ''; // Clear the display area
    } else {
        showLoadingBar(); // Show the loading bar
        google.script.run.withSuccessHandler(function(result) {
            showTimeSensitiveTasks(result);
            hideLoadingBar(); // Hide the loading bar after loading is complete
        }).getTimeSensitiveTasks();
    }
}


function showTimeSensitiveTasks(tasks) {
    var tasksDisplay = document.getElementById('timeSensitiveTasksDisplay');
    tasksDisplay.innerHTML = ''; // Clear the existing content

    var clientsTasks = {}; // Object to hold the latest task per client and category

    tasks.forEach(function(task) {
        var parts = task.split('-');
        if (parts.length > 1) {
            var clientName = parts[0].trim();
            var clientCategory = parts[1].trim();
            var details = parts.slice(2).join('-').trim();
            var dateMatches = details.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
            if (dateMatches) {
                var date = new Date(dateMatches[0]);
                if (!clientsTasks[clientName]) {
                    clientsTasks[clientName] = {};
                }
                if (!clientsTasks[clientName][clientCategory] || clientsTasks[clientName][clientCategory].date < date) {
                    clientsTasks[clientName][clientCategory] = { date: date, details: details };
                }
            }
        }
    });

    // Now, create DOM elements for each client and their latest task per category
    for (var clientName in clientsTasks) {
        for (var category in clientsTasks[clientName]) {
            var taskInfo = clientsTasks[clientName][category];

            var clientDiv = document.createElement('div');
            var selectButton = document.createElement('button');
            selectButton.onclick = function() { selectClientFromTimeSensitiveTasks(clientName); };
            selectButton.textContent = clientName;
            clientDiv.appendChild(selectButton);

            var categorySpan = document.createElement('span');
            categorySpan.style.cssText = "margin-left: 10px;";
            categorySpan.textContent = category + ': ' + taskInfo.details;
            clientDiv.appendChild(categorySpan);

            tasksDisplay.appendChild(clientDiv);
            tasksDisplay.appendChild(document.createElement('hr')); // For visual separation
        }
    }
}




// Function to extract the base name of a client
function extractBaseName(clientName) {
    // Use a regex to remove trailing numbers and spaces
    return clientName.replace(/\d+$/, '').trim();
}







        // Submit New Client
      function submitNewClient() {
  var clientName = document.getElementById('newClientName').value;
  var futureWorkNote = document.getElementById('newClientNote').value; // Optional field
  var category = document.getElementById('newClientCategory').value;
  var pastWork = document.getElementById('pastWork').value; // Optional field

  // Check if the required fields (clientName and category) are filled
  if (!clientName || !category) {
    alert('Please fill in the required fields: Client Name and Category.');
    return;
  }

  // Call Google Apps Script function
  google.script.run
    .withSuccessHandler(function(response) {
      alert('New client added: ' + clientName); // Notify success
      // Clear input fields and hide form
      document.getElementById('newClientName').value = '';
      document.getElementById('newClientNote').value = '';
      document.getElementById('newClientCategory').value = '';
      document.getElementById('pastWork').value = '';
      document.getElementById('newClientForm').style.display = 'none';

      // Refresh clientsData and the dropdown
      google.script.run
        .withSuccessHandler(function(data){
          clientsData = data;
          populateClientDropdown(clientsData);

          // Now select the new client in the dropdown
          var clientSelect = document.getElementById('clientSelect');
          var clientAutocomplete = document.getElementById('clientAutocomplete');

          for (var i = 0; i < clientSelect.options.length; i++) {
            if (clientSelect.options[i].value === clientName) {
              clientSelect.selectedIndex = i;
              clientAutocomplete.value = clientSelect.options[i].text;
              break;
            }
          }
          // Now call showClientNotes()
          showClientNotes();

          console.log('Before alert');
          // Show the pop-up message
          alert('PLEASE ADD FUTURE WORK IN ORDER FOR NEW CLIENT TO ENTER DASHBOARD WORKFLOW');
          console.log('After alert');

        })
        .withFailureHandler(function(error) {
          console.error('Error fetching client data:', error);
          alert('Error fetching client data. Please try again.');
        })
        .getAllClientsData();

    })
    .withFailureHandler(function(error) {
      console.error('Error adding new client:', error);
      alert('Error adding new client. Please try again.');
    })
    .addNewClientWithPastWork(clientName, futureWorkNote, category, pastWork);
}







// Function triggered by the "TOP PRIORITY CLIENTS" button
function displayTopClients() {
  displayFilteredClients('JB'); // Show strictPast (Immediate) clients by default
}

// This function is triggered by the quadrant buttons
function displayFilteredClients(filter) {
    showLoadingBar(); // Show loading indication
    google.script.run.withSuccessHandler(function(result) {
        showTopClients(result, filter);
        hideLoadingBar(); // Hide loading indication

        // Get today's date in the required format
        var formattedDates = stampTodayDateTitle();

        // Initialize titles
        var dateTitle = formattedDates.longDate;
        var topClientsTitle = '';

        // Set titles based on the filter
      // SNIPPET: ALWAYS SHOW DATE
// Set topClientsTitle based on the filter, but ALWAYS set dateTitle to today's date
dateTitle = formattedDates.longDate;
switch (filter) {
    case 'strictPast':
        topClientsTitle = 'TOP CLIENTS:';
        break;
    case 'flexiblePast':
        topClientsTitle = 'FLEXIBLE';
        break;
    case 'strictUpcoming':
        topClientsTitle = 'STRICT';
        break;
    case 'flexibleUpcoming':
        topClientsTitle = 'FLEXIBLE';
        break;
    case 'others':
        topClientsTitle = 'OTHERS';
        break;
    case 'all':
        topClientsTitle = 'ALL';
        break;
    default:
        topClientsTitle = filter.toUpperCase();
        break;
}

// Now that dateTitle is set for EVERY filter...
document.getElementById('dateTitle').innerText = dateTitle;
document.getElementById('topClientsTitle').innerText = '';
document.getElementById('topClientsTitle').style.display = 'none';

        fitTopClientsHeaderControls();

    }).getTopClients(); // Your server-side function to fetch top clients
}

/**********************************************
  (A) The "OLD" function (for updates/reloading)
**********************************************/function showTopClients(clients, filterKey) {
  // Keep dropdown visually in sync
  var dd = document.getElementById('topClientsFilterDropdown');
  if (dd && filterKey) dd.value = filterKey;

  var filter = normalizeTopClientsFilter(filterKey || 'JB'); // you already have this helper
  var out = document.getElementById('topClientsDisplay');
  if (!out) return;
  out.innerHTML = '';

  // Map emojis ‚Üí actual emoji to look for
  var emojiMap = {
    BRIEFCASE: 'üíº',
    STAR: '‚≠ê',
    GRADCAP: 'üéì',
    PHONE: 'üìû'
  };

  // Robust emoji checker for various label shapes
  function hasEmojiLabel(c, emoji) {
    if (!emoji) return false;
    const L = String(c.columnLContent || c.suggestion || '');
    return L.includes(emoji);
  }

  // OWNER filters (JB/RB/QC/TEAM)
  var OWNER_KEYS = ['JB','RB','QC','TEAM','BDAY'];

  var filtered = clients.filter(function(c){
    if (OWNER_KEYS.includes(filter)) {
      var initials = (c.chipInitials || c.initials || '').toUpperCase();
      return initials === filter;
    }
    // ICON filters
    var emoji = emojiMap[filter];
    return emoji ? hasEmojiLabel(c, emoji) : true;
  });

  // Sort: chipDate (valid earliest first), blanks LAST; then name
  filtered.sort(function(a, b){
    var ta = chipDateToTimeForSort(a && a.chipDate);
    var tb = chipDateToTimeForSort(b && b.chipDate);
    if (ta !== tb) return ta - tb;

    var na = (a.clientName || a.name || '').toLowerCase();
    var nb = (b.clientName || b.name || '').toLowerCase();
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
  });

  // Paint
  filtered.forEach(function(c){ displayClient(c, out); });

  // Re-wire suggestion textareas + visibility
  if (typeof wireToplistSuggestionTextareas === 'function') wireToplistSuggestionTextareas();
  if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
}

/* Helper: push blank/invalid chip dates to the BOTTOM */
function chipDateToTimeForSort(chipDateStr){
  // Expecting like "MM/DD/YY" (you can reuse your existing parser if you have one)
  if (!chipDateStr) return Number.POSITIVE_INFINITY;
  var d = new Date(chipDateStr);
  return isNaN(d) ? Number.POSITIVE_INFINITY : d.getTime();
}


/**********************************************
  (B) The "NEW" function (for initial page load)
**********************************************/function showTopClientsOnLoad(clients, filterKey) {
  // 1) Stamp the date + clear the title (your existing UI bits)
  stampTodayDateTitle();

  (function clearInitialTitle(){
    var titleEl = document.getElementById('topClientsTitle');
    if (!titleEl) return;
    titleEl.innerText = '';
    titleEl.style.display = 'none';
  })();

  fitTopClientsHeaderControls();

  // 2) Resolve filter from dropdown if not passed; default to JB
  var dd = document.getElementById('topClientsFilterDropdown');
  var chosen = filterKey || (dd && dd.value) || 'JB';
  var filter = normalizeTopClientsFilter(chosen); // you already have this helper

  // Keep dropdown visually in sync with what we render
  if (dd) dd.value = filter;

  var out = document.getElementById('topClientsDisplay');
  if (!out) return;
  out.innerHTML = '';

  // 3) Filtering: owners OR emoji labels only
  var OWNER_KEYS = ['JB','RB','QC','TEAM','BDAY'];
  var emojiMap = { BRIEFCASE:'üíº', STAR:'‚≠ê', GRADCAP:'üéì', PHONE:'üìû' };

  function hasEmojiLabel(c, emoji) {
    if (!emoji) return false;
    const L = String(c.columnLContent || c.suggestion || '');
    return L.includes(emoji);
  }

  var filtered = (clients || []).filter(function(c){
    if (OWNER_KEYS.includes(filter)) {
      var initials = (c.chipInitials || c.initials || '').toUpperCase();
      return initials === filter;
    }
    var emoji = emojiMap[filter];
    return emoji ? hasEmojiLabel(c, emoji) : true;
  });

  // 4) Sort: chipDate ascending; blanks/invalids LAST; then name
  filtered.sort(function(a, b){
    var ta = chipDateToTimeForSort(a && a.chipDate);
    var tb = chipDateToTimeForSort(b && b.chipDate);
    if (ta !== tb) return ta - tb;

    var na = (a.clientName || a.name || '').toLowerCase();
    var nb = (b.clientName || b.name || '').toLowerCase();
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
  });

  // 5) Paint
  filtered.forEach(function(c){ displayClient(c, out); });

  // 6) Wire suggestion areas & visibility
  if (typeof wireToplistSuggestionTextareas === 'function') wireToplistSuggestionTextareas();
  if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
}

/* Helper used above: push blank/invalid chip dates to BOTTOM */
function chipDateToTimeForSort(chipDateStr){
  if (!chipDateStr) return Number.POSITIVE_INFINITY;
  var d = new Date(chipDateStr);
  return isNaN(d) ? Number.POSITIVE_INFINITY : d.getTime();
}




function updateColumnB(clientName, columnBValue) {
    // Show the loading bar when the update process begins
    showLoadingBar();

    google.script.run
        .withSuccessHandler(function() {
            // Log success message or inform the user through the UI
            console.log('Column B updated successfully for', clientName, 'to', columnBValue);
            // Optionally, refresh client data on the page to reflect the update
            // e.g., getTopClients(); assuming you have a function to refresh the displayed clients

            // Hide the loading bar after successfully updating
            hideLoadingBar();
        })
        .withFailureHandler(function(error) {
            // Log error or inform the user through the UI
            console.error('Error updating Column B for', clientName, ':', error);

            // Hide the loading bar even if the update fails to inform the user that the process has completed
            hideLoadingBar();
        })
        .updateClientColumnB(clientName, columnBValue); // Assuming this is the correct server-side function name
}


function updateColumnD(clientName, columnDValue) {
    // Show the loading bar when the update process begins
    showLoadingBar();

    google.script.run
        .withSuccessHandler(function() {
            // Log success message or inform the user through the UI
            console.log('Column D updated successfully for', clientName, 'to', columnDValue);
            // Optionally, refresh client data on the page to reflect the update
            // e.g., getTopClients(); assuming you have a function to refresh the displayed clients

            // Hide the loading bar after successfully updating
            hideLoadingBar();
        })
        .withFailureHandler(function(error) {
            // Log error or inform the user through the UI
            console.error('Error updating Column D for', clientName, ':', error);

            // Hide the loading bar even if the update fails to inform the user that the process has completed
            hideLoadingBar();
        })
        .updateClientColumnD(clientName, columnDValue); // Assuming this is the correct server-side function name
}


// Ensure to define or include your existing functions like saveAllClientData, selectClientFromButton, showLoadingBar, hideLoadingBar, and others as needed.


//////////////////////////////////////////////


function toggleTopClientsDisplay() {
    var clientsDisplay = document.getElementById('topClientsDisplay');
    // Simply toggle the display visibility without refreshing the content
    if (clientsDisplay.style.display === 'block' || clientsDisplay.style.display === '') {
        clientsDisplay.style.display = 'none'; // Hide
    } else {
        clientsDisplay.style.display = 'block'; // Show without refreshing the data
    }
}



function saveAllClientData() {
    showLoadingBar(); // Optionally show a loading indicator

    var clientsDisplay = document.getElementById('topClientsDisplay');
    var clientDivs = clientsDisplay.querySelectorAll('div'); // Select all client divs

    var saveOperations = []; // To keep track of save operations

    for (var i = 0; i < clientDivs.length; i++) {
        var clientDiv = clientDivs[i];
        var clientName = clientDiv.querySelector('button.inline-button').innerText; // Assuming the client's name is in the button
        var textBox = clientDiv.querySelector('input[type="text"]');
        var newData = textBox.value;

        // Save each client's data
        (function(clientName, newData) {
            saveOperations.push(new Promise(function(resolve, reject) {
                google.script.run.withSuccessHandler(function() {
                    resolve(); // Resolve the promise when data is successfully saved
                }).withFailureHandler(function() {
                    reject(); // Reject the promise if there's an error
                }).updateClientData(clientName, newData);
            }));
        })(clientName, newData);
    }

    // Wait for all save operations to complete before refreshing
    Promise.all(saveOperations).then(function() {
        hideLoadingBar(); // Hide loading bar on success
        alert('All data saved successfully.'); // Notify the user
retriggerTopClientsFilter();

            }).catch(function() {
        hideLoadingBar(); // Hide loading bar in case of error
        alert('An error occurred while saving the data.'); // Notify the user about the error
    });
}




function displayClientsByCategory() {
    var selectedCategory = document.getElementById('categoryDisplaySelect').value;
    if (selectedCategory) {
        google.script.run.withSuccessHandler(showClientsByCategory).getClientsByCategory(selectedCategory);
    }
}

function showClientsByCategory(clients) {
    var displayArea = document.getElementById('categoryClientsDisplay');
    displayArea.innerHTML = '';

    clients.forEach(function(client) {
        var clientInfo = `
            <div>
                <strong>Name:</strong> ${client.name}<br>
                <strong>Date:</strong> ${client.date}<br>
                <strong>Note:</strong> ${client.note}<br>
                <strong>Follow-up:</strong> ${client.followUp}<br>
                <strong>Category:</strong> ${client.category}<br>
            </div>
            <hr>
        `;
        displayArea.innerHTML += clientInfo;
    });
}

function showAppointmentInput() {
    var modal = document.getElementById('appointmentModal');
    if (!modal) return;

    var clientName = document.getElementById('clientSelect').value;
    var now = new Date();
    var dateInput = document.getElementById('appointmentDate');
    var timeInput = document.getElementById('appointmentTime');
    var modalTitle = document.getElementById('appointmentModalTitle');
    var modalSubtitle = document.getElementById('appointmentModalSubtitle');

    if (modalTitle) {
      modalTitle.textContent = clientName ? `Schedule appointment for ${clientName}` : 'Schedule appointment';
    }
    if (modalSubtitle) {
      modalSubtitle.textContent = 'Choose a date and start time for this client.';
    }

    if (dateInput && !dateInput.value) {
      dateInput.value = now.toISOString().split('T')[0];
    }
    if (timeInput && !timeInput.value) {
      var hours = String(now.getHours()).padStart(2, '0');
      var minutes = String(now.getMinutes()).padStart(2, '0');
      timeInput.value = `${hours}:${minutes}`;
    }

    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');

    if (dateInput) {
      dateInput.focus();
    }
}

function closeAppointmentModal() {
    var modal = document.getElementById('appointmentModal');
    if (!modal) return;

    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
}

function submitAppointmentToCalendar() {
    var clientName = document.getElementById('clientSelect').value;
    var appointmentDate = document.getElementById('appointmentDate').value;
    var appointmentTime = document.getElementById('appointmentTime').value;

    if (!appointmentDate || !appointmentTime) {
        alert('Please select both a date and start time.');
        return;
    }

    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
        // Assuming 'refreshClientData' is a function to refresh client data
        refreshClientData(); // Call this function to refresh the client data
        closeAppointmentModal();
    }).addAppointmentToCalendar(clientName, appointmentDate, appointmentTime);
}

function refreshClientData() {
    var selectedClient = document.getElementById('clientSelect').value;
    if (selectedClient) {
        // Call the function that fetches and displays the client data
        showClientNotes();
    }
}




function resizeElements(applySmallerSize) {
    var buttons = tasksDisplay.querySelectorAll('button');
    buttons.forEach(function(button) {
        if (applySmallerSize) {
            button.classList.add('smaller-size');
        } else {
            button.classList.remove('smaller-size');
        }
    });
}











        // Show Add New Client Form
function displayAddNewClientForm() {
    var form = document.getElementById('newClientForm');
    if (form.style.display === 'block') {
        form.style.display = 'none'; // Hide the form if it's currently shown
    } else {
        form.style.display = 'block'; // Show the form if it's currently hidden
    }
}
var suggestions; // Keep this global to store suggestions

function autocompleteClient() {
  var clientSelect = document.getElementById('clientSelect');
  var inputElement = document.getElementById('clientAutocomplete');
  if (!inputElement) return;

  suggestions = document.getElementById('autocompleteSuggestions');
  if (!suggestions) {
    suggestions = document.createElement('div');
    suggestions.id = 'autocompleteSuggestions';
    inputElement.parentNode.appendChild(suggestions);
    var clientContainer = document.querySelector('.client-container');
    if (clientContainer && clientContainer.classList.contains('hide-recents')) {
      suggestions.classList.add('is-contracted');
      suggestions.style.display = 'none';
    }
  }

  var inputValue = (inputElement.value || '').trim().toLowerCase();

  // Clear current suggestions
  suggestions.innerHTML = '';

  // Calculate the available height below the input field
  var rect = inputElement.getBoundingClientRect();
  var availableHeight = window.innerHeight - rect.bottom;

  // Set the max-height of suggestions to the available height
  suggestions.style.maxHeight = availableHeight + 'px';

  if (!inputValue || !Array.isArray(clientsData) || !clientsData.length) {
    suggestions.style.display = 'none';
    return;
  }

  // Populate suggestions using case-insensitive matching against name, category, or row text
  var matchedClients = clientsData.filter(function(client) {
    var name = (client.clientName || '').toLowerCase();
    var category = (client.category || '').toLowerCase();
    var rowText = (client.rowText || '').toLowerCase();
    return name.includes(inputValue) || category.includes(inputValue) || rowText.includes(inputValue);
  });

  if (!matchedClients.length) {
    suggestions.style.display = 'none';
    return;
  }

  matchedClients.forEach(function(client) {
    var suggestion = document.createElement('div');
    suggestion.innerHTML = client.clientName + (client.category ? ' (' + client.category + ')' : '');

    suggestion.onclick = function() {
      inputElement.value = this.innerHTML;
      if (clientSelect) clientSelect.value = client.clientName;
      showClientNotes();
      scrollToTop(); // Add this line to scroll to the top

      suggestions.innerHTML = ''; // Hide suggestions after selection
      suggestions.style.display = 'none';
    };

    suggestions.appendChild(suggestion);
  });

  suggestions.style.display = 'block';
}





function displayDomTasks() {
    var tasksDisplayArea = document.getElementById('domTasksDisplay');
    
    // Check if tasks are currently displayed
    if (tasksDisplayArea.innerHTML.trim() !== '') {
        // If displayed, clear the content to hide them
        tasksDisplayArea.innerHTML = '';
    } else {
        showLoadingBar(); // Show the loading bar
        google.script.run.withSuccessHandler(function(result) {
            showDomTasks(result);
            hideLoadingBar(); // Hide the loading bar after loading is complete
        }).getDomTasks();
    }
}




// Function to extract client name from the task string
function extractClientNameFromTask(taskString) {
    var endOfNameIndex = taskString.indexOf(' - '); // Find the index where client name ends
    if (endOfNameIndex !== -1) {
        return taskString.substring(0, endOfNameIndex).trim(); // Extract client name
    }
    return ''; // Return empty string if not found
}

// This function will be called when the task button is clicked
function selectClientFromButton(clientText) {

        hideClientNotes(); // Call the function when the input is clicked into


    var clientSelect = document.getElementById('clientSelect');

    for (var i = 0; i < clientSelect.options.length; i++) {
        // Extract the client name and category from the dropdown option
        var optionText = clientSelect.options[i].text;
        var optionClientName = optionText.split(' (')[0]; // Get the client name before the '('

        // Check if the client names match (without considering the category)
        if (clientText.startsWith(optionClientName)) {
            clientSelect.selectedIndex = i;
            showClientNotes(); // Refresh client notes if needed
            scrollToTop(); // Scroll to the top of the page
            break;
        }
    }
}

// 1) Paint function
function paintRecentBar(list){
  const wrap = document.getElementById('recentClientsBar');
  if (!wrap) return;
  const active = (typeof getActiveClientName === 'function') ? getActiveClientName() : '';
  const activeNorm = active ? String(active).trim().toLowerCase() : '';

  const filtered = (list || []).filter(e => {
    const nm = (e && e.name) ? String(e.name).trim().toLowerCase() : '';
    return !activeNorm || nm !== activeNorm;
  });

  if (!filtered.length) { wrap.innerHTML = ''; return; }

  const renderList = filtered.slice(0, 3);

  wrap.innerHTML = renderList.map(e => {
    const displayName = formatRecentClientName(e.name);
    const muted = e.columnL ? '' : ' rc-muted';
    const cat   = e.category ? `<span class="rc-cat">${e.category}</span>` : '';
    const chip  = (e.chipInitials || e.chipDate)
      ? `<span class="rc-chip">${(e.chipInitials||'').toUpperCase()}${e.chipDate?' ¬∑ '+e.chipDate:''}</span>` : '';
    const dot   = e.columnL ? '<span class="rc-dot" title="Has In-Progress"></span>' : '';
    return `
      <div class="recent-pill${muted}" data-name="${e.name}" title="${e.name}">
        ${dot}
        <span class="rc-name">${displayName}</span>
        ${cat}
        ${chip}
      </div>`;
  }).join('');

  // click ‚Üí open that client (use your existing loader)
  wrap.querySelectorAll('.recent-pill').forEach(pill => {
    pill.addEventListener('click', () => {
      const name = pill.getAttribute('data-name');
      // If you have a helper like selectClientFromButton(name), prefer that:
      if (typeof selectClientFromButton === 'function') {
        selectClientFromButton(name);
      } else {
        // Fallback to your existing dropdown flow
        const sel = document.getElementById('clientSelect');
        if (sel) {
          sel.value = name;
          showClientNotes();
          // keep the text box in sync if you use it
          const ca = document.getElementById('clientAutocomplete');
          if (ca) ca.value = name;
        }
      }
    });
  });
}

// 2) Load on page load: fast render, then (optional) metadata refresh
function loadRecentBar() {
  // Fast: use cached metadata
  google.script.run
    .withSuccessHandler(list => paintRecentBar(list))
    .getRecentClients(4, false);

  // Optional: refresh metadata in a second pass so chips/categories are up to date
  google.script.run
    .withSuccessHandler(list => paintRecentBar(list))
    .getRecentClients(4, true);
}

// Kick it off as soon as DOM is ready
document.addEventListener('DOMContentLoaded', loadRecentBar);

// 3) Whenever a client is opened, log it and refresh the bar
function onClientOpened(name){
  google.script.run
    .withSuccessHandler(() => loadRecentBar())
    .logRecentClient(name, 4);
}

// If you have a central place that runs when a client is selected, call onClientOpened there.
// Example: at the end of selectClientFromButton(...) or showClientNotes():
// onClientOpened(clientName);







// Utility function to format the date
function formatDate(dateString) {
  var dateParts = dateString.split('-'); // Split YYYY-MM-DD
  if (dateParts.length === 3) {
    var year = dateParts[0].substring(2); // Get last two digits of the year
    var month = dateParts[1];
    var day = dateParts[2];
    return month + '/' + day + '/' + year; // Format to MM/DD/YY
  }
  return dateString; // Return original string if it doesn't match expected format
}


function selectClientFromCalendarTask(clientName) {
    var clientSelect = document.getElementById('clientSelect');
    for (var i = 0; i < clientSelect.options.length; i++) {
        if (clientSelect.options[i].text.includes(clientName)) {
            clientSelect.selectedIndex = i;
            showClientNotes();
            scrollToTop(); // Smooth scroll to the top
            break;
        }
    }
}

// Smooth scroll to the top of the page
function scrollToTop() {
    window.scrollTo({
        top: 0,
        left: 0,
        behavior: 'smooth'
    });
}



function handleCalendarTaskSelection(taskName) {
    callServerFunction('getCategoryForClient', [taskName], function(category) {
        if (category) {
            selectClientFromCalendarTasks(taskName + ' (' + category + ')');
        } else {
            console.error('Category not found for client:', taskName);
            // Handle the case where the category is not found
        }
    });
}



function showLoadingBar() {
    var loadingBarContainer = document.getElementById('loadingBarContainer');
    var loadingBar = document.getElementById('loadingBar');
    loadingBarContainer.style.display = 'block';
    loadingBar.style.width = '0'; // Start with an empty bar
    setTimeout(function() {
        loadingBar.style.width = '100%'; // Transition to full width
    }, 20); // Start the transition slightly after displaying the bar
}

function hideLoadingBar() {
    var loadingBarContainer = document.getElementById('loadingBarContainer');
    var loadingBar = document.getElementById('loadingBar');
    loadingBar.style.width = '0'; // Reset to empty
    setTimeout(function() {
        loadingBarContainer.style.display = 'none';
    }, 2000); // Wait for the transition to finish before hiding the container
}



function handleUserSelectionChange() {
    var userSelection = document.getElementById('userSelection').value;
    var dateInputContainer = document.getElementById('dateInputContainer');

    // Show the date input for both 'JB' and 'Ricky'
    if (userSelection === 'JB' || userSelection === 'Ricky') {
        dateInputContainer.style.display = 'block';
    } else {
        dateInputContainer.style.display = 'none';
    }
}



function submitFutureWork() {
    var userSelection = document.getElementById('userSelection').value;
    var clientName = document.getElementById('clientSelect').value;
    var futureWorkText = document.getElementById('newFollowUp').value;
    var futureWorkDate = document.getElementById('futureWorkDate').value;

    // Show loading bar
    showLoadingBar();

    // Check if user is 'JB' or 'Ricky' and no date is entered
    if ((userSelection === 'JB' || userSelection === 'Ricky') && !futureWorkDate) {
        alert('Please enter a date for future work.');
        hideLoadingBar(); // Hide loading bar if validation fails
        return; // Stop execution of the function
    }

    // Call server-side function asynchronously
    google.script.run.withSuccessHandler(function(response) {
        alert('Future work added successfully to follow-up notes.');
        document.getElementById('newFollowUp').value = '';
        document.getElementById('futureWorkDate').value = '';


retriggerTopClientsFilter();

        // Refresh client notes
        showClientNotes();

        // Send email notification
        google.script.run.sendEmailNotification(clientName, futureWorkText);

        // If JB is selected and date is provided, create a task in JB's calendar
        if (userSelection === 'JB' && futureWorkDate) {
            addEventToCalendar(clientName, futureWorkDate, futureWorkText);
        }

        // If Ricky is selected and date is provided, create a task in Ricky's calendar
        if (userSelection === 'Ricky' && futureWorkDate) {
            addEventToRickyCalendar(clientName, futureWorkDate, futureWorkText);
        }

        hideLoadingBar(); // Hide loading bar after successful execution
    }).withFailureHandler(function(error) {
        alert('Error updating follow-up note.');
        hideLoadingBar(); // Hide loading bar also in case of failure
    }).updateFollowUp(clientName, futureWorkText, futureWorkDate, userSelection);
}








// Rest of your functions remain unchanged


function createCalendarTask(futureWorkText, futureWorkDate) {
    // Your logic to create a task in the calendar goes here
    // This is a placeholder function - replace with your actual calendar task creation logic
    console.log("Creating calendar task for:", futureWorkText, "on", futureWorkDate);
}




// Function to add the event to the calendar
function addEventToCalendar(clientName, futureWorkDate, futureWorkContent) {
    // Adjust this function call to match your existing addEventToCalendar logic
    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
    }).addEventToCalendar(clientName, futureWorkDate, futureWorkContent);
}

function addEventToRickyCalendar(clientName, futureWorkDate, futureWorkContent) {
    // Adjust this function call to match your existing addEventToCalendar logic
    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
    }).addEventToRickyCalendar(clientName, futureWorkDate, futureWorkContent);
}


function toggleDateInput() {
        var userSelection = document.getElementById('userSelection').value;
        var clientSelected = document.getElementById('clientSelect').value;
        var dateInputContainer = document.getElementById('dateInputContainer');

        // Check if a client is selected and user is "JB"
        if (clientSelected && userSelection === 'JB') {
            dateInputContainer.style.display = 'block';
        } else {
            dateInputContainer.style.display = 'none';
        }
    }


  google.charts.load('current', {'packages':['corechart']});
  google.charts.setOnLoadCallback(drawChart);
  
function drawChart() {
  google.script.run.withSuccessHandler(function(chartData) {
    var data = google.visualization.arrayToDataTable(chartData);

    // Set chart options
    var options = {
  width: 900,
  height: 500,
  chartArea: { width: '100%', height: '85%' }, // Adjust if necessary
  pieSliceText: 'none',
  legend: 'none',
  tooltip: { textStyle: { fontSize: 12 }, isHtml: true, trigger: 'focus' },
  titleTextStyle: {
    fontSize: 14, // Try reducing the font size
    color: '#333',
    bold: true,
    italic: false
  },
  // ... other options ...
};


    // Instantiate and draw the chart
    var chart = new google.visualization.PieChart(document.getElementById('piechart'));
    chart.draw(data, options);
  }).getClientCategoriesForPieChart();
}



function drawHeatmap(weekdayCounts) {
  // Define the correct order of weekdays, starting from Sunday or Monday
  var daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  // Convert weekdayCounts to an array and sort by the daysOrder
  var sortedData = daysOrder.map(day => {
    return [day, weekdayCounts[day] || 0]; // Fallback to 0 if no data for the day
  });

  // Now create the DataTable using the sorted data
  var data = new google.visualization.DataTable();
  data.addColumn('string', 'Weekday');
  data.addColumn('number', 'Past Notes');
  sortedData.forEach(function(row) {
    data.addRow(row);
  });

  // Define the chart options
  var options = {
    title: 'Client Interactions Per Weekday',
    hAxis: {title: 'Weekday'},
    vAxis: {title: 'Number of Interactions'}
  };

  // Draw the chart
  var chart = new google.visualization.ColumnChart(document.getElementById('heatmap'));
  chart.draw(data, options);
}

var futureChart = new google.visualization.ColumnChart(document.getElementById('futureHeatmap'));
futureChart.draw(futureData, options);

// Function to get data and draw the heatmap
function getAndDrawHeatmapData() {
    // Call server-side function to get data
    google.script.run.withSuccessHandler(drawHeatmap).getWeekdayCountsForHeatmap();
}

// Updated function to get data and draw the heatmap for future notes
function getAndDrawFutureHeatmapData() {
    // Call server-side function to get data for future notes
    google.script.run.withSuccessHandler(drawFutureHeatmap).getFutureWeekdayCountsForHeatmap();
}

function drawFutureHeatmap(weekdayCounts) {
  // Define the correct order of weekdays, starting from Sunday or Monday
  var daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  // Convert weekdayCounts for future notes to an array and sort by daysOrder
  var sortedData = daysOrder.map(day => {
    return [day, weekdayCounts[day] || 0]; // Fallback to 0 if no data for the day
  });

  // Create the DataTable using the sorted data
  var data = new google.visualization.DataTable();
  data.addColumn('string', 'Weekday');
  data.addColumn('number', 'Future Notes');
  sortedData.forEach(function(row) {
    data.addRow(row);
  });

  // Define the chart options for the future notes heatmap
  var options = {
    title: 'Future Client Interactions Per Weekday',
    hAxis: {title: 'Weekday'},
    vAxis: {title: 'Number of Future Notes'},
    colors: ['#1E90FF'], // Custom color for the bars, change as needed
    // Additional styling options can be added here
  };

  // Draw the chart in the 'futureHeatmap' div
  var chart = new google.visualization.ColumnChart(document.getElementById('futureHeatmap'));
  chart.draw(data, options);
}

function loadAllHeatmaps() {
    getAndDrawHeatmapData();
    getAndDrawFutureHeatmapData();
}


    function drawScatterPlot() {
        google.script.run.withSuccessHandler(function(chartData) {
            var data = google.visualization.arrayToDataTable(chartData);
            var options = {
    title: '', // Remove chart title
    hAxis: {
        title: 'Category',
        titleTextStyle: {
            fontSize: 0 // Font size for hAxis title
        }
    },
    vAxis: {
        title: 'Interactions',
        titleTextStyle: {
            fontSize: 0 // Font size for vAxis title
        }
    },
    legend: 'none'
};



            var chart = new google.visualization.ScatterChart(document.getElementById('scatter_chart_div'));
            chart.draw(data, options);
        }).getDataForScatterPlot();
    }


function displayTable() {
    google.script.run.withSuccessHandler(buildTable).generateTable();
  }

 function buildTable(data) {
    var values = data.values;
    var backgrounds = data.backgrounds;

    var rowHeight = '20px'; // You can adjust this value as needed
    var html = '<table style="border-collapse: collapse; width: auto; font-size: 9px; margin: 0 auto;">';

    for (var i = 0; i < values.length; i++) {
        html += `<tr style="height: ${rowHeight};">`;
        for (var j = 0; j < values[i].length; j++) {
            var cellValue = values[i][j];
            // Ensure cellValue is a string and check if it's numeric
            var isNumeric = /^-?\d+$/.test(cellValue.toString().trim());
            var formattedValue = cellValue;
            if (isNumeric) {
                // Format as dollar value without cents
                formattedValue = parseFloat(cellValue).toLocaleString('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                });
            }

            // Apply right-align for columns B and D
            var textAlignStyle = (j === 1 || j === 4) ? 'text-align: right;' : 'text-align: center;';

            // Make cell A1 bold
            var fontWeightStyle = (i === 0 && j === 0) ? 'font-weight: bold;' : '';

            html += '<td style="padding: 4px 6px; background-color:' + backgrounds[i][j] + 
                    '; line-height: normal; ' + textAlignStyle + fontWeightStyle + 
                    ' vertical-align: middle;">' + formattedValue + '</td>';
        }
        html += '</tr>';
    }

    html += '</table>';
    document.getElementById('tableContainer').innerHTML = html;
}















  window.onload = displayData;

function displayBirthdays() {
  var topClientsTitle = document.getElementById('topClientsTitle');
  var clientsDisplay = document.getElementById('topClientsDisplay');

  // Clear existing content
  clientsDisplay.innerHTML = '';
  topClientsTitle.innerHTML = '<u>BIRTHDAYS</u>';

  // Fetch clients with birthdays from the server
  showLoadingBar(); // Optional: Show loading indicator
  google.script.run.withSuccessHandler(function(clients) {
    hideLoadingBar(); // Hide loading indicator

    var currentMonth = new Date().getMonth() + 1; // Months are 0-indexed, so add 1

    // Separate clients into currentMonthClients and restOfYearClients
    var currentMonthClients = [];
    var restOfYearClients = [];
    var clientsWithoutBirthdays = [];

    clients.forEach(function(client) {
      if (client.birthday) {
        if (client.month === currentMonth) {
          currentMonthClients.push(client);
        } else {
          restOfYearClients.push(client);
        }
      } else {
        clientsWithoutBirthdays.push(client);
      }
    });

    // Display current month clients
    showClients(currentMonthClients, clientsDisplay);

    // Create REST OF THE YEAR button if there are more clients
    if (restOfYearClients.length > 0) {
      var restButton = document.createElement('button');
      restButton.id = 'restOfYearButton';
      restButton.textContent = 'REST OF THE YEAR';
      restButton.className = 'secondary-button';
      clientsDisplay.appendChild(restButton);

      var restClientsContainer = document.createElement('div');
      restClientsContainer.style.display = 'none'; // Hide initially
      clientsDisplay.appendChild(restClientsContainer);

      restButton.onclick = function() {
        if (restClientsContainer.style.display === 'none') {
          restClientsContainer.style.display = 'block';
          restButton.textContent = 'HIDE REST OF THE YEAR';
          showClients(restOfYearClients, restClientsContainer);
        } else {
          restClientsContainer.style.display = 'none';
          restButton.textContent = 'REST OF THE YEAR';
        }
      };
    }

    // Display clients without birthdays at the end
    if (clientsWithoutBirthdays.length > 0) {
      clientsDisplay.appendChild(document.createElement('hr'));
      showClients(clientsWithoutBirthdays, clientsDisplay);
    }
  }).getClientsWithBirthdays();
}

function showClients(clients, container) {
  clients.forEach(function(client) {
    var clientDiv = document.createElement('div');
    clientDiv.style.cssText = "font-size: 16px; margin-bottom: 10px; position: relative;";

    // Create a button for the client name
    var clientNameButton = document.createElement('button');
    clientNameButton.className = 'inline-button client-button';
    clientNameButton.innerText = client.name;
    clientNameButton.onclick = function() {
      selectClientFromButton(client.name);
    };
    clientDiv.appendChild(clientNameButton);

    // Display birthday
    var birthdaySpan = document.createElement('span');
    birthdaySpan.style.cssText = "margin-left: 10px;";
    if (client.birthday) {
      var month = client.month;
      var day = client.day;
      var formattedBirthday = (month < 10 ? '0' + month : month) + '/' + (day < 10 ? '0' + day : day);
      birthdaySpan.textContent = ' - ' + formattedBirthday;
    } else {
      birthdaySpan.textContent = ' - Unknown Birthday';
    }
    clientDiv.appendChild(birthdaySpan);

    container.appendChild(clientDiv);
    container.appendChild(document.createElement('hr'));
  });
}





function showTodaysTasks() {
    var displayAreaId = 'todaysTasksDisplay';
    var displayArea = document.getElementById(displayAreaId);

    if (displayArea.style.display === 'none' || displayArea.style.display === '') {
        showLoadingBar();

        google.script.run.withSuccessHandler(function(data) {
            displayTasksToday(data, displayAreaId, 'TODAY'); // Display tasks as before
            // createClientButtons(data.clients); // Create buttons for each client
            hideLoadingBar();
        }).getTasksForDay(0);
    } else {
        displayArea.style.display = 'none';
    }
}

function createClientButtons(clients) {
    var displayArea = document.getElementById('todaysTasksDisplay');
    // Add a style to align items to the left
    displayArea.style.textAlign = 'left';

    clients.forEach(function(client) {
        var button = document.createElement('button');
        button.innerText = client;
        button.onclick = function() {
            loadClient(client.split(' - ')[0]); // Assuming client name is before the '-'
            scrollToTop();
        };
        displayArea.appendChild(button);
    });
}


function loadClient(clientName) {
    console.log("loadClient called with:", clientName); // Log the client name passed to the function

    var clientSelect = document.getElementById('clientSelect');
    var options = Array.from(clientSelect.options);
    var clientOption = options.find(option => option.text === clientName);

    if (clientOption) {
        console.log("Matching option found:", clientOption.text); // Log if a matching option is found
        clientSelect.value = clientOption.value;
    } else {
        console.log("No matching option found for:", clientName); // Log if no matching option is found
        var newOption = new Option(clientName, clientName);
        clientSelect.add(newOption);
        clientSelect.value = clientName;
    }

    showClientNotes();
}





function displayTasksToday(data, displayAreaId, datePrefix) {
    var datePrefix = 'OVER THE NEXT 10 DAYS';
  var formattedDate = getFormattedDate(0);
  var clients = data.clients; // Assuming 'clients' contains the list of client names from column A
  displayAppointmentsOnly(data, displayAreaId, datePrefix, formattedDate, clients);
}





function displayAppointmentsOnly(data, displayAreaId, datePrefix, clients) {
  var displayArea = document.getElementById(displayAreaId);

  // Update the displayArea innerHTML with the date
  displayArea.innerHTML = `<strong>APPOINTMENTS ${datePrefix}:</strong><br>`;

  // Filter to keep only appointments
  var appointments = data.calendarEvents.filter(event => event.startsWith('APPOINTMENT:'));

  // Display appointments
  if (appointments.length > 0) {
    appointments.forEach(function(appointment) {
      var appointmentDetails = appointment.match(/APPOINTMENT: (.*?) - (.+? to .+?) -/);
      if (appointmentDetails && appointmentDetails.length > 2) {
        var timeRange = appointmentDetails[2].split(' to ');
        var eventDate = new Date(timeRange[0]);
        var weekday = eventDate.toLocaleDateString(undefined, { weekday: 'long' });
        var day = eventDate.toLocaleDateString(undefined, { day: 'numeric', month: 'long' });

        var startTime = formatDateToHHMM(timeRange[0]);
        var endTime = formatDateToHHMM(timeRange[1]);

        var clientName = appointmentDetails[1];
        var isHighlighted = clients.includes(clientName) ? 'highlighted' : '';

        displayArea.innerHTML += `<div class="${isHighlighted}">${weekday}, ${day} - ${clientName} - ${startTime} to ${endTime}</div>`;
      }
    });
  } else {
    displayArea.innerHTML += 'NONE<br>';
  }

  // Ensure the content is displayed
  displayArea.style.display = 'block';
}







function formatDateToHHMM(timeString) {
  const time = timeString.match(/(\d+):(\d+)/);
  if (!time) return 'Invalid Time';

  let hours = parseInt(time[1], 10);
  const minutes = parseInt(time[2], 10);

  // Convert 24-hour time to 12-hour format
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  hours = hours ? hours : 12; // the hour '0' should be '12'

  return hours + ':' + minutes.toString().padStart(2, '0') + ' ' + ampm;
}



function getFormattedDate(offset) {
  var date = new Date();
  date.setDate(date.getDate() + offset);
  var dd = String(date.getDate()).padStart(2, '0');
  var mm = String(date.getMonth() + 1).padStart(2, '0');
  return mm + '/' + dd;
}

function updateCategoryLabel() {
    var clientSelect = document.getElementById('clientSelect');
    var categorySelect = document.getElementById('categorySelect');
    var selectedOption = clientSelect.options[clientSelect.selectedIndex];

    if (clientSelect.value) {
        // Extract client name and category from the selected option
        var clientName = selectedOption.value;
        var rawText = selectedOption && selectedOption.textContent ? selectedOption.textContent : '';
        var split = rawText.split(' (');
        var clientCategory = split.length > 1 ? split[1].slice(0, -1) : '';
        var effectiveCategory = clientCategory || __currentCategory || '';

        // Overlay the dropdown with the current category so it sits on top of the "(Category)" text
        setCategoryPlaceholderText(effectiveCategory);
        positionCategoryDropdownOverAutocomplete();
    } else {
        // Set the placeholder text when no client is selected and hide the overlay
        setCategoryPlaceholderText('');
        hideCategoryOverlay();
    }
}

function setCategoryPlaceholderText(text) {
    var categorySelect = document.getElementById('categorySelect');
    if (!categorySelect) return;

    var fallbackFromClient = (function() {
        var clientSel = document.getElementById('clientSelect');
        if (!clientSel || !clientSel.value || !clientSel.selectedOptions.length) return '';
        var raw = clientSel.selectedOptions[0].textContent || '';
        var parts = raw.split(' (');
        return parts.length > 1 ? parts[1].replace(/\)$/, '') : '';
    })();

    if (categorySelect.options.length === 0) {
        var placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        categorySelect.appendChild(placeholderOption);
    }

    var effectiveText = (text || '').trim() || __currentCategory || fallbackFromClient || '‚ñº';
    if (effectiveText) {
        __currentCategory = effectiveText;
    }
    categorySelect.options[0].text = effectiveText;
}

function hideCategoryOverlay() {
    var overlay = document.getElementById('categoryChangeSection');
    if (overlay) {
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
    }
}

function positionCategoryDropdownOverAutocomplete() {
    var overlay = document.getElementById('categoryChangeSection');
    var categorySelect = document.getElementById('categorySelect');
    var clientSelect = document.getElementById('clientSelect');
    if (!overlay || !categorySelect || !clientSelect) return;

    if (!clientSelect.value) {
        hideCategoryOverlay();
        return;
    }

    overlay.style.display = 'block';
    overlay.setAttribute('aria-hidden', 'false');
}




function populateLabelsDropdown(labels) {
    var dropdown = document.getElementById('labelsDropdown');
    dropdown.innerHTML = ''; // Clear existing options

    // Add a disabled and selected placeholder option at the beginning
    var placeholderOption = document.createElement('option');
    placeholderOption.value = "";
    placeholderOption.textContent = "ADD";
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    dropdown.appendChild(placeholderOption);
    // Define the only label options that should be available
    var fixedLabels = ["NEW LABEL", "üéÇ", "üíª"];

    fixedLabels.forEach(function(label) {
        var option = document.createElement('option');
        option.value = label;
        option.textContent = label;
        dropdown.appendChild(option);
    });
}





function addLabelToClient(label) {
    var clientSelect = document.getElementById('clientSelect');
    var clientName = clientSelect.value;

    if (label === "NEW LABEL") {
        // Prompt user to enter the new label name
        var newLabel = prompt("Please enter the new label name:");
        if (newLabel) {
            // Call server-side function to add the new label to the client
            google.script.run.withSuccessHandler(function() {
                alert("New label added successfully!");
                showClientNotes(); // Refresh to show the new label
            }).addLabelToClient(clientName, newLabel);
        }
    } else {
        // Existing logic to add existing label to client
        google.script.run.withSuccessHandler(function() {
            alert("Label added successfully!");
            showClientNotes(); // Refresh to show the added label
        }).addLabelToClient(clientName, label);
    }
}



function refreshClientDetails(clientName) {
  // Implement the logic to refresh client details here.
  // This could be a call to the function that initially loads the client details.
  showClientNotes(); // Example: Refresh client notes or any other relevant information
}


document.getElementById('loadNotesButton').addEventListener('click', function() {
    showLoadingBar(); // Start loading as soon as the button is clicked
    displayTodayNotes(notes); // Assuming 'notes' is your data source
});

function displayTodayNotes(notes) {
    var displayArea = document.getElementById('notesDisplayArea');

    if (displayArea.style.display === 'none' || displayArea.style.display === '') {
        var formattedNotes = notes.map(function(item) {
            var noteDisplay = item.isPastNote ? '‚≠ê ' + item.note : item.note;
            return noteDisplay.replace(/\n/g, '<br>');
        }).join('<br><br>');

        displayArea.innerHTML = formattedNotes;
        displayArea.style.display = 'block';
    } else {
        displayArea.style.display = 'none';
    }

    hideLoadingBar(); // Hide the loading bar after rendering the notes
}


// REPLACEMENT: populateCategoryDropdown ‚Äî fills #categorySelect with unique Column F values (A‚ÜíZ)
function populateCategoryDropdown(categories) {
  var sel = document.getElementById('categorySelect');
  if (!sel) return;

  sel.innerHTML = '';

  var ph = document.createElement('option');
  ph.value = '';
  ph.textContent = __currentCategory || '';
  sel.appendChild(ph);

  (categories || []).forEach(function (cat) {
    var opt = document.createElement('option');
    opt.value = cat;
    opt.textContent = cat;
    sel.appendChild(opt);
  });

  var newOpt = document.createElement('option');
  newOpt.value = '__NEW__';
  newOpt.textContent = 'NEW CATEGORY‚Ä¶';
  sel.appendChild(newOpt);

  // üîß One unified handler for both cases
  if (!sel._wiredChange) {
    sel.addEventListener('change', function () {
      if (this.value === '__NEW__') {
        this.value = '';
        openNewCategoryModal();
        return;
      }
      if (this.value) {
        updateCategory();                 // <- saves to sheet
        if (typeof updateCategoryLabel === 'function') updateCategoryLabel();
      }
    });
    sel._wiredChange = true;
  }
}




// Call the function at the end of the script to automatically execute it on page load
// displayTopClients();

function updateClientColumnBFromNotes(newValue) {
  var clientName = document.getElementById('clientSelect').value;

  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
retriggerTopClientsFilter();


    })
    .withFailureHandler(function(error) {
      hideLoadingBar();
      alert('Failed to update Column B: ' + error);
    })
    .updateClientColumnB(clientName, newValue);
}

function updateClientColumnDFromNotes(newValue) {
  var clientName = document.getElementById('clientSelect').value;

  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // Refresh the top clients display
retriggerTopClientsFilter();


    })
    .withFailureHandler(function(error) {
      hideLoadingBar();
      alert('Failed to update Column D: ' + error);
    })
    .updateClientColumnD(clientName, newValue);
}




function saveClientData(clientName, newData) {
    showLoadingBar(); // Optionally show a loading indicator

    google.script.run.withSuccessHandler(function() {
        hideLoadingBar(); // Hide loading bar on success
        alert('Data saved successfully.'); // Notify the user
retriggerTopClientsFilter();

    }).updateClientData(clientName, newData); // Implement this Google Apps Script function
}

function toggleAdvanced() {
    var container = document.getElementById('advancedContainer');
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function toggleGraphs() {
    var container = document.getElementById('graphsContainer');
    container.style.display = container.style.display === 'none' ? 'block' : 'none';
}

function filterClients(day) {
  google.script.run.withSuccessHandler(displayClients).getTopClientsByDay(day);
}

function displayClients(clients) {
  const displayArea = document.getElementById('clientDisplay');
  displayArea.innerHTML = ''; // Clear previous entries
  clients.forEach(client => {
    const clientDiv = document.createElement('div');

    // Create a span for the client name with a smaller font size
    const nameSpan = document.createElement('span');
    nameSpan.textContent = client.name;
    nameSpan.style.fontSize = 'small';  // Adjust the font size as needed

    // Create a span for the latest follow-up with a smaller font size
    const followUpSpan = document.createElement('span');
    followUpSpan.textContent = `: ${client.latestFollowUp}`;
    followUpSpan.style.fontSize = 'small'; // Adjust the font size as needed

    // Append both spans to the div
    clientDiv.appendChild(nameSpan);
    clientDiv.appendChild(followUpSpan);

    displayArea.appendChild(clientDiv);
  });
}

function hideClientNotes() {
  // Capture the currently open client name BEFORE we clear/reset anything
  var clientSelectEl = document.getElementById('clientSelect');
  var justHiddenClient =
    (clientSelectEl && clientSelectEl.value) ? clientSelectEl.value :
    (typeof currentClientName !== 'undefined' && currentClientName) ? currentClientName : '';

  // Hide the client notes area
  var notesDisplayEl = document.getElementById('notesDisplay');
  if (notesDisplayEl) {
    notesDisplayEl.innerHTML = '';
    notesDisplayEl.style.display = 'none';
  }

  // Hide all related UI sections
  var idsToHide = [
    'workSectionsContainer',
    'pastWorkSection',
    'categoryChangeSection',
    'addAppointmentBtn',
    'labelsAdditionSection',
    'hideClientNotesBtn'
  ];
  idsToHide.forEach(function(id){
    var el = document.getElementById(id);
    if (el && el.style) el.style.display = 'none';
  });

  if (typeof closeAppointmentModal === 'function') {
    closeAppointmentModal();
  }

  // Safety: Future Work section should stay hidden if it still exists
  var fw = document.getElementById('futureWorkSection');
  if (fw) fw.style.display = 'none';

  // Clear labels
  var labelsDisplayEl = document.getElementById('labelsDisplay');
  if (labelsDisplayEl) labelsDisplayEl.innerHTML = '';

  // Reset autocomplete input
  var clientAutocomplete = document.getElementById('clientAutocomplete');
  if (clientAutocomplete) {
    clientAutocomplete.value = '';
    clientAutocomplete.style.color = '';
  }

  // Clear loaded in-progress area
  var loadedArea = document.getElementById('loadedInProgressArea');
  if (loadedArea) loadedArea.value = '';

  // Clear chip data (columns P and Q)
  window.__chipForCurrentClient = { initials: '', date: '' };

  // Clear category selection
  var catSel = document.getElementById('categorySelect');
  if (catSel) catSel.value = '';

  // Clear past work input
  var pastWorkEl = document.getElementById('newPastWork');
  if (pastWorkEl) pastWorkEl.value = '';

  // Reset current client globals & dropdown last (after we captured justHiddenClient)
  if (typeof currentClientName !== 'undefined') currentClientName = '';
  if (clientSelectEl) clientSelectEl.value = '';

  // === New: update the recent chips ONLY when hiding ===
  if (justHiddenClient) {
    if (typeof updateRecentsOnHide === 'function') {
      updateRecentsOnHide(justHiddenClient);
    } else {
      // Minimal inline fallback if the recents manager wasn't added yet:
      window.__recentClients = window.__recentClients || [];
      var norm = justHiddenClient.toLowerCase();
      window.__recentClients = window.__recentClients.filter(function(n){
        return String(n).toLowerCase() !== norm;
      });
      window.__recentClients.unshift(justHiddenClient);
      window.__recentClients = window.__recentClients.slice(0, RECENT_CACHE_LIMIT);
      if (typeof renderRecentClientsBar === 'function') renderRecentClientsBar();
    }
  }
}



    // Show Add New Client Modal
function displayAddNewClientModal() {
    // Open the modal
    var modal = document.getElementById('addClientModal');
    var modalContent = document.getElementById('addClientModalContent');
    modal.style.display = 'block';

    // Clear the modal content
    modalContent.innerHTML = '';

    // Add content to modal for Client Name input
    var clientNameLabel = document.createElement('label');
    clientNameLabel.textContent = 'Client Name:';
    var clientNameInput = document.createElement('input');
    clientNameInput.type = 'text';
    clientNameInput.id = 'modalClientName';
    clientNameInput.style.width = '100%';

    var nextButton = document.createElement('button');
    nextButton.textContent = 'Next';
    nextButton.onclick = function() {
        var clientName = clientNameInput.value.trim();
        if (!clientName) {
            alert('Please enter a client name.');
            return;
        }
        // Proceed to Category selection
        showCategorySelection(clientName);
    };

    modalContent.appendChild(clientNameLabel);
    modalContent.appendChild(clientNameInput);
    modalContent.appendChild(nextButton);
}

// Function to show Category selection
function showCategorySelection(clientName) {
    var modalContent = document.getElementById('addClientModalContent');
    modalContent.innerHTML = '';

    var categoryLabel = document.createElement('label');
    categoryLabel.textContent = 'Category:';
    var categorySelect = document.createElement('select');
    categorySelect.id = 'modalClientCategory';
    categorySelect.style.width = '100%';

    // Populate category options
    var categories = [
        '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê',
        '‚≠ê‚≠ê‚≠ê‚≠ê',
        '‚≠ê‚≠ê‚≠ê',
        '‚≠ê‚≠ê',
        '‚≠ê',
    ];

    categories.forEach(function(category) {
        var option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
    });

    var submitButton = document.createElement('button');
    submitButton.textContent = 'Submit';
    submitButton.onclick = function() {
        var category = categorySelect.value;
        // Proceed to submit the new client
        submitNewClientModal(clientName, category);
    };

    modalContent.appendChild(categoryLabel);
    modalContent.appendChild(categorySelect);
    modalContent.appendChild(submitButton);
}

function submitNewClientModal(clientName, category) {
    // Close the modal
    var modal = document.getElementById('addClientModal');
    modal.style.display = 'none';

    // Prepare the data
    var futureWorkNote = ''; // Set empty if not collecting
    var pastWork = '';

    // Call the existing function to submit the new client
    google.script.run.withSuccessHandler(function(response) {
        alert('New client added: ' + clientName); // Notify success
        alert('PLEASE ADD FUTURE WORK IN ORDER FOR NEW CLIENT TO ENTER DASHBOARD WORKFLOW');

        // **Show the loading bar after the alerts**
        showLoadingBar();

        // Now set Column B to 'STRICT' for the new client
        google.script.run.withSuccessHandler(function(){
            // Refresh clientsData and the dropdown
            google.script.run.withSuccessHandler(function(data){
                clientsData = data;
                populateClientDropdown(clientsData);

                // Now select the new client in the dropdown
                var clientSelect = document.getElementById('clientSelect');
                var clientAutocomplete = document.getElementById('clientAutocomplete');

                for (var i = 0; i < clientSelect.options.length; i++) {
                    if (clientSelect.options[i].value === clientName) {
                        clientSelect.selectedIndex = i;
                        clientAutocomplete.value = clientSelect.options[i].text;
                        break;
                    }
                }
                // Now call showClientNotes()
                showClientNotes();
            }).getAllClientsData();
        }).updateClientColumnB(clientName, 'STRICT');
    }).addNewClientWithPastWork(clientName, futureWorkNote, category, pastWork);
}




// Function to close the modal
function closeAddClientModal() {
    var modal = document.getElementById('addClientModal');
    modal.style.display = 'none';
}

/**********************************************
REPLACE ENTIRE displayClient FUNCTION WITH THIS
**********************************************/
/**********************************************
  READ-ONLY Top Clients renderer
  - No inline note editing in the list
  - Chip is read-only in the list
  - Editing remains in client details after selecting a client
**********************************************/
/**********************************************
  READ-ONLY Top Clients renderer (keeps original layout)
  + Adds green Ricky‚Äôs Suggestion block (hidden by default)
**********************************************/
function displayClient(client, container) {
  // Card wrapper (keep your existing task-display sizing)
  var clientDiv = document.createElement('div');
  clientDiv.className = 'task-display';
  clientDiv.style.display = 'flex';
  clientDiv.style.flexDirection = 'column';
  clientDiv.style.alignItems = 'flex-start';
  clientDiv.style.marginBottom = '10px';

  /* ‚îÄ‚îÄ Top row: Client button ONLY (no day-of-week dropdown in Top Clients list) ‚îÄ‚îÄ */
  var topRow = document.createElement('div');
  topRow.style.cssText = "display:flex; align-items:center; justify-content:center; width:100%;";

  var clientButton = document.createElement('button');
  clientButton.className = 'inline-button client-button';
  clientButton.innerText = client.name + (client.category ? ' (' + client.category + ')' : '');
  clientButton.style.cssText = "display:inline-flex; align-items:center;";
  clientButton.addEventListener('click', function () {
    // prime chip cache so details view shows same chip
    window.__chipForCurrentClient = {
      initials: (client.chipInitials || '').toUpperCase(),
      date: normalizeChipDate(client.chipDate || '')
    };
    selectClientFromButton(client.name);
  });
  topRow.appendChild(clientButton);

  clientDiv.appendChild(topRow);

  /* ‚îÄ‚îÄ Notes highlight section (read-only in list) ‚îÄ‚îÄ */
  var allC = [];
  (client.pastWorks || []).forEach(function(pw){
    String(pw || '').split('\n').forEach(function(line){
      var t = (line || '').trim();
      if (t) allC.push(t);
    });
  });

  if (allC.length > 0) {
    function parseMDY(line){
      var m = String(line).match(/\b(\d{1,2})\/(\d{1,2})\/(\d{2,4})\b/);
      if (!m) return null;
      var mm=+m[1], dd=+m[2], yy=+m[3]; if (yy<100) yy+=2000;
      return new Date(yy, mm-1, dd);
    }
    function safeFormatNoteHTML(s){
      return typeof formatNoteHTML === 'function' ? formatNoteHTML(s)
        : String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    var withDates=[], noDates=[];
    allC.forEach(function(line){
      var d=parseMDY(line);
      if(d) withDates.push({line,d}); else noDates.push({line});
    });
    withDates.sort(function(a,b){ return a.d - b.d; });
    var sorted = withDates.map(x=>x.line).concat(noDates.map(x=>x.line));

    var notesWrap = document.createElement('div');
    notesWrap.style.cssText = "display:flex; flex-direction:column; align-items:stretch; margin-top:5px; width:100%;";

    // Older notes container (remains hidden, and no MORE button in the list)
    var olderWrap = document.createElement('div');
    olderWrap.style.cssText = "display:none; flex-direction:column; gap:5px;";
    notesWrap.appendChild(olderWrap);

    // Highlighted (newest 3) container
    var hiWrap = document.createElement('div');
    hiWrap.style.cssText = "display:flex; flex-direction:column; gap:5px;";
    notesWrap.appendChild(hiWrap);

    var lastIdx = sorted.length - 1;
    var hiCount = Math.min(3, sorted.length);
    var firstHi = lastIdx - (hiCount - 1);

    sorted.forEach(function(line, i){
      var div = document.createElement('div');
      div.className = 'note-line';
      div.style.fontSize = '32px';
      div.style.marginBottom = '0px';
      div.innerHTML = safeFormatNoteHTML(line);

      if (i >= firstHi) {
        // HIGHLIGHTED
        div.classList.add('latest-note');
        div.style.backgroundColor = 'yellow';
        hiWrap.appendChild(div);

        // Newest line gets chip (read-only edit still opens chip editor if clicked)
        if (i === lastIdx) {
          var chipEl = createChipElement(
            client.name,
            (client.chipInitials || "").toUpperCase(),
            client.chipDate || ""
          );
          div.appendChild(chipEl);
        }
      } else {
        // OLDER ‚Äî stays hidden (no MORE button to reveal)
        div.classList.add('older-note');
        div.style.display = 'none';
        olderWrap.appendChild(div);
      }
    });

    // (list remains read-only)
    clientDiv.appendChild(notesWrap);
  }

  /* ‚îÄ‚îÄ Ricky‚Äôs Suggestion (Column L) ‚Äî green block; obeys global toggle; unchanged ‚îÄ‚îÄ */
  var sugWrap = document.createElement('div');
  sugWrap.className = 'toplist-suggestion';
  sugWrap.style.display = 'none'; // toggled by your existing toggleSuggestions()
  sugWrap.style.alignSelf = 'stretch';   // ensure it spans the whole card width
  sugWrap.setAttribute('data-client', client.name);

  var bulb = document.createElement('span');
  bulb.className = 'bulb';
  bulb.setAttribute('aria-hidden', 'true');
  bulb.textContent = 'üí°';
  sugWrap.appendChild(bulb);

  var ta = document.createElement('textarea');
  ta.className = 'note-textarea inProgressArea';
  ta.style.minHeight = '60px';
  ta.value = client.columnLContent || '';
  ta.setAttribute('data-client', client.name);
  ta.setAttribute('data-last-saved', ta.value || '');
  sugWrap.appendChild(ta);

  clientDiv.appendChild(sugWrap);

  /* ‚îÄ‚îÄ Thick divider like before ‚îÄ‚îÄ */
  var thickLine = document.createElement('hr');
  thickLine.style.cssText = "width:100%; border:3px solid black; margin:10px 0;";
  clientDiv.appendChild(thickLine);

  container.appendChild(clientDiv);

  // Respect current Suggestions toggle state
  if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
}



function updateCategorySelectValue(clientCategory) {
    var categorySelect = document.getElementById('categorySelect');
    if (!categorySelect) return;

    var normalizedCategory = (clientCategory || '').trim();

    // Ensure the category exists in the dropdown
    if (normalizedCategory) {
        var optionExists = Array.from(categorySelect.options).some(function(option) {
            return option.value === normalizedCategory;
        });

        // If not, add it to the dropdown
        if (!optionExists) {
            var newOption = document.createElement('option');
            newOption.value = normalizedCategory;
            newOption.textContent = normalizedCategory;
            categorySelect.appendChild(newOption);
        }

        __suppressCategoryChange = true;
        categorySelect.value = normalizedCategory;
        __suppressCategoryChange = false;

        __currentCategory = normalizedCategory;
        setCategoryPlaceholderText(__currentCategory);
        positionCategoryDropdownOverAutocomplete();
    } else {
        __suppressCategoryChange = true;
        categorySelect.value = '';
        __suppressCategoryChange = false;

        __currentCategory = '';
        setCategoryPlaceholderText(__currentCategory);
        hideCategoryOverlay();
    }
}


function displayTopClientsByCategory() {
    showLoadingBar(); // Optional: show loading indicator

    google.script.run.withSuccessHandler(function(clients) {
        var categoryCounts = {};

        // Define the same variables and logic used in showTopClients function
        var now = new Date();
        var sevenDaysFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now
        var todayIndex = now.getDay();
        var daysOfWeek = ['Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'];
        var todayDay = daysOfWeek[todayIndex];

        // Filter clients based on the 'strictPast' filter logic
        var filteredClients = clients.filter(function(client) {
            var latestDate = null;
            client.followUps.forEach(function(followUp) {
                var followUpLines = followUp.split('\n');
                followUpLines.forEach(function(line) {
                    var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
                    if (dates) {
                        var dateParts = dates[0].split('/');
                        var date = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
                        if (!latestDate || date > latestDate) {
                            latestDate = date;
                        }
                    }
                });
            });
            client.latestDate = latestDate; // Store the latestDate in client for sorting

            // Apply the same filtering conditions as in 'strictPast'
            return client.columnB === "STRICT" && latestDate && latestDate <= sevenDaysFromNow;
        });

        // Separate clients matching today and rest of the week
        var clientsMatchingToday = [];
        var otherClients = [];

        filteredClients.forEach(function(client) {
            if (client.columnD === todayDay) {
                clientsMatchingToday.push(client);
            } else {
                otherClients.push(client);
            }
        });

        // Combine clients to reflect the ones displayed on page load
        var strictPastClients = clientsMatchingToday.concat(otherClients);

        // Count categories from the combined list
        strictPastClients.forEach(function(client) {
            var category = client.category || 'Uncategorized';
            if (categoryCounts[category]) {
                categoryCounts[category]++;
            } else {
                categoryCounts[category] = 1;
            }
        });

        // Build the HTML content
        var content = '';
        for (var category in categoryCounts) {
            content += '<p>' + category + ': ' + categoryCounts[category] + '</p>';
        }

        // Display the modal with the content
        document.getElementById('categoriesModalContent').innerHTML = content;
        document.getElementById('categoriesModal').style.display = 'block';
        hideLoadingBar(); // Hide loading indicator
    }).getTopClients();
}



function closeCategoriesModal() {
    document.getElementById('categoriesModal').style.display = 'none';
}

function triggerTopClientsEmail() {
  // Show a quick "loading" bar if you want
  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      alert("Email summary sent successfully!");
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Failed to send email summary. Error: " + err.message);
    })
    .sendDailyTopClientsEmail();  // <-- Must match the function name in Code.gs
}

// This function creates a big star overlay, shows it for ~5s, then removes it
function showStarAnimation() {
  // Create the DIV
  var starDiv = document.createElement('div');
  starDiv.className = 'star-animation';
  document.body.appendChild(starDiv);

  // Remove after 5 seconds
  setTimeout(function() {
    if (starDiv && starDiv.parentNode) {
      starDiv.parentNode.removeChild(starDiv);
    }
  }, 2500);
}

/*******************************************************
 SNIPPET #3: Real-time ‚ÄúIn Progress‚Äù sync & save
*******************************************************/
/*******************************************************
 SNIPPET #3: Real-time ‚ÄúIn Progress‚Äù sync & save (UPDATED)
*******************************************************/

function onInProgressChange(clientName, newValue) {
  // Show the loading bar BEFORE calling the server
  showLoadingBar();

  // 1) Immediately call Apps Script to store in Column L
  google.script.run
    .withSuccessHandler(function() {
      // Hide the loading bar AFTER success
      hideLoadingBar();

      // 2) If successful, mirror that newValue into the loaded client area (if it‚Äôs the same client)
      updateInProgressDom(clientName, newValue);
    })
    .withFailureHandler(function(err) {
      // Hide the loading bar even if it fails
      hideLoadingBar();
      console.error("Failed to update column L:", err);
    })
    .updateClientData(clientName, newValue); // Reuses your existing updateClientData() in Code.gs
}

/* ===== REPLACEMENT: onInProgressLoadedBlur (no full refresh) ===== */
function onInProgressLoadedBlur(valueFromUI) {
  // Find current client name from the picker
  var clientName = (document.getElementById('clientSelect') || {}).value || '';
  if (!clientName) return; // nothing to save against

  var ta = document.getElementById('loadedInProgressArea');
  if (!ta) return;

  // Don‚Äôt do anything if text hasn't changed
  var newVal = String(valueFromUI || '');
  var oldVal = String(ta.getAttribute('data-last-saved') || '');
  if (newVal.trim() === oldVal.trim()) return;

  // Optional: tiny spinner cue at field level (keep your global bar too if you like)
  if (typeof showLoadingBar === 'function') showLoadingBar();

  google.script.run
    .withSuccessHandler(function () {
      // Lock in the new value locally, NO full re-render
      ta.setAttribute('data-last-saved', newVal);

      // Small inline ‚ÄúSaved‚Äù badge (reuse the helper you already have)
      if (typeof showInlineSavedBadge === 'function') showInlineSavedBadge(ta);

      if (typeof hideLoadingBar === 'function') hideLoadingBar();

            if (typeof updateInProgressDom === 'function') {
        updateInProgressDom(clientName, newVal);
      }


      // ‚úÖ DO NOT call displayTopClients(), showTopClients(), getTopClients(), etc. here

    })
    .withFailureHandler(function (err) {
      alert('Error saving In Progress: ' + (err && err.message ? err.message : err));
      // Revert UI to the last saved text
      ta.value = oldVal;
      if (typeof hideLoadingBar === 'function') hideLoadingBar();
    })
    // ‚¨áÔ∏è change to your server function name if different
    .updateClientColumnL(clientName, newVal);
}
/* ===== END REPLACEMENT ===== */



// This function updates all ‚ÄúIn Progress:‚Äù textareas on the page for the given client
// so they match the newly saved value, WITHOUT reloading.
function updateInProgressDom(clientName, newValue) {
    var normalizedValue = newValue == null ? '' : String(newValue);

  // 1) If the loaded client is the same, update the loadedInProgressArea
var selectEl = document.getElementById('clientSelect');
  var currentlySelected = selectEl ? selectEl.value : '';
    if (currentlySelected === clientName) {
    var loadedText = document.getElementById('loadedInProgressArea');
   if (loadedText && loadedText.value !== normalizedValue) {
      loadedText.value = normalizedValue;
    }
    if (loadedText) {
      loadedText.setAttribute('data-last-saved', normalizedValue);
    }
  }

  // 2) Update the ‚ÄúIn Progress:‚Äù textareas in the top clients list
  //    (They have .className = "inProgressArea" plus a data-client attribute)
  var allAreas = document.querySelectorAll('.inProgressArea[data-client="' + clientName + '"]');
  allAreas.forEach(function(area) {
    if (area.value !== normalizedValue) {
      area.value = normalizedValue;
    }
        area.setAttribute('data-last-saved', normalizedValue);

  });
}
// UPDATED: Handle JB / RB / QC filters and update topClientsTitle


function handleTopClientsFilterChange(selectedFilter) {
  var titleEl = document.getElementById('topClientsTitle');
  var val = normalizeFilterValue(selectedFilter);

  // Title updates (owners & ALL only)
  if (['JB','RB','QC','TEAM','BDAY'].includes(val)) {
    titleEl.innerText = val;
  } else if (val === 'ALL') {
    titleEl.innerText = 'TOP CLIENTS';
  } else {
    // For text or emoji filters we keep the date-only header per your current UI
    if (titleEl) { titleEl.innerText = ''; titleEl.style.display = 'none'; }
  }

  // Always pull the latest list, then filter client-side
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function(clients){
      var filtered = clients || [];
      var emoji = asEmojiOrNull(val);

      if (val === 'ALL') {
        // no-op
      } else if (isOwnerKey(val)) {
        // Owner filter = exact initials match
        var target = val.toUpperCase();
        filtered = filtered.filter(function(c){
          return String(c.chipInitials || c.initials || '').toUpperCase() === target;
        });
      } else if (emoji) {
        // Emoji filter = look inside Column L (suggestions/lightbulb)
        filtered = filtered.filter(function(c){
          return suggestionsContainEmoji(c, emoji);
        });
      } else {
        // Text filter = look inside Column P (chip text)
        var needle = val.toLowerCase();
        filtered = filtered.filter(function(c){
          return chipSearchString(c).includes(needle);
        });
      }

      showTopClients(filtered, 'all');
      hideLoadingBar();

      // Keep the dropdown visually in sync
      var dd = document.getElementById('topClientsFilterDropdown');
      if (dd) dd.value = selectedFilter;
    })
    .withFailureHandler(function(err){
      hideLoadingBar();
      alert('Failed to filter top clients: ' + (err && err.message ? err.message : err));
    })
    .getTopClients();
}




function showTasksFromSpreadsheet() {
  // Show the container
  document.getElementById('updateTasksContainer').style.display = 'block';

  // Clear the current listing
  document.getElementById('tasksList').innerHTML = '';

  // Show loading bar
  showLoadingBar();

  // Call server function getTasksForDashboardIntegration() [defined in .gs snippet below]
  google.script.run
    .withSuccessHandler(function(tasksArray) {
      hideLoadingBar();

      if (!tasksArray || tasksArray.length === 0) {
        document.getElementById('tasksList').innerHTML =
          "<p>No tasks found in the Tasks spreadsheet.</p>";
        return;
      }

      tasksArray.forEach(function(taskObj, idx) {
        addTaskRowToDOM(taskObj, idx);
      });
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Failed to fetch tasks: " + err.message);
    })
    .getTasksForDashboardIntegration();
}

/**
 * Renders one row for a given task in the #tasksList div.
 */
function addTaskRowToDOM(taskObj, idx) {
  var container = document.getElementById('tasksList');

  // Outer wrapper
  var rowDiv = document.createElement('div');
  rowDiv.style.border = '1px solid #ccc';
  rowDiv.style.padding = '10px';
  rowDiv.style.marginBottom = '10px';
  rowDiv.id = 'taskRow_' + idx;

  // The raw task text
  var taskTitle = document.createElement('div');
  taskTitle.innerHTML = "<b>Task:</b> " + taskObj.fullTask;
  rowDiv.appendChild(taskTitle);
taskTitle.style.fontSize = '0.5em'; 

// Automatically fetch 5 matches (no guess button).
var namePart = extractNameFromTask(taskObj.fullTask);
fetchClosestMatches(namePart, function(matches) {
    showMatchesDropdown(rowDiv, matches, taskObj);
});


  // Spot to show the dropdown of matches
  var matchesDiv = document.createElement('div');
  matchesDiv.id = 'matchesDiv_' + idx;
  rowDiv.appendChild(matchesDiv);

  container.appendChild(rowDiv);
}

/**
 * Extract the first 2 or 3 words from the task, assuming "Name" is at the start of the text.
 */
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * FIXED extractNameFromTask
 * REMOVED logic around "for", "couple", "&", "and"
 * NOW returns the entire task string so we match any name
 ******************************************************/
function extractNameFromTask(fullTask) {
  if (!fullTask) return "";
  // This new version just returns the entire trimmed text
  // so name-finding can work on the full string.
  return fullTask.trim();
}






/**
 * Calls the server to find 5 closest matches in Dashboard 8.0 Column A.
 */
function fetchClosestMatches(namePart, callback) {
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function(matches) {
      hideLoadingBar();
      callback(matches);
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Error finding closest matches: " + err.message);
      callback([]); // fallback
    })
    .getClosestClients(namePart, 5); // We'll define getClosestClients() in Code.gs
}

//-----------------------------------------------
// showMatchesDropdown(rowDiv, matches, taskObj)
// REPLACE your entire old function with this
//-----------------------------------------------
function showMatchesDropdown(rowDiv, matches, taskObj) {
  /*1*/  var matchesDiv = rowDiv.querySelector('div[id^="matchesDiv_"]');
  /*2*/  matchesDiv.innerHTML = ''; // Clear any existing content

  /*3*/  if (!matches || matches.length === 0) {
  /*4*/    matchesDiv.innerHTML = '<p>No matches found.</p>';
  /*5*/    return; // Done if no matches
  /*6*/  }

  /*7*/  // We'll build a UL containing the normal matches
  /*8*/  var clientList = document.createElement('ul');
  /*9*/  clientList.style.listStyle = 'none';
  /*10*/ clientList.style.padding = '0';
  /*11*/ clientList.style.marginBottom = '5px';

  /*12*/ // We'll track which client is selected from among the normal 5
  /*13*/ var selectedClient = null;

  /*14*/ // Build the normal 5 matches as LI elements
  /*15*/ matches.forEach(function(clientName) {
  /*16*/   var li = document.createElement('li');
  /*17*/   li.innerText = clientName;
  /*18*/   li.style.cursor = 'pointer';
  /*19*/   li.style.padding = '4px 8px';
  /*20*/   li.style.border = '1px solid #ccc';
  /*21*/   li.style.borderRadius = '4px';
  /*22*/   li.style.marginBottom = '3px';
  /*23*/   li.style.fontSize = '0.33em';

  /*24*/   li.onclick = function() {
  /*25*/     // Remove highlighting from everything:
  /*26*/     Array.from(clientList.children).forEach(child => {
  /*27*/       child.style.backgroundColor = '';
  /*28*/       child.style.fontWeight = '';
  /*29*/     });
  /*30*/     // Highlight THIS <li>
  /*31*/     li.style.backgroundColor = '#e0e0e0';
  /*32*/     li.style.fontWeight = 'bold';
  /*33*/     // Set selectedClient
  /*34*/     selectedClient = clientName;
  /*35*/   };

  /*36*/   clientList.appendChild(li);
  /*37*/ }); 
  // AFTER this closing brace is where we'll paste the snippet

  /************************************************************
   SNIPPET: ADD THE 6TH "AUTOCOMPLETE" ROW
   PASTE THIS EXACT BLOCK AFTER LINE 37, BEFORE CONTINUING CODE
  ************************************************************/
  /*38*/ // === SNIPPET START: 6th suggestion (autocomplete) ===
  /*39*/ var li6 = document.createElement('li');
  /*40*/ li6.style.cursor = 'default';
  /*41*/ li6.style.padding = '4px 8px';
  /*42*/ li6.style.border = '1px solid #ccc';
  /*43*/ li6.style.borderRadius = '4px';
  /*44*/ li6.style.marginBottom = '3px';
  /*45*/ li6.style.fontSize = '0.33em';
  /*46*/ li6.style.backgroundColor = '#f9f9f9';
  /*47*/ li6.innerText = 'Enter any client name:'; // label at the top

  /*48*/ // The manual input
  /*49*/ var manualInput = document.createElement('input');
  /*50*/ manualInput.type = 'text';
  /*51*/ manualInput.style.width = '100%';
  /*52*/ manualInput.style.marginTop = '3px';
  /*53*/ manualInput.style.fontSize = '16px';
  /*54*/ manualInput.placeholder = 'Type to search all clients...';

  /*55*/ var isUsingManualChoice = false;     // true if user picks from 6th row
  /*56*/ var manualChosenClient = null;       // which client was chosen

  /*57*/ // subSuggestions container
  /*58*/ var subSuggestions = document.createElement('div');
  /*59*/ subSuggestions.style.position = 'relative';
  /*60*/ subSuggestions.style.backgroundColor = '#ffffff';
  /*61*/ subSuggestions.style.border = '1px solid #ccc';
  /*62*/ subSuggestions.style.marginTop = '2px';
  /*63*/ subSuggestions.style.zIndex = '9999';
  /*64*/ subSuggestions.style.display = 'none'; // hidden by default

  /*65*/ li6.appendChild(manualInput);
  /*66*/ li6.appendChild(subSuggestions);

  /*67*/ function highlightLi6() {
  /*68*/   // Clear highlight from the first 5
  /*69*/   Array.from(clientList.children).forEach(child => {
  /*70*/     child.style.backgroundColor = '';
  /*71*/     child.style.fontWeight = '';
  /*72*/   });
  /*73*/   // highlight this 6th row
  /*74*/   li6.style.backgroundColor = '#e0e0e0';
  /*75*/   li6.style.fontWeight = 'bold';
  /*76*/ }

  /*77*/ // oninput -> show sub-suggestions from global clientsData
  /*78*/ manualInput.addEventListener('input', function() {
  /*79*/   var partial = manualInput.value.trim().toLowerCase();
  /*80*/   subSuggestions.innerHTML = '';
  /*81*/   subSuggestions.style.display = 'none';

  /*82*/   if (!partial) {
  /*83*/     manualChosenClient = null;
  /*84*/     isUsingManualChoice = false;
  /*85*/     li6.style.backgroundColor = '#f9f9f9';
  /*86*/     li6.style.fontWeight = '';
  /*87*/     return;
  /*88*/   }

  /*89*/   // Filter from your global clientsData
  /*90*/   var matched = clientsData.filter(function(clientObj) {
  /*91*/     return clientObj.clientName.toLowerCase().includes(partial);
  /*92*/   });

  /*93*/   if (matched.length === 0) return;
  /*94*/   subSuggestions.style.display = 'block';
  /*95*/   subSuggestions.style.maxHeight = '180px';
  /*96*/   subSuggestions.style.overflowY = 'auto';

  /*97*/   matched.forEach(function(cObj) {
  /*98*/     var div = document.createElement('div');
  /*99*/     div.style.padding = '4px';
  /*100*/    div.style.cursor = 'pointer';
  /*101*/    div.style.borderBottom = '1px solid #eee';
  /*102*/    div.innerText = cObj.clientName + (cObj.category ? ' (' + cObj.category + ')' : '');
  /*103*/    div.onclick = function() {
  /*104*/      manualChosenClient = cObj.clientName;
  /*105*/      manualInput.value = div.innerText;
  /*106*/      subSuggestions.innerHTML = '';
  /*107*/      subSuggestions.style.display = 'none';
  /*108*/      isUsingManualChoice = true;
  /*109*/      highlightLi6();
  /*110*/    };
  /*111*/    subSuggestions.appendChild(div);
  /*112*/  });
  /*113*/ });

  /*114*/ // blur -> hide subSuggestions
  /*115*/ manualInput.addEventListener('blur', function() {
  /*116*/   setTimeout(function() {
  /*117*/     subSuggestions.innerHTML = '';
  /*118*/     subSuggestions.style.display = 'none';
  /*119*/   }, 200);
  /*120*/ });

  /*121*/ // We'll override the existing applyBtn.onclick to handle manual picks
  /*122*/ // But first, we need a reference to the existing applyBtn:
  //        We'll define applyBtn later below (lines ~161), so we‚Äôll "inject"
  //        the logic after we create it. We do so with a small trick shown below.
  /*123*/ 
  /*124*/ // We won't finalize li6 into the UL until after we define the rest.
  /*125*/ // === SNIPPET END: 6th suggestion ===

  /*126*/ // Now that we've built clientList, add it to matchesDiv
  /*127*/ matchesDiv.appendChild(clientList);

  /*128*/ // Build radio container for Past/Future
  /*129*/ var radioContainer = document.createElement('div');
  /*130*/ radioContainer.style.marginTop = '5px';
  /*131*/ radioContainer.style.fontSize = '12px';

  /*132*/ var pastRadio = document.createElement('input');
  /*133*/ pastRadio.type = 'radio';
  /*134*/ pastRadio.name = 'workType_' + rowDiv.id;
  /*135*/ pastRadio.value = 'PAST';
  /*136*/ pastRadio.id = 'past_' + rowDiv.id;
  /*137*/ pastRadio.checked = true;

  /*138*/ var pastLabel = document.createElement('label');
  /*139*/ pastLabel.htmlFor = pastRadio.id;
  /*140*/ pastLabel.innerText = 'Past Work';

  /*141*/ var futureRadio = document.createElement('input');
  /*142*/ futureRadio.type = 'radio';
  /*143*/ futureRadio.name = 'workType_' + rowDiv.id;
  /*144*/ futureRadio.value = 'FUTURE';
  /*145*/ futureRadio.id = 'future_' + rowDiv.id;

  /*146*/ var futureLabel = document.createElement('label');
  /*147*/ futureLabel.htmlFor = futureRadio.id;
  /*148*/ futureLabel.innerText = 'Future Work';

  /*149*/ radioContainer.appendChild(pastRadio);
  /*150*/ radioContainer.appendChild(pastLabel);
  /*151*/ radioContainer.appendChild(document.createTextNode('  '));
  /*152*/ radioContainer.appendChild(futureRadio);
  /*153*/ radioContainer.appendChild(futureLabel);

  /*154*/ matchesDiv.appendChild(radioContainer);

  /*155*/ // Build the APPLY button
  /*156*/ var applyBtn = document.createElement('button');
  /*157*/ applyBtn.innerText = 'APPLY';
  /*158*/ applyBtn.style.marginTop = '5px';
  /*159*/ applyBtn.style.fontSize = '18px';

  /*160*/ // Original applyBtn onclick
  /*161*/ var oldApplyClick = function() {
  /*162*/   if (!selectedClient) {
  /*163*/     alert('Please select a client.');
  /*164*/     return;
  /*165*/   }
  /*166*/   var chosenWorkType = pastRadio.checked ? 'PAST' : 'FUTURE';
  /*167*/   doApplyTaskToClient(selectedClient, chosenWorkType, taskObj, rowDiv.id);
  /*168*/ };

  /*169*/ applyBtn.onclick = function() {
  /*170*/   // If we used the 6th row
  /*171*/   if (isUsingManualChoice && manualChosenClient) {
  /*172*/     selectedClient = manualChosenClient;
  /*173*/   }
  /*174*/   // Then run the original logic
  /*175*/   oldApplyClick();
  /*176*/ };

  /*177*/ matchesDiv.appendChild(applyBtn);

  /*178*/ // Now that applyBtn is defined, we can finalize adding li6 to the UL
  /*179*/ clientList.appendChild(li6);

  // DONE
}


/**
 * Actually loads the chosen client in the UI, puts the leftover text (task minus name) into
 * either #newPastWork or #newFollowUp, then calls the server to delete the row from tasks.
 */
function doApplyTaskToClient(chosenClient, chosenWorkType, taskObj, rowId) {
  // 1) Hide any existing client notes
  hideClientNotes();

  // 2) Set the #clientSelect to the chosen client (if it exists)
  var clientSelect = document.getElementById('clientSelect');
  if (clientSelect) {
    // Try to find an exact match
    for (var i = 0; i < clientSelect.options.length; i++) {
      if (clientSelect.options[i].value === chosenClient) {
        clientSelect.selectedIndex = i;
        break;
      }
    }
  }
  // Also set the clientAutocomplete field
  var clientAutocomplete = document.getElementById('clientAutocomplete');
  if (clientAutocomplete) {
    clientAutocomplete.value = chosenClient;
  }

  // 3) Show that client's notes
  showClientNotes();
  window.scrollTo({ top: 0, behavior: 'smooth' });


  // 4) Insert the leftover text into Past or Future
  //    "Leftover text" is everything AFTER the extracted name portion
  var leftover = stripNameFromTask(taskObj.fullTask, chosenClient);
  if (chosenWorkType === 'PAST') {
    document.getElementById('newPastWork').value = leftover;
  } else {
    document.getElementById('newFollowUp').value = leftover;
  }

  // 5) Delete the row from the tasks spreadsheet
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // Remove that task row from the DOM
      var rowDiv = document.getElementById(rowId);
      if (rowDiv) rowDiv.remove();
      alert("Task successfully applied and removed from Tasks.");
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Error removing task from spreadsheet: " + err.message);
    })
    .deleteTaskRow(taskObj.rowIdInTasks); // We'll define deleteTaskRow() in Code.gs
}

/**
 * Strips the leading name portion from the full task text. This is rough logic ‚Äì modify as needed.
 */
function stripNameFromTask(fullTask, chosenClientName) {
  // Simplify by removing the first words that match chosenClientName, or at least the first 2-3 words
  // For best results, do a simple approach:
  var re = new RegExp(chosenClientName, 'i');
  var leftover = fullTask.replace(re, '').trim();
  return leftover;
}

/*********************************
 * SNIPPET: findClientName
 * Paste this directly after the
 * stripNameFromTask function‚Äôs
 * closing brace
 *********************************/
function findClientName(fullTask, clientNamesArray) {
  // This loops through each client name in the array
  for (var i = 0; i < clientNamesArray.length; i++) {
    var name = clientNamesArray[i];
    // Create a case-insensitive RegExp for that name
    var re = new RegExp(name, 'i');
    // If the name is found anywhere in fullTask...
    if (re.test(fullTask)) {
      // ...immediately return it.
      return name;
    }
  }
  // If no name is found, return null
  return null;
}

function scrollToBottomInOneSecond() {
  // Current scroll position
  const startY = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;

  // Target scroll position (bottom of the page)
  const doc = document.documentElement;
  const body = document.body;
  const fullHeight = Math.max(
    body.scrollHeight, body.offsetHeight, body.clientHeight,
    doc.scrollHeight,  doc.offsetHeight,  doc.clientHeight
  );
  const targetY = Math.max(0, fullHeight - window.innerHeight);

  // If we're basically there, do nothing
  if (Math.abs(targetY - startY) < 2) return;

  const duration = 1000; // 1 second
  let startTime = null;

  // Ease-in-out (quadratic) for a pleasant feel
  function easeInOutQuad(t) {
    return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
  }

  function step(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = timestamp - startTime;
    const t = Math.min(1, elapsed / duration);
    const eased = easeInOutQuad(t);
    const y = startY + (targetY - startY) * eased;
    window.scrollTo(0, y);

    if (t < 1) {
      requestAnimationFrame(step);
    }
  }

  requestAnimationFrame(step);
}

// Build chip element for the highlighted FOLLOW UP line.
// If initials/date are blank, show placeholder " | " with neutral color.

function createChipElement(clientName, initials, mmddyy) {
  var safeInitials = (initials || "").toUpperCase().trim();

  // ‚úÖ Normalize the date to always display as M/D/YY
  var safeDate = normalizeChipDate(mmddyy || "");

  var chip = document.createElement('span');
  chip.className = 'chip ' + (safeInitials ? safeInitials : 'EMPTY');

  // If both initials and date are empty, show a neutral placeholder
  if (!safeInitials && !safeDate) {
    var ph = document.createElement('span');
    ph.className = 'chip-assign';
    ph.textContent = '(ASSIGN)';
    chip.appendChild(ph);
  } else {
    // Render "INITIALS | M/D/YY"
    var initEl = document.createElement('span');
    initEl.className = 'chip-initials';
    initEl.textContent = safeInitials;

    var sepEl = document.createElement('span');
    sepEl.className = 'chip-sep';
    sepEl.textContent = ' ‚Ä¢ ';

    var dateEl = document.createElement('span');
    dateEl.className = 'chip-date';
    dateEl.textContent = safeDate;

    chip.appendChild(initEl);
    chip.appendChild(sepEl);   // <-- you were missing this line
    chip.appendChild(dateEl);
  }

  // Clicking the chip still opens the inline editor
  chip.addEventListener('click', function(ev) {
    ev.stopPropagation();
    openChipEditor(chip, clientName, safeInitials, safeDate);
  });

  return chip;
}

// READ-ONLY chip for the Top Clients list (no click-to-edit)
function createChipElementReadOnly(clientName, initials, mmddyy) {
  var safeInitials = (initials || "").toUpperCase().trim();

  // Reuse your normalizer
  var safeDate = normalizeChipDate(mmddyy || "");

  var chip = document.createElement('span');
  chip.className = 'chip ' + (safeInitials ? safeInitials : 'EMPTY');

  if (!safeInitials && !safeDate) {
    var ph = document.createElement('span');
    ph.className = 'chip-assign';
    ph.textContent = '(ASSIGN)';
    chip.appendChild(ph);
  } else {
    var initEl = document.createElement('span');
    initEl.className = 'chip-initials';
    initEl.textContent = safeInitials;

    var sepEl = document.createElement('span');
    sepEl.className = 'chip-sep';
    sepEl.textContent = ' | ';

    var dateEl = document.createElement('span');
    dateEl.className = 'chip-date';
    dateEl.textContent = safeDate;

    chip.appendChild(initEl);
    chip.appendChild(sepEl);
    chip.appendChild(dateEl);
  }

  // IMPORTANT: no click handler attached ‚Äî read-only.
  return chip;
}




// === REPLACEMENT: Auto-save chip editor (no Save/Cancel buttons) ===
function openChipEditor(anchorEl, clientName, initials, mmddyy) {
  closeAnyChipEditor(); // ensure only one editor open

  var editor = document.createElement('div');
  editor.id = 'chipEditorPopover';
  editor.style.position = 'absolute';
  editor.style.zIndex = '99999';
  editor.style.background = '#fff';
  editor.style.border = '1px solid #ccc';
  editor.style.borderRadius = '8px';
  editor.style.padding = '8px';
  editor.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
  editor.style.fontSize = '14px';
  editor.style.display = 'flex';
  editor.style.alignItems = 'center';
  editor.style.gap = '8px';

  // initials dropdown
  var sel = document.createElement('select');
  ['','RB','JB','QC','TEAM','BDAY'].forEach(function(opt){
    var o = document.createElement('option');
    o.value = opt; o.textContent = opt || '(none)';
    if (opt === (initials || '')) o.selected = true;
    sel.appendChild(o);
  });

  // date input (native)
  var dateInput = document.createElement('input');
  dateInput.type = 'date';

  // prefill date from MM/DD/YY ‚Üí YYYY-MM-DD
  if (mmddyy) {
    var m = mmddyy.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      var y = parseInt(m[3],10); if (y < 100) y = 2000 + y;
      var iso = y + '-' + String(parseInt(m[1],10)).padStart(2,'0') + '-' + String(parseInt(m[2],10)).padStart(2,'0');
      dateInput.value = iso;
    }
  }

  editor.appendChild(sel);
  editor.appendChild(dateInput);
  document.body.appendChild(editor);

  // position next to chip
  var rect = anchorEl.getBoundingClientRect();
  editor.style.top = (window.scrollY + rect.bottom + 6) + 'px';
  editor.style.left = (window.scrollX + rect.left) + 'px';

  // helper: run save with current select + date values
  function saveChipAndClose() {
    var newInitials = sel.value;
    var newIso = dateInput.value || ''; // '' allowed

    // Show loading, save, update chip, close editor
    showLoadingBar();
    google.script.run.withSuccessHandler(function(){
      hideLoadingBar();

      // Convert ISO ‚Üí MM/DD/YY for chip display
      var newMmddyy = '';
      if (newIso) {
        var d = new Date(newIso);
        newMmddyy = (d.getMonth()+1).toString().padStart(2,'0') + '/' +
                    d.getDate().toString().padStart(2,'0') + '/' +
                    (d.getFullYear()%100).toString().padStart(2,'0');
      }

      renderChipInto(anchorEl, clientName, newInitials, newMmddyy);
      closeAnyChipEditor();
      // ---- NEW: ensure BOTH chip instances refresh ----
try {
  // Refresh the Top Clients list (updates chips inside More/Less cards)

retriggerTopClientsFilter();


  // If the currently loaded notes belong to this client, refresh them too
  var sel = document.getElementById('clientSelect');
  if (sel && sel.value && sel.value.trim() === clientName.trim()) {
    if (typeof showClientNotes === 'function') {
      showClientNotes();
    }
  }
} catch (e) {
  console.warn('Post-save refresh warning:', e);
}

    }).withFailureHandler(function(err){
      hideLoadingBar();
      alert('Failed to update chip: ' + err.message);
    }).updateClientChip(clientName, newInitials, newIso || null);
  }

  // AUTO-SAVE behaviors:
  // 1) Change initials ‚Üí save immediately
  sel.addEventListener('change', saveChipAndClose);
  // 2) Pick a date ‚Üí save immediately
  dateInput.addEventListener('change', saveChipAndClose);
  // 3) Click outside the popover ‚Üí close without saving (no change made)
  setTimeout(function() { // defer to avoid immediate close on open
    document.addEventListener('mousedown', outsideHandler);
  }, 0);

  function outsideHandler(e) {
    var ed = document.getElementById('chipEditorPopover');
    if (ed && !ed.contains(e.target)) {
      closeAnyChipEditor();
      document.removeEventListener('mousedown', outsideHandler);
    }
  }
}


function closeAnyChipEditor() {
  var existing = document.getElementById('chipEditorPopover');
  if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
}

// Swap the existing chip node with a re-rendered one (keeps position).
function renderChipInto(oldChipEl, clientName, initials, mmddyy) {
  var parent = oldChipEl.parentNode;
  if (!parent) return;
  var newChip = createChipElement(clientName, initials, mmddyy);
  parent.replaceChild(newChip, oldChipEl);
}
// === HELPER: convert chip date to sortable timestamp ===
// Blank or invalid dates will return NEGATIVE_INFINITY so they sort to the TOP.
function chipDateToTime(raw) {
  if (!raw) return Number.NEGATIVE_INFINITY; // blanks go to top
  var s = normalizeChipDate(raw);
  if (!s) return Number.NEGATIVE_INFINITY;

  // Match MM/DD/YY or MM/DD/YYYY
  var m1 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2}|\d{4})$/);
  if (m1) {
    var mm = parseInt(m1[1],10), dd = parseInt(m1[2],10), yy = parseInt(m1[3],10);
    if (yy < 100) yy += 2000;
    var d1 = new Date(yy, mm-1, dd);
    return isNaN(d1.getTime()) ? Number.NEGATIVE_INFINITY : d1.getTime();
  }

  // Match YYYY-MM-DD
  var m2 = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (m2) {
    var y = parseInt(m2[1],10), m = parseInt(m2[2],10), d = parseInt(m2[3],10);
    var d2 = new Date(y, m-1, d);
    return isNaN(d2.getTime()) ? Number.NEGATIVE_INFINITY : d2.getTime();
  }

  // Fallback
  var d3 = new Date(s);
  return isNaN(d3.getTime()) ? Number.NEGATIVE_INFINITY : d3.getTime();
}

function onToplistSuggestionBlur(clientName, newValue) {
  if (!clientName) return;
  if (typeof showLoadingBar === 'function') showLoadingBar();
  google.script.run
    .withSuccessHandler(function() {
     if (typeof updateInProgressDom === 'function') {
        updateInProgressDom(clientName, newValue);
      }
      if (typeof refreshTopClientsPreservingScroll === 'function') {
        refreshTopClientsPreservingScroll();
      }
      if (typeof hideLoadingBar === 'function') hideLoadingBar();
    })
    .withFailureHandler(function(err) {
      if (typeof hideLoadingBar === 'function') hideLoadingBar();

      alert('Error saving Ricky\'s Suggestion: ' + (err && err.message ? err.message : err));
    })
    .updateClientColumnL(clientName, newValue);
}


function ensureSuggestionsButtonInToolbar() {
  // Find a host element in the existing toolbar (try both IDs you already use)
  var host = document.getElementById('topClientsFilter') || 
             document.getElementById('userSelection');

  if (!host) return; // nothing to do if toolbar isn't mounted yet

  // Avoid duplicates
  if (document.getElementById('suggestionsToggleBtn')) return;

  // Style the toolbar row if not already styled
  var toolbarRow = host.parentElement;
  if (toolbarRow && !toolbarRow.classList.contains('top-controls')) {
    toolbarRow.classList.add('top-controls');
  }

  // Create the inline SUGGESTIONS toggle button
  var btn = document.createElement('button');
  btn.id = 'suggestionsToggleBtn';
  btn.type = 'button';
  btn.textContent = 'üí°';
  btn.onclick = function () {
    if (typeof toggleSuggestions === 'function') toggleSuggestions();
  };

  // Insert immediately after the filter control
  host.insertAdjacentElement('afterend', btn);
}

// Run once after page builds (safe to call multiple times)
document.addEventListener('DOMContentLoaded', ensureSuggestionsButtonInToolbar);
// Also run after you redraw/refresh top clients, just in case:
(function patchAfterDraw(){
  var _old = window.showTopClients;
  if (typeof _old === 'function') {
    window.showTopClients = function() {
      var r = _old.apply(this, arguments);
      try { ensureSuggestionsButtonInToolbar(); } catch(e){}
      return r;
    };
  }
})();

// Wire #categorySelect change to handle normal updates vs. NEW CATEGORY modal
(function wireCategorySelectChange(){
  var sel = document.getElementById('categorySelect');
  if (!sel || sel._wiredForNewCat) return;
  sel.addEventListener('change', function() {
    var v = sel.value;

    if (v === '__NEW__') {
      // Open modal and revert select to prior value to avoid accidental save
      sel.value = '';
      openNewCategoryModal();
      return;
    }

    // Normal path: save the chosen category for the current client
    if (v) {
      updateCategory();       // already defined in your file
      updateCategoryLabel();  // already defined in your file
    }
  });
  sel._wiredForNewCat = true;
})();



  // Example renderer (adapt to your UI)
  function renderRecentBar(items) {
    // items: [{name, tsISO, category, columnL, chipInitials, chipDate}, ...]
    // Build your pill bar here. For example:
    // - show name
    // - show category as a small badge
    // - show chipInitials + chipDate as a tiny chip
    // - maybe a small dot if columnL (in-progress) is non-empty
  }

  // On initial load
  document.addEventListener('DOMContentLoaded', refreshRecentBar);



  // Build the pills
  function renderRecentBar(items) {
    const bar = document.getElementById('recentClientsBar');
    if (!bar) return;

    if (!items || !items.length) {
      bar.innerHTML = `<span style="opacity:.7">No recent clients yet.</span>`;
      return;
    }

    bar.innerHTML = items.map(it => {
      const hasInProgress = it.columnL && it.columnL.trim().length > 0;
      const dot = `<span class="rc-dot ${hasInProgress ? '' : 'rc-muted'}" title="${hasInProgress ? 'In Progress' : 'No In Progress'}"></span>`;
      const cat = it.category ? `<span class="rc-cat" title="Category">${it.category}</span>` : '';
      const chip = (it.chipInitials || it.chipDate)
          ? `<span class="rc-chip" title="Owner/Date">${(it.chipInitials||'').trim()} ${(it.chipDate||'').trim()}</span>` : '';
      const displayName = formatRecentClientName(it.name);
      return `
        <button class="recent-pill" onclick="selectClientFromRecent('${escapeHtml(it.name)}')">
          ${dot}
          <span class="rc-name">${escapeHtml(displayName)}</span>
          ${cat}
          ${chip}
        </button>
      `;
    }).join('');
  }

  // When a pill is clicked, do whatever your app already does to open a client:
  function selectClientFromRecent(name) {
    // Example: set your dropdown + trigger your existing load
    const dd = document.getElementById('clientDropdown');
    if (dd) {
      dd.value = name;
      // call your existing loader function if you have one
      if (typeof onClientSelected === 'function') onClientSelected();
      // also re-log to bump it to top (optional)
      onClientOpened(name);
    }
  }

  // Simple HTML escaper for safety
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // Load the bar on page load
  document.addEventListener('DOMContentLoaded', refreshRecentBar);

 // 1) Call this whenever a client is opened/loaded in your UI
  function onClientOpened(clientName) {
    if (!clientName) return;
    google.script.run
      .withSuccessHandler(refreshRecentBar)
      .logRecentClient(clientName, 3);
  }

  // 2) Ask server for the list, then render
  function refreshRecentBar() {
    google.script.run
      .withSuccessHandler(renderRecentBar)
      .getRecentClients(3, /* refreshMetadata */ true);
  }

  // 3) Paint the pills into #recentClientsBar
  function renderRecentBar(items) {
    const bar = document.getElementById('recentClientsBar');
    if (!bar) return;

    if (!items || !items.length) {
      bar.innerHTML = `<span style="opacity:.4">No recent clients yet.</span>`;
      return;
    }

    bar.innerHTML = items.map(it => {
      const hasInProgress = it.columnL && it.columnL.trim().length > 0;
      const dot  = `<span class="rc-dot ${hasInProgress ? '' : 'rc-muted'}" title="${hasInProgress ? 'In Progress' : 'No In Progress'}"></span>`;
      const cat  = it.category ? `<span class="rc-cat" title="Category">${escapeHTML(it.category)}</span>` : '';
      const chip = (it.chipInitials || it.chipDate)
        ? `<span class="rc-chip" title="Owner/Date">${escapeHTML(it.chipInitials || '')} ${escapeHTML(it.chipDate || '')}</span>`
        : '';
      const displayName = formatRecentClientName(it.name);
      return `
        <button class="recent-pill" onclick="selectClientFromRecent('${escapeHTML(it.name)}')">
          ${dot}
          <span class="rc-name">${escapeHTML(displayName)}</span>
          ${cat}
          ${chip}
        </button>
      `;
    }).join('');
  }

  // 4) What happens when a pill is clicked
  function selectClientFromRecent(name) {
    // Put the name into your dropdown + trigger your existing loader
    const dd = document.getElementById('clientSelect');
    if (dd) {
      dd.value = name;
      // Mirror the text in your autocomplete input
      const txt = [...dd.options].find(o => o.value === name)?.text || name;
      const auto = document.getElementById('clientAutocomplete');
      if (auto) auto.value = txt;

      if (typeof showClientNotes === 'function') showClientNotes(); // your existing flow
      onClientOpened(name); // bump to top
      // Optional: scroll to top where your notes live
      if (typeof scrollToTop === 'function') scrollToTop();
    }
  }

// Re-run the Top Clients filter as if the dropdown changed (even if value didn‚Äôt)
function retriggerTopClientsFilter() {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  try {
    dd.dispatchEvent(new Event('change', { bubbles: true }));
  } catch (_) {
    // Fallback if the listener ignores synthetic events
    if (typeof syncClientsListToDropdown === 'function') {
      syncClientsListToDropdown();
    } else if (typeof handleTopClientsFilterChange === 'function') {
      handleTopClientsFilterChange(dd.value || 'JB');
    }
  }
}


  // 5) Load the bar on first paint
  document.addEventListener('DOMContentLoaded', refreshRecentBar);

// --- helpers for the unified dropdown behavior ---
function isOwnerKey(v) {
  return ['JB','RB','QC','TEAM','BDAY'].includes(String(v || '').toUpperCase());
}

function normalizeFilterValue(v) {
  return String(v || '').trim();
}

// Accept both tokens (BRIEFCASE/STAR/GRADCAP/PHONE) and the actual emoji
function asEmojiOrNull(v) {
  const s = normalizeFilterValue(v).toUpperCase();
  const map = { BRIEFCASE:'üíº', STAR:'‚≠ê', GRADCAP:'üéì', PHONE:'üìû' };
  if (map[s]) return map[s];
  // if they actually chose an emoji, pass it through
  const isEmoji = /[\u{1F300}-\u{1FAFF}]/u.test(v || '');
  return isEmoji ? v : null;
}

// Build a safe chip "search string" from Column P (free text or initials)
// Works even if your data only has initials; extend if you add fields later.
function chipSearchString(client) {
  // Prefer free text if you store it; otherwise fall back to initials.
  const pText = client.chipText || client.chipLabel || '';
  const initials = client.chipInitials || client.initials || '';
  return (pText + ' ' + initials).trim().toLowerCase();
}

// True if Column L (lightbulb/suggestions) contains the emoji
function suggestionsContainEmoji(client, emoji) {
  const L = client.columnLContent || client.suggestion || '';
  return String(L).includes(emoji);
}


(() => {
  // === STATE ===
  let currentClient = null;
  let currentCategory = null;
  let categories = []; // from getUniqueCategories()
  let saving = false;

  // === ELEMENTS ===
  const catCalWrap   = () => document.getElementById('catCalWrap');
  const catInput     = () => document.getElementById('categoryCombo');
  const catList      = () => document.getElementById('categoryList');
  const calendarBtn  = () => document.getElementById('calendarBtn');

  const apptModal    = () => document.getElementById('apptModal');
  const apptClose    = () => document.getElementById('apptClose');
  const apptCancel   = () => document.getElementById('apptCancel');
  const apptSave     = () => document.getElementById('apptSave');
  const apptDate     = () => document.getElementById('apptDate');
  const apptTime     = () => document.getElementById('apptTime');
  const apptTitle    = () => document.getElementById('apptTitle');

  // === UTIL ===
  function setTooltip(el, text) {
    if (!el) return;
    el.title = text || '';
  }
  function setDisabled(disabled) {
    catInput().disabled = disabled;
    calendarBtn().disabled = disabled;
  }
  function toast(msg) {
    if (window.showToast) { showToast(msg); } else { alert(msg); }
  }
  function populateDatalist(list) {
    categories = list || [];
    catList().innerHTML = '';
    categories.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c;
      catList().appendChild(opt);
    });
  }
  function refreshCategoryUI(cat) {
    currentCategory = cat || '';
    catInput().value = currentCategory || '';
    catInput().placeholder = currentCategory ? currentCategory : 'Select category';
    setTooltip(catInput(), currentCategory || 'Select category');
  }
  function showCatUI(show) {
    catCalWrap().style.display = show ? 'inline-flex' : 'none';
  }

  // Debounce helper ~200ms
  function debounce(fn, wait=200) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
  }

  // === PUBLIC HOOK from your autocomplete selection ===
  // Call this when user selects a client in your existing autocomplete.
  window.onClientSelectedForBar = function(clientName, displayText) {
    currentClient = clientName;
    showCatUI(!!currentClient);

    // keep the full bar‚Äôs tooltip showing the full text that might overflow
    const barEl = document.querySelector('.your-autocomplete-input-selector'); // update if you want
    if (barEl) setTooltip(barEl, displayText || clientName);

    // get list of categories + current category
    showLoadingBar && showLoadingBar();
    setDisabled(true);

    google.script.run
      .withSuccessHandler(list => {
        populateDatalist(list);
        // pull current category quickly (cheapest reliable path)
        google.script.run.withSuccessHandler(det => {
          const cat = (det && det.notes && det.notes.length) ? (det.notes[0].category || '') : '';
          refreshCategoryUI(cat);
          hideLoadingBar && hideLoadingBar();
          setDisabled(false);
        }).withFailureHandler(() => {
          refreshCategoryUI(''); // unknown
          hideLoadingBar && hideLoadingBar();
          setDisabled(false);
        }).getClientDetails(currentClient);
      })
      .withFailureHandler(() => {
        populateDatalist([]);
        refreshCategoryUI('');
        hideLoadingBar && hideLoadingBar();
        setDisabled(false);
      })
      .getUniqueCategories();
  };

  // === SAVE CATEGORY (enter/change) ===
  function saveCategory(newVal) {
    if (!currentClient) return;
    const newCategory = (newVal || '').trim();
    const prev = currentCategory;

    if (!newCategory || newCategory === prev) {
      // no change
      refreshCategoryUI(prev);
      return;
    }

    if (saving) return;
    saving = true;

    showLoadingBar && showLoadingBar();
    setDisabled(true);
    catInput().setAttribute('aria-busy', 'true');

    google.script.run
      .withSuccessHandler(res => {
        saving = false;
        catInput().removeAttribute('aria-busy');
        hideLoadingBar && hideLoadingBar();
        setDisabled(false);

        if (res && res.ok) {
          refreshCategoryUI(newCategory);
          // Update any dependents you show under today's date etc.
          if (window.fetchAndRenderTopClientsFromDropdown) {
            try { fetchAndRenderTopClientsFromDropdown(); } catch(e){}
          }
        } else {
          refreshCategoryUI(prev);
          toast('Category change fail');
        }
      })
      .withFailureHandler(() => {
        saving = false;
        catInput().removeAttribute('aria-busy');
        hideLoadingBar && hideLoadingBar();
        setDisabled(false);
        refreshCategoryUI(prev);
        toast('Category change fail');
      })
      .updateClientCategory(currentClient, newCategory);
  }

  // Input events: Enter = save (type-to-create supported), change = save
  catInput().addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      saveCategory(catInput().value);
    }
  });
  catInput().addEventListener('change', () => saveCategory(catInput().value));
  // Optional debounced ‚Äúpreview‚Äù (not saving): keep tooltip updated
  catInput().addEventListener('input', debounce(() => {
    setTooltip(catInput(), catInput().value || currentCategory || 'Select category');
  }, 200));

  // === CALENDAR MODAL ===
  function openApptModal() {
    if (!currentClient) return;
    apptTitle().textContent = `Schedule appointment ‚Äî ${currentClient}`;
    apptDate().value = ''; apptTime().value = '';
    apptModal().style.display = 'flex';
  }
  function closeApptModal() {
    apptModal().style.display = 'none';
  }

  calendarBtn().addEventListener('click', openApptModal);
  apptClose().addEventListener('click', closeApptModal);
  apptCancel().addEventListener('click', closeApptModal);

  apptSave().addEventListener('click', () => {
    const d = apptDate().value; // 'yyyy-mm-dd'
    const t = apptTime().value; // 'HH:mm'
    if (!d || !t) { toast('Please choose date and time'); return; }

    showLoadingBar && showLoadingBar();
    setDisabled(true);

    google.script.run
      .withSuccessHandler(msg => {
        hideLoadingBar && hideLoadingBar();
        setDisabled(false);
        closeApptModal();
        toast(msg || 'Appointment scheduled');
        // also append to follow-up UI if you do that elsewhere
      })
      .withFailureHandler(err => {
        hideLoadingBar && hideLoadingBar();
        setDisabled(false);
        toast('Failed to add appointment.');
      })
      .addAppointmentToCalendar(currentClient, d, t);
  });

  // OPTIONAL: If your autocomplete already has a ‚Äúselection‚Äù handler,
  // just call window.onClientSelectedForBar(name, label) from there.
})();

</script>




</body>
</html>